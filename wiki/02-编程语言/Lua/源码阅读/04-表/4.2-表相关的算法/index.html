<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    
    <title>4.2 表相关的算法 | Back Number</title>
    
    
        <meta name="keywords" content="Lua">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="在上一节中，我们简要提到了表的数组部分和哈希部分会进行自适应调整；以正整数为键的数据可能会存储在数组部分，也可能存储在哈希部分；存储在数组部分时，它的键就是数组的索引；而存储在哈希部分时，就是单纯的键值对。Lua有一个标准去做这个调整，保证数组和哈希部分有最优的边界。 我们在来看这个例子： 123local t &#x3D; &#123;&#125;t[1] &#x3D; 0t[100] &#x3D; 0 插入的这两个元">
<meta property="og:type" content="article">
<meta property="og:title" content="4.2 表相关的算法">
<meta property="og:url" content="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/4.2-%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Back Number">
<meta property="og:description" content="在上一节中，我们简要提到了表的数组部分和哈希部分会进行自适应调整；以正整数为键的数据可能会存储在数组部分，也可能存储在哈希部分；存储在数组部分时，它的键就是数组的索引；而存储在哈希部分时，就是单纯的键值对。Lua有一个标准去做这个调整，保证数组和哈希部分有最优的边界。 我们在来看这个例子： 123local t &#x3D; &#123;&#125;t[1] &#x3D; 0t[100] &#x3D; 0 插入的这两个元">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/4.2-%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AE%97%E6%B3%95/LuaTableHash.drawio.png">
<meta property="og:image" content="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/4.2-%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AE%97%E6%B3%95/LuaTableRehash.drawio.png">
<meta property="og:image" content="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/4.2-%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AE%97%E6%B3%95/202401141725.png">
<meta property="article:published_time" content="2025-01-14T03:05:06.000Z">
<meta property="article:modified_time" content="2025-01-14T10:01:19.410Z">
<meta property="article:author" content="Z.P.Y">
<meta property="article:tag" content="Lua">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/4.2-%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AE%97%E6%B3%95/LuaTableHash.drawio.png">
    

    

    
        <link rel="icon" href="/favicon.ico">
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">

    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
<meta name="generator" content="Hexo 7.1.1"><link rel="alternate" href="/atom.xml" title="Back Number" type="application/atom+xml">
</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">Back Number</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">首页</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/tags">标签</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">首页</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/tags">标签</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    
        
    <div class="widget-wrap">
        <h3 class="widget-title"><span>标签</span></h3>
        <div class="widget">
            <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CS-101/" rel="tag">CS-101</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Compression/" rel="tag">Compression</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EditorExtend/" rel="tag">EditorExtend</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Issues/" rel="tag">Issues</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lua/" rel="tag">Lua</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/UIElements/" rel="tag">UIElements</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity/" rel="tag">Unity</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unity%E5%8A%9F%E8%83%BD%E5%AE%9E%E4%BE%8B/" rel="tag">Unity功能实例</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" rel="tag">数据结构和算法</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9/" rel="tag">易混淆点</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">游戏编程设计模式</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-02-编程语言/Lua/源码阅读/04-表/4.2-表相关的算法" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link-link" href="/tags/Lua/" rel="tag">Lua</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/4.2-%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AE%97%E6%B3%95/">
            <time datetime="2025-01-14T03:05:06.000Z" itemprop="datePublished">2025-01-14</time>
        </a>
    </div>


                        <!-- 
                            <i class="fa fa-bar-chart"></i>
                            <span id="busuanzi_container_site_pv"><span id="busuanzi_value_page_pv"></span></span>
                         -->
                        
                            <div class="article-meta-button">
                                <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/PeiyuZou/peiyuZou.github.io/raw/master/source/_posts/02-编程语言/Lua/源码阅读/04-表/4.2-表相关的算法.md"> Source </a>
                            </div>
                            <!-- <div class="article-meta-button">
                                <a target="_blank" rel="noopener" href='https://github.com/PeiyuZou/peiyuZou.github.io/edit/master/source/_posts/02-编程语言/Lua/源码阅读/04-表/4.2-表相关的算法.md'> Edit </a>
                            </div>
                            <div class="article-meta-button">
                                <a target="_blank" rel="noopener" href='https://github.com/PeiyuZou/peiyuZou.github.io/commits/master/source/_posts/02-编程语言/Lua/源码阅读/04-表/4.2-表相关的算法.md'> History </a>
                            </div> -->
                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
            4.2 表相关的算法
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <p>在上一节中，我们简要提到了表的数组部分和哈希部分会进行自适应调整；以正整数为键的数据可能会存储在数组部分，也可能存储在哈希部分；存储在数组部分时，它的键就是数组的索引；而存储在哈希部分时，就是单纯的键值对。Lua有一个标准去做这个调整，保证数组和哈希部分有最优的边界。</p>
<p>我们在来看这个例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">t[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">t[<span class="number">100</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>插入的这两个元素对外部使用者来说，并不能准确地知道它们究竟写入了数组还是哈希表。我们先跳过它的写入逻辑，来看看
table 是怎么处理查找的。</p>
<h1 id="查找">查找</h1>
<p>table 处理查找的伪代码如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> key &gt; <span class="number">0</span> <span class="keyword">and</span> key &lt;= 数组大小 <span class="keyword">then</span> <span class="comment">--在数组索引范围内</span></span><br><span class="line">    尝试在数组部分查找</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    尝试在哈希部分查找</span><br><span class="line">    <span class="comment">--[[</span></span><br><span class="line"><span class="comment">        1.计算出key的哈希值，根据哈希值访问Node数组得到哈希桶位置</span></span><br><span class="line"><span class="comment">        2.遍历哈希桶链表，直到找到对应key</span></span><br><span class="line"><span class="comment">    ]]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>可以看出来，一个正整数，只有在数组索引范围内时，其存储才会落在数组部分。否则也会存储在哈希部分。</p>
<h1 id="新增">新增</h1>
<p>上面关于查找的算法可以看出来，table 的哈希部分采用链地址法。Lua
将哈希桶所在的位置称为
<code>mainposition</code>。哈希部分的链表结构和普通链地址法的哈希表一致：</p>
<p><img src="LuaTableHash.drawio.png" alt="table的哈希表结构"><br>
</p>
<p>那么 Lua 在往 table
新增数据的时候，是如何处理的？让我们关注两个入口函数
<code>luaH_set</code> 和 <code>luaH_setint</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaH_set</span> <span class="params">(lua_State *L, Table *t, <span class="type">const</span> TValue *key, TValue *value)</span> &#123;</span><br><span class="line">  <span class="type">const</span> TValue *slot = luaH_get(t, key);</span><br><span class="line">  luaH_finishset(L, t, key, slot, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">luaH_setint</span> <span class="params">(lua_State *L, Table *t, lua_Integer key, TValue *value)</span> &#123;</span><br><span class="line">  <span class="type">const</span> TValue *p = luaH_getint(t, key);</span><br><span class="line">  <span class="keyword">if</span> (isabstkey(p)) &#123;</span><br><span class="line">    TValue k;</span><br><span class="line">    setivalue(&amp;k, key);</span><br><span class="line">    luaH_newkey(L, t, &amp;k, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    setobj2t(L, cast(TValue *, p), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和以前的版本不同，Lua 5.4.4 中并没有
<code>luaH_setstr</code>、<code>luaH_setnum</code>
等API，它使用了一个公共的 <code>luaH_set</code>
来满足全部类型数据的新增，这本身是得益于 TValue 结构的优化。</p>
<h2 id="luah_setint">luaH_setint ?</h2>
<p>而 <code>luaH_setint</code>
则是基于整数键做出的优化函数，它会判断整数键是否属于表的数组部分，从而绕过了非整数键的检查逻辑。这样具有更高的访问效率，减少了很多不必要的逻辑计算。</p>
<p>举个例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">t[<span class="number">1</span>] = <span class="string">&quot;a&quot;</span>    <span class="comment">-- 整数键</span></span><br><span class="line">t[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;b&quot;</span> <span class="comment">-- 字符串键</span></span><br></pre></td></tr></table></figure>
<p><code>t[1] = "a"</code></p>
<ul>
<li>Lua会调用 <code>luaH_setint</code></li>
<li>如果键 <code>1</code> 落在数组部分，直接将 <code>"a"</code>
存入数组部分</li>
<li>如果键超出数组范围或数组未分配足够大小，调整 alimit
或将键值存入哈希部分</li>
</ul>
<p><code>t["key"] = "b"</code></p>
<ul>
<li>Lua 会调用 <code>luaH_set</code></li>
<li>根据键的类型（字符串），计算其哈希值，找到对应的哈希桶并插入</li>
</ul>
<h2 id="luah_newkey">luaH_newkey</h2>
<p>不管是调用 <code>luaH_setint</code> 还是
<code>luaH_set</code>，如果新增的键不存在，都牵涉到一个函数
<code>luaH_newkey</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** inserts a new key into a hash table; first, check whether key&#x27;s main</span></span><br><span class="line"><span class="comment">** position is free. If not, check whether colliding node is in its main</span></span><br><span class="line"><span class="comment">** position or not: if it is not, move colliding node to an empty place and</span></span><br><span class="line"><span class="comment">** put new key in its main position; otherwise (colliding node is in its main</span></span><br><span class="line"><span class="comment">** position), new key goes to an empty position.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">luaH_newkey</span> <span class="params">(lua_State *L, Table *t, <span class="type">const</span> TValue *key, TValue *value)</span> &#123;</span><br><span class="line">  Node *mp;</span><br><span class="line">  TValue aux;</span><br><span class="line">  <span class="keyword">if</span> (l_unlikely(ttisnil(key)))</span><br><span class="line">    luaG_runerror(L, <span class="string">&quot;table index is nil&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ttisfloat(key)) &#123;</span><br><span class="line">    lua_Number f = fltvalue(key);</span><br><span class="line">    lua_Integer k;</span><br><span class="line">    <span class="keyword">if</span> (luaV_flttointeger(f, &amp;k, F2Ieq)) &#123;  <span class="comment">/* does key fit in an integer? */</span></span><br><span class="line">      setivalue(&amp;aux, k);</span><br><span class="line">      key = &amp;aux;  <span class="comment">/* insert it as an integer */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l_unlikely(luai_numisnan(f)))</span><br><span class="line">      luaG_runerror(L, <span class="string">&quot;table index is NaN&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ttisnil(value))</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">/* do not insert nil values */</span></span><br><span class="line">  mp = mainpositionTV(t, key);</span><br><span class="line">  <span class="keyword">if</span> (!isempty(gval(mp)) || isdummy(t)) &#123;  <span class="comment">/* main position is taken? */</span></span><br><span class="line">    Node *othern;</span><br><span class="line">    Node *f = getfreepos(t);  <span class="comment">/* get a free place */</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;  <span class="comment">/* cannot find a free place? */</span></span><br><span class="line">      rehash(L, t, key);  <span class="comment">/* grow table */</span></span><br><span class="line">      <span class="comment">/* whatever called &#x27;newkey&#x27; takes care of TM cache */</span></span><br><span class="line">      luaH_set(L, t, key, value);  <span class="comment">/* insert key into grown table */</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lua_assert(!isdummy(t));</span><br><span class="line">    othern = mainpositionfromnode(t, mp);</span><br><span class="line">    <span class="keyword">if</span> (othern != mp) &#123;  <span class="comment">/* is colliding node out of its main position? */</span></span><br><span class="line">      <span class="comment">/* yes; move colliding node into free position */</span></span><br><span class="line">      <span class="keyword">while</span> (othern + gnext(othern) != mp)  <span class="comment">/* find previous */</span></span><br><span class="line">        othern += gnext(othern);</span><br><span class="line">      gnext(othern) = cast_int(f - othern);  <span class="comment">/* rechain to point to &#x27;f&#x27; */</span></span><br><span class="line">      *f = *mp;  <span class="comment">/* copy colliding node into free pos. (mp-&gt;next also goes) */</span></span><br><span class="line">      <span class="keyword">if</span> (gnext(mp) != <span class="number">0</span>) &#123;</span><br><span class="line">        gnext(f) += cast_int(mp - f);  <span class="comment">/* correct &#x27;next&#x27; */</span></span><br><span class="line">        gnext(mp) = <span class="number">0</span>;  <span class="comment">/* now &#x27;mp&#x27; is free */</span></span><br><span class="line">      &#125;</span><br><span class="line">      setempty(gval(mp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* colliding node is in its own main position */</span></span><br><span class="line">      <span class="comment">/* new node will go into free position */</span></span><br><span class="line">      <span class="keyword">if</span> (gnext(mp) != <span class="number">0</span>)</span><br><span class="line">        gnext(f) = cast_int((mp + gnext(mp)) - f);  <span class="comment">/* chain new position */</span></span><br><span class="line">      <span class="keyword">else</span> lua_assert(gnext(f) == <span class="number">0</span>);</span><br><span class="line">      gnext(mp) = cast_int(f - mp);</span><br><span class="line">      mp = f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setnodekey(L, mp, key);</span><br><span class="line">  luaC_barrierback(L, obj2gco(t), key);</span><br><span class="line">  lua_assert(isempty(gval(mp)));</span><br><span class="line">  setobj2t(L, gval(mp), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们逐段分析，看看这个函数做了什么。</p>
<ul>
<li>首先是第 11 ~ 24 行，这一段针对 key
做了一些错误处理，中间的分支对于浮点数键做了处理：如果 key
是一个浮点数，但是它的值是一个整数，那么把 key 作为一个整型值插入。</li>
<li>第 25 行，计算得到 key 的哈希值
mainposition，也就是它在哈希数组中的哈希桶的地址</li>
<li>先看 58 ~ 61 行，该 mainposition 位置空闲，这里直接将 key 和 value
设置给该位置的 Node</li>
<li>再看 26 ~ 57 行，该 mainposition
位置冲突（我们暂且称这里存放的节点为冲突节点）
<ul>
<li>28 ~ 34 行，尝试找一个空闲位置，如果没有，执行一次 rehash 扩张一次
table，然后插入 key 和 value</li>
<li>36 行，有现成的空闲位置，那么计算这个冲突节点的 mainposition
<ul>
<li>37 ~ 48 行，冲突节点的 mainposition
在其它位置，那么把冲突节点移动到一个空闲位置</li>
<li>50 ~ 57 行，冲突节点的 mainposition 就在它当前位置，那么把当前 key
和 value 插入空闲位置</li>
</ul></li>
</ul></li>
</ul>
<p>总结就是：首先，检查 key
的主位置是否空闲。如果不是，则检查冲突节点是否在其主位置：如果不是，则将冲突节点移至空位置并将
key 放入其主位置；否则（冲突节点在其主位置），key 将移至空位置</p>
<blockquote>
<p>这里要重点注意，整个操作都是基于哈希表进行的，而没有关于数组的逻辑。因为在执行
<code>luaH_newkey</code> 之前，一定是通过 <code>luaH_get</code> 或者
<code>luaH_getint</code>
在数组部分检查过了，数组部分不存在的情况下，才会走进
<code>luaH_newkey</code> 的逻辑。</p>
</blockquote>
<h2 id="rehash">rehash</h2>
<p>从前面的代码可见，在空闲空间不足的情况下，table 会自动执行一次
rehash，这个函数就是我们在前一节提到的自适应调整数组部分和哈希部分空间的算法，让我们来看看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** nums[i] = number of keys &#x27;k&#x27; where 2^(i - 1) &lt; k &lt;= 2^i</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rehash</span> <span class="params">(lua_State *L, Table *t, <span class="type">const</span> TValue *ek)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> asize;  <span class="comment">/* optimal size for array part */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> na;  <span class="comment">/* number of keys in the array part */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nums[MAXABITS + <span class="number">1</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> totaluse;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= MAXABITS; i++) nums[i] = <span class="number">0</span>;  <span class="comment">/* reset counts */</span></span><br><span class="line">  setlimittosize(t);</span><br><span class="line">  na = numusearray(t, nums);  <span class="comment">/* count keys in array part */</span></span><br><span class="line">  totaluse = na;  <span class="comment">/* all those keys are integer keys */</span></span><br><span class="line">  totaluse += numusehash(t, nums, &amp;na);  <span class="comment">/* count keys in hash part */</span></span><br><span class="line">  <span class="comment">/* count extra key */</span></span><br><span class="line">  <span class="keyword">if</span> (ttisinteger(ek))</span><br><span class="line">    na += countint(ivalue(ek), nums);</span><br><span class="line">  totaluse++;</span><br><span class="line">  <span class="comment">/* compute new size for array part */</span></span><br><span class="line">  asize = computesizes(nums, &amp;na);</span><br><span class="line">  <span class="comment">/* resize the table to new computed sizes */</span></span><br><span class="line">  luaH_resize(L, t, asize, totaluse - na);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的大致算法思路如下：</p>
<ul>
<li>分配一个数组 <code>nums</code>，初始它的每个元素都是
0，假设它的下标用变量 i 表示，它的每个元素的含义是 key 的值在 <span class="math inline">\({2^{(i-1)}}\)</span> ~ <span class="math inline">\({2^i}\)</span> 之间的元素数量（左开右闭）</li>
<li>遍历数组部分，统计元素数量更新到 nums</li>
<li>遍历哈希部分，只统计正整数键，更新到 nums</li>
<li>此时，整个 table 的正整数 key 的分配已经统计在了 nums 中。接着遍历
nums
数组，找到范围区间内包含的整数数量大于50%，满足这个条件的索引可能有很多个，只要索引最大的那个</li>
<li>这个索引作为重新散列后的数组大小，也就是之前提到的
<code>alimit</code>，凡是超过这个值的 key，就分配到了哈希部分</li>
</ul>
<p>从这个函数可以看出 Lua
的设计思想：简单高效、且尽量节省内存。在重新散列的过程中，除了要增大
table
的大小来容纳新的数据外，还借此机会调整了数组和哈希两个部分，让两部分都尽可能发挥其容纳效率。</p>
<p>下面的图是调整后的数组部分的示意图，每个 2
的幂之间的空间的存储率都大于 50%，这也是 Lua
认为数组达到最大容纳效率的标准：</p>
<p><img src="LuaTableRehash.drawio.png" alt="rehash调整后的数组"><br>
</p>
<h2 id="代价">代价？</h2>
<p>从上面的分析可以看出， Lua
解释器会自动进行重新散列，并且对使用者来说是透明的。从算法和以往对哈希表扩容的经验来看，这个操作的开销不会很小，然而我们在知晓其原理后，可以手动减少它的发生，来看一个例子：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">    t[i] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这个代码执行会触发 3 次 rehash：</p>
<ul>
<li>第一次，为了装下 t[1] , Lua 触发了一次 rehash，数组部分长度设置为
1</li>
<li>第二次，数组长度设置为 2</li>
<li>第三次，数组长度设置为 4</li>
</ul>
<p>也就是说，如果数组部分要装下一个数，需要执行 n 次 rehash，保证 <span class="math inline">\({2^n}\)</span> 大于
key。对于超多元素的表，比如100万个元素，其实也不过触发了 20 次
rehash。但是在一个需要创建大量小长度的表的情况下，这个问题会很严重。但是我们可以尽可能地减少它，来看对比：</p>
<p><img src="202401141725.png" alt="创建大量小长度的表"><br>
</p>
<p>我们使用预填充的方法，减少触发重新散列，这里的优化提高了一倍多的速度！</p>
<h1 id="迭代">迭代</h1>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaH_next</span> <span class="params">(lua_State *L, Table *t, StkId key)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> asize = luaH_realasize(t);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = findindex(L, t, s2v(key), asize);  <span class="comment">/* find original key */</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; asize; i++) &#123;  <span class="comment">/* try first array part */</span></span><br><span class="line">    <span class="keyword">if</span> (!isempty(&amp;t-&gt;<span class="built_in">array</span>[i])) &#123;  <span class="comment">/* a non-empty entry? */</span></span><br><span class="line">      setivalue(s2v(key), i + <span class="number">1</span>);</span><br><span class="line">      setobj2s(L, key + <span class="number">1</span>, &amp;t-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i -= asize; cast_int(i) &lt; sizenode(t); i++) &#123;  <span class="comment">/* hash part */</span></span><br><span class="line">    <span class="keyword">if</span> (!isempty(gval(gnode(t, i)))) &#123;  <span class="comment">/* a non-empty entry? */</span></span><br><span class="line">      Node *n = gnode(t, i);</span><br><span class="line">      getnodekey(L, s2v(key), n);</span><br><span class="line">      setobj2s(L, key + <span class="number">1</span>, gval(n));</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* no more elements */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lua
中表的迭代并没有设计迭代器，很大原因是为了兼容数组部分和哈希部分的访问。</p>
<p>luaH_next 大致的逻辑是在当前 key 的基础上找下一个有效键值对</p>
<ul>
<li>如果 key 是 nil，表示从头开始遍历，否则找到该 key
的位置，然后从下一个位置继续</li>
<li>优先遍历数组部分，因为顺序表遍历更快，找到下一个非空值。</li>
<li>如果数组部分没有找到，再遍历哈希部分，这部分就需要遍历每个桶，找到下一个有效键值对</li>
<li>不管在是数组部分还是哈希部分找到，都将键和值压入 Lua
栈，并返回成功或失败（1或0）</li>
</ul>
<h1 id="取长度">取长度</h1>
<p>在 Lua 中，我们可以提供元方法 <code>__len</code>
来自定义表的取长度方法，Lua 本身默认提供了 <code>#</code>
作为取长度符号。</p>
<p>它的取长度的结果不是 table 的全部元素的数量，而是 table
的序列部分的长度，这个序列部分指表的第一个键的值连续的数据子集，比如：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(#&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">nil</span>,<span class="number">10</span>&#125;) <span class="comment">-- 输出 5</span></span><br></pre></td></tr></table></figure>
<p>这和数组部分无关，尽管它看起来像是数组，这个所谓的序列对哈希部分也是一样的规则：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t1 = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(#t1) <span class="comment">-- 输出 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t2 = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="number">2</span>,</span><br><span class="line">    [<span class="number">5</span>] = <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(#t2) <span class="comment">-- 输出 2</span></span><br></pre></td></tr></table></figure>
<p>如果一个表混合了这两种风格，那么优先取数组部分的长度：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(#&#123;[<span class="number">1</span>] = <span class="number">1</span>, [<span class="number">2</span>] = <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;) <span class="comment">-- 输出 3</span></span><br></pre></td></tr></table></figure>
<p>取长度对应的源码函数是
<code>luaH_getn</code>，这里不赘述了，它的算法思路大致就是先在数组部分取长度，没有取成功就在哈希部分取</p>
<h1 id="总结">总结</h1>
<p>Lua
的表内部分为数组部分和哈希部分，虽然对使用者是透明的，但是理解其存储原理会帮助我们更正确地使用它：</p>
<ul>
<li>尽量避免混用数组和哈希，提升效率</li>
<li>可以通过预先分配的方式，减少 rehash</li>
</ul>

            </div>
        
        <!-- <footer class="article-footer">
        </footer> -->
    </div>
</article>

<!-- zpy dont need foot nav -->
<!-- 
    
<nav id="article-nav">
    
        <a href="/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/5.1-Lua%E6%89%A7%E8%A1%8C%E7%9A%84%E5%A4%A7%E8%87%B4%E8%BF%87%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    5.1 Lua执行的大致过程
                
            </div>
        </a>
    
    
        <a href="/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.1-Lua%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">2.1 Lua中的数据类型</div>
        </a>
    
</nav>


 -->


    
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>
</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            Z.P.Y &copy; 2025 
            <a rel="external nofollow noopener noreferrer" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"></a>
            <br> Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>. Theme - <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/zthxxx/hexo-theme-Wikitten">wikitten</a>
            <!-- 
                <br>
                <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i> <span id="busuanzi_value_site_pv"></span></span>
                &nbsp;|&nbsp;
                <span id="busuanzi_container_site_pv"><i class="fa fa-user"></i> <span id="busuanzi_value_site_uv"></span></span>
             -->
        </div>
    </div>
</footer>

        

    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>