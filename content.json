{"pages":[{"title":"关于","date":"2024-12-06T02:30:17.949Z","path":"about/index.html","text":"Mail：18280318713@163.com Github：https://github.com/PeiyuZou"},{"title":"Categories","date":"2024-12-06T02:30:17.949Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2024-12-06T02:30:17.950Z","path":"tags/index.html","text":""}],"posts":[{"title":"4.5 相关问题","date":"2025-07-16T03:32:12.000Z","path":"wiki/01-计算机科学/数据结构和算法/04-数组与链表/4.5-相关问题/","text":"数组分配在栈 or 堆？ 这个问题不同语言有不同的结果。 对于 C++ 来说，静态数组（编译时确定大小）和 std:array 分配在栈上，动态数组（new[]）和 std::vector 分配在堆上。 对于 C# 来说，都是分配在堆上，但是提供了关键字 stackalloc 在栈上分配： 1Span&lt;int&gt; stackSpan = stackalloc int[100]; 数组存储在栈上和存储在堆上，对时间效率和空间效率是否有影响？ 存储在栈上和堆上的数组都被存储在连续内存空间内，数据操作效率基本一致。然而，栈和堆具有各自的特点，从而导致以下不同点。 分配和释放效率：栈是一块较小的内存，分配由编译器自动完成；而堆内存相对更大，可以在代码中动态分配，更容易碎片化。因此，堆上的分配和释放操作通常比栈上的慢。 大小限制：栈内存相对较小，堆的大小一般受限于可用内存。因此堆更加适合存储大型数组。 灵活性：栈上的数组的大小需要在编译时确定，而堆上的数组的大小可以在运行时动态确定。 为什么数组要求相同类型的元素，而在链表中却没有强调相同类型呢？ 链表由节点组成，通过指针连接，所以各个节点可以存储不同类型的数据。 而数组必须是相同类型，这样才能通过计算偏移量来获取对应元素位置。例如，数组同时包含 int 和 long 两种类型，单个元素分别占用 4 字节和 8 字节 ，此时就不能用公式计算偏移量了，因为数组中包含了两种 “元素长度” 。 在列表末尾添加元素是否时时刻刻都为 \\(O(1)\\) ？ 如果添加元素时超出列表长度，则需要先扩容列表再添加。系统会申请一块新的内存，并将原列表的所有元素搬运过去，这时候时间复杂度就会是 \\(O(n)\\) 。 列表的内存浪费如何避免？ 我们可以通过预先确定列表的最大长度来在初始化时给列表分配一个固定长度的空间并且确保在生命周期内不会扩容，这样可以尽量减少内存空间的浪费，同时也避免了扩容带来的时间和空间的开销。","tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数据结构和算法","slug":"01-计算机科学/数据结构和算法","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"04-数组与链表","slug":"01-计算机科学/数据结构和算法/04-数组与链表","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"}]},{"title":"4.4 内存与缓存","date":"2025-07-16T03:12:31.000Z","path":"wiki/01-计算机科学/数据结构和算法/04-数组与链表/4.4-内存与缓存/","text":"我们在本章讨论的数组和链表，它们分别代表代表了 “连续存储” 和 “分散存储” 两种物理结构，物理结构在很大程度上决定了程序对内存和缓存的使用效率。 计算机存储设备 计算机中包括三种类型的存储设备：硬盘（hard disk）、内存（random-access memory, RAM）、缓存（cache memory） 硬盘 内存 缓存 用途 长期存储数据，包括操作系统、程序、文件等 临时存储当前运行的程序和正在处理的数据 易失性 断电后数据不会丢失 断电后数据会丢失 容量 较大，TB 级别 较小，GB 级别 速度 较慢，几百到几千 MB/s 较快，几十 GB/s 价格（人民币） 较便宜，几毛到几元 / GB 较贵，几十到几百元 / GB 这种多层级的设计并非偶然，而是计算机科学家和工程师们经过深思熟虑的结果： 硬盘难以被内存取代。首先，内存中的数据在断电后会丢失，因此它不适合长期存储数据；其次，内存的成本是硬盘的几十倍，这使得它难以在消费者市场普及。 缓存的大容量和高速度难以兼得。随着 L1、L2、L3 缓存的容量逐步增大，其物理尺寸会变大，与 CPU 核心之间的物理距离会变远，从而导致数据传输时间增加，元素访问延迟变高。在当前技术下，多层级的缓存结构是容量、速度和成本之间的最佳平衡点。 总的来说，硬盘用于长期存储大量数据，内存用于临时存储程序运行中正在处理的数据，而缓存则用于存储经常访问的数据和指令，以提高程序运行效率。三者共同协作，确保计算机系统高效运行。 在程序运行时，数据会从硬盘中被读取到内存中，供 CPU 计算使用。缓存可以看作 CPU 的一部分，它通过智能地从内存加载数据，给 CPU 提供高速的数据读取，从而显著提升程序的执行效率，减少对较慢的内存的依赖。 数据结构的内存效率 在内存空间利用方面，数组和链表各自具有优势和局限性。 一方面，内存是有限的，且同一块内存不能被多个程序共享，因此我们希望数据结构能够尽可能高效地利用空间。数组的元素紧密排列，不需要额外的空间来存储链表节点间的引用（指针），因此空间效率更高。然而，数组需要一次性分配足够的连续内存空间，这可能导致内存浪费，数组扩容也需要额外的时间和空间成本。相比之下，链表以 “节点” 为单位进行动态内存分配和回收，提供了更大的灵活性。 另一方面，在程序运行时，随着反复申请与释放内存，空闲内存的碎片化程度会越来越高，从而导致内存的利用效率降低。数组由于其连续的存储方式，相对不容易导致内存碎片化。相反，链表的元素是分散存储的，在频繁的插入与删除操作中，更容易导致内存碎片化。 数据结构的缓存效率 Cache Miss 缓存虽然在空间容量上远小于内存，但它比内存快得多，在程序执行速度上起着至关重要的作用。由于缓存的容量有限，只能存储一小部分频繁访问的数据，因此当 CPU 尝试访问的数据不在缓存中时，就会发生缓存未命中（cache miss），此时 CPU 不得不从速度较慢的内存中加载所需数据。 显然，“缓存未命中” 越少，CPU 读写数据的效率就越高，程序性能也就越好。我们将 CPU 从缓存中成功获取数据的比例称为缓存命中率（cache hit rate），这个指标通常用来衡量缓存效率。 缓存的机制 为了尽可能达到更高的效率，缓存会采取以下数据加载机制。 缓存行：缓存不是单个字节地存储与加载数据，而是以缓存行为单位。相比于单个字节的传输，缓存行的传输形式更加高效。 预取机制：处理器会尝试预测数据访问模式（例如顺序访问、固定步长跳跃访问等），并根据特定模式将数据加载至缓存之中，从而提升命中率。 空间局部性：如果一个数据被访问，那么它附近的数据可能近期也会被访问。因此，缓存在加载某一数据时，也会加载其附近的数据，以提高命中率。 时间局部性：如果一个数据被访问，那么它在不久的将来很可能再次被访问。缓存利用这一原理，通过保留最近访问过的数据来提高命中率。 缓存层面对比数组和链表 数组和链表对缓存的利用效率是不同的，主要体现在以下几个方面。 占用空间：链表元素比数组元素占用空间更多，导致缓存中容纳的有效数据量更少。 缓存行：链表数据分散在内存各处，而缓存是“按行加载”的，因此加载到无效数据的比例更高。 预取机制：数组比链表的数据访问模式更具“可预测性”，即系统更容易猜出即将被加载的数据。 空间局部性：数组被存储在集中的内存空间中，因此被加载数据附近的数据更有可能即将被访问。 总体而言，数组具有更高的缓存命中率，因此它在操作效率上通常优于链表。这使得在解决算法问题时，基于数组实现的数据结构往往更受欢迎。 需要注意的是，高缓存效率并不意味着数组在所有情况下都优于链表。实际应用中选择哪种数据结构，应根据具体需求来决定。例如，数组和链表都可以实现 “栈” 数据结构，但它们适用于不同场景。 在做算法题时，我们会倾向于选择基于数组实现的栈，因为它提供了更高的操作效率和随机访问的能力，代价仅是需要预先为数组分配一定的内存空间。 如果数据量非常大、动态性很高、栈的预期大小难以估计，那么基于链表实现的栈更加合适。链表能够将大量数据分散存储于内存的不同部分，并且避免了数组扩容产生的额外开销。","tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数据结构和算法","slug":"01-计算机科学/数据结构和算法","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"04-数组与链表","slug":"01-计算机科学/数据结构和算法/04-数组与链表","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"}]},{"title":"4.3 列表","date":"2025-07-16T02:56:55.000Z","path":"wiki/01-计算机科学/数据结构和算法/04-数组与链表/4.3-列表/","text":"列表（list）是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。 链表天然可以看作一个列表，其支持元素增删查改操作，并且可以灵活动态扩容。 数组也支持元素增删查改，但由于其长度不可变，因此只能看作一个具有长度限制的列表。 当使用数组实现列表时，长度不可变的性质会导致列表的实用性降低。这是因为我们通常无法事先确定需要存储多少数据，从而难以选择合适的列表长度。若长度过小，则很可能无法满足使用需求；若长度过大，则会造成内存空间浪费。 为解决此问题，我们可以使用动态数组（dynamic array）来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。 实际上，许多编程语言中的标准库提供的列表是基于动态数组实现的，比如 C# 的 List 和 C++ 的 vector 等。我们下面讨论的 “列表” 请视为 “动态数组” 。 常用操作 1. 初始化 123456/* 初始化列表 */// 无初始值List&lt;int&gt; nums1 = [];// 有初始值int[] numbers = [1, 3, 2, 5, 4];List&lt;int&gt; nums = [.. numbers]; 2. 访问元素 列表本质上是数组，因此可以在 \\(O(1)\\) 时间内访问和更新元素，效率很高。 12345/* 访问元素 */int num = nums[1]; // 访问索引 1 处的元素/* 更新元素 */nums[1] = 0; // 将索引 1 处的元素更新为 0 3. 插入与删除元素 本质上和数组相同，只是封装了接口： 123456789101112131415/* 清空列表 */nums.Clear();/* 在尾部添加元素 */nums.Add(1);nums.Add(3);nums.Add(2);nums.Add(5);nums.Add(4);/* 在中间插入元素 */nums.Insert(3, 6); // 在索引 3 处插入数字 6/* 删除元素 */nums.RemoveAt(3); // 删除索引 3 处的元素 4. 遍历列表 1234567891011/* 通过索引遍历列表 */int count = 0;for (int i = 0; i &lt; nums.Count; i++) &#123; count += nums[i];&#125;/* 直接遍历列表元素 */count = 0;foreach (int num in nums) &#123; count += num;&#125; 5. 拼接列表 123/* 拼接两个列表 */List&lt;int&gt; nums1 = [6, 8, 7, 10, 9];nums.AddRange(nums1); // 将列表 nums1 拼接到 nums 之后 6. 排序列表 完成列表排序后，我们便可以使用在数组类算法题中经常考查的 “二分查找” 和 “双指针” 算法。 12/* 排序列表 */nums.Sort(); // 排序后，列表元素从小到大排列 列表的实现 我们来用 C# 实现一个建议列表，有三个重点设计： 初始容量：选取一个合理的数组初始容量。在本示例中，我们选择 10 作为初始容量。 数量记录：声明一个变量 size ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。 扩容机制：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。在本示例中，我们规定每次将数组扩容至之前的 2 倍。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/* 列表类 */class MyList &#123; private int[] arr; // 数组（存储列表元素） private int arrCapacity = 10; // 列表容量 private int arrSize = 0; // 列表长度（当前元素数量） private readonly int extendRatio = 2; // 每次列表扩容的倍数 /* 构造方法 */ public MyList() &#123; arr = new int[arrCapacity]; &#125; /* 获取列表长度（当前元素数量）*/ public int Size() &#123; return arrSize; &#125; /* 获取列表容量 */ public int Capacity() &#123; return arrCapacity; &#125; /* 访问元素 */ public int Get(int index) &#123; // 索引如果越界，则抛出异常，下同 if (index &lt; 0 || index &gt;= arrSize) throw new IndexOutOfRangeException(&quot;索引越界&quot;); return arr[index]; &#125; /* 更新元素 */ public void Set(int index, int num) &#123; if (index &lt; 0 || index &gt;= arrSize) throw new IndexOutOfRangeException(&quot;索引越界&quot;); arr[index] = num; &#125; /* 在尾部添加元素 */ public void Add(int num) &#123; // 元素数量超出容量时，触发扩容机制 if (arrSize == arrCapacity) ExtendCapacity(); arr[arrSize] = num; // 更新元素数量 arrSize++; &#125; /* 在中间插入元素 */ public void Insert(int index, int num) &#123; if (index &lt; 0 || index &gt;= arrSize) throw new IndexOutOfRangeException(&quot;索引越界&quot;); // 元素数量超出容量时，触发扩容机制 if (arrSize == arrCapacity) ExtendCapacity(); // 将索引 index 以及之后的元素都向后移动一位 for (int j = arrSize - 1; j &gt;= index; j--) &#123; arr[j + 1] = arr[j]; &#125; arr[index] = num; // 更新元素数量 arrSize++; &#125; /* 删除元素 */ public int Remove(int index) &#123; if (index &lt; 0 || index &gt;= arrSize) throw new IndexOutOfRangeException(&quot;索引越界&quot;); int num = arr[index]; // 将将索引 index 之后的元素都向前移动一位 for (int j = index; j &lt; arrSize - 1; j++) &#123; arr[j] = arr[j + 1]; &#125; // 更新元素数量 arrSize--; // 返回被删除的元素 return num; &#125; /* 列表扩容 */ public void ExtendCapacity() &#123; // 新建一个长度为 arrCapacity * extendRatio 的数组，并将原数组复制到新数组 Array.Resize(ref arr, arrCapacity * extendRatio); // 更新列表容量 arrCapacity = arr.Length; &#125; /* 将列表转换为数组 */ public int[] ToArray() &#123; // 仅转换有效长度范围内的列表元素 int[] arr = new int[arrSize]; for (int i = 0; i &lt; arrSize; i++) &#123; arr[i] = Get(i); &#125; return arr; &#125;&#125;","tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数据结构和算法","slug":"01-计算机科学/数据结构和算法","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"04-数组与链表","slug":"01-计算机科学/数据结构和算法/04-数组与链表","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"}]},{"title":"4.2 链表","date":"2025-07-16T02:39:34.000Z","path":"wiki/01-计算机科学/数据结构和算法/04-数组与链表/4.2-链表/","text":"存储数组的内存空间必须是连续的，而当数组非常大时，内存可能无法提供如此大的连续空间。此时链表的灵活性优势就体现出来了。 和数组一样，链表（linked list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过 “引用” 相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。 链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续。 每个节点都包含两项数据：节点的 “值” 和指向下一节点的 “引用” 链表的首个节点被称为 “头节点” ，最后一个节点被称为 “尾节点” 尾节点指向的是 “空” ，它在 Java、C++ 和 Python 中分别被记为 null、nullptr 和 None 在 C、C++、Go 和 Rust 等支持指针的语言中，上述 “引用” 应被替换为 “指针” 链表节点 ListNode 除了包含值，还需额外保存一个引用（指针）。因此在相同数据量下，链表比数组占用更多的内存空间： 12345/* 链表节点类 */class ListNode(int x) &#123; //构造函数 int val = x; // 节点值 ListNode? next; // 指向下一节点的引用&#125; 常用操作 1. 初始化 建立链表分为两步，第一步是初始化各个节点对象，第二步是构建节点之间的引用关系 123456789101112/* 初始化链表 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */// 初始化各个节点ListNode n0 = new(1);ListNode n1 = new(3);ListNode n2 = new(2);ListNode n3 = new(5);ListNode n4 = new(4);// 构建节点之间的引用n0.next = n1;n1.next = n2;n2.next = n3;n3.next = n4; 我们通常将头节点当作链表的代称，比如以上代码中的链表可记作链表 n0 。 2. 插入节点 在链表中插入节点非常容易, 只需改变两个节点引用（指针）即可，时间复杂度为 \\(O(1)\\)，相比数组更高效（特别是大量数据的情况下） 123456/* 在链表的节点 n0 之后插入节点 P */void Insert(ListNode n0, ListNode P) &#123; ListNode? n1 = n0.next; P.next = n1; n0.next = P;&#125; 3. 删除节点 删除节点也非常方便，只需改变一个节点的引用（指针）即可。 请注意，尽管在删除操作完成后节点 P 仍然指向 n1 ，但实际上遍历此链表已经无法访问到 P ，这意味着 P 已经不再属于该链表了。 123456789/* 删除链表的节点 n0 之后的首个节点 */void Remove(ListNode n0) &#123; if (n0.next == null) return; // n0 -&gt; P -&gt; n1 ListNode P = n0.next; ListNode? n1 = P.next; n0.next = n1;&#125; 4. 访问节点 在链表中访问节点的效率较低。需要从头节点出发，逐个向后遍历，直至找到目标节点，时间复杂度为 \\(O(n)\\) ，而数组是 \\(O(1)\\) 123456789/* 访问链表中索引为 index 的节点 */ListNode? Access(ListNode? head, int index) &#123; for (int i = 0; i &lt; index; i++) &#123; if (head == null) return null; head = head.next; &#125; return head;&#125; 5. 查找节点 同样也是线性查找： 1234567891011/* 在链表中查找值为 target 的首个节点 */int Find(ListNode? head, int target) &#123; int index = 0; while (head != null) &#123; if (head.val == target) return index; head = head.next; index++; &#125; return -1;&#125; 数组 vs. 链表 数组 链表 存储方式 连续内存空间 分散内存空间 容量扩展 长度不可变 可灵活扩展 内存效率 元素占用内存少、但可能浪费空间 元素占用内存多 访问元素 \\(O(1)\\) \\(O(n)\\) 添加元素 \\(O(n)\\) \\(O(1)\\) 删除元素 \\(O(n)\\) \\(O(1)\\) 常见链表类型 单向链表：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空 None 。 环形链表：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。 双向链表：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。 123456/* 双向链表节点类 */class ListNode(int x) &#123; // 构造函数 int val = x; // 节点值 ListNode next; // 指向后继节点的引用 ListNode prev; // 指向前驱节点的引用&#125; 典型应用 单向链表 栈与队列：当插入和删除操作都在链表的一端进行时，它表现的特性为先进后出，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现的特性为先进先出，对应队列。 哈希表：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。 图：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。 环形链表 常用于需要周期性操作的场景，比如操作系统的资源调度。 时间片轮转调度算法：在操作系统中，时间片轮转调度算法是一种常见的 CPU 调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU 将切换到下一个进程。这种循环操作可以通过环形链表来实现。 数据缓冲区：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。 双向链表 常用于需要快速查找前一个和后一个元素的场景： 高级数据结构：比如在红黑树、B 树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。 浏览器历史：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。 LRU 算法：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。","tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数据结构和算法","slug":"01-计算机科学/数据结构和算法","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"04-数组与链表","slug":"01-计算机科学/数据结构和算法/04-数组与链表","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"}]},{"title":"4.1 数组","date":"2025-07-16T02:07:42.000Z","path":"wiki/01-计算机科学/数据结构和算法/04-数组与链表/4.1-数组/","text":"数组（array）是一种线性数据结构，其将相同类型的元素存储在连续的内存空间中。 常用操作 1. 初始化 123/* 初始化数组 */int[] arr = new int[5]; // [ 0, 0, 0, 0, 0 ]int[] nums = [1, 3, 2, 5, 4]; 一般有两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为 \\(0\\) 。 2. 访问元素 数组元素被存储在连续的内存空间中，给定数组内存地址（首元素内存地址）和某个元素的索引，通过下图的计算就可以算出指定元素的内存地址： 数组首个元素的索引为 \\(0\\) ，这似乎有些反直觉，因为从 \\(1\\) 开始计数会更自然。但从地址计算公式的角度看，索引本质上是内存地址的偏移量。首个元素的地址偏移量是 \\(0\\) ，因此它的索引为 \\(0\\) 是合理的。 在数组中访问元素非常高效，我们可以在 \\(O(1)\\) 时间内随机访问数组中的任意一个元素 123456789/* 随机访问元素 */int RandomAccess(int[] nums) &#123; Random random = new(); // 在区间 [0, nums.Length) 中随机抽取一个数字 int randomIndex = random.Next(nums.Length); // 获取并返回随机元素 int randomNum = nums[randomIndex]; return randomNum;&#125; 3. 插入元素 在数组中间插入一个元素，需要将该元素之后的所有元素都向后移动一位，再把元素赋值给该索引： 由于数组的长度是固定的，因此插入一个元素必定会导致数组尾部元素 “丢失” 。 123456789/* 在数组的索引 index 处插入元素 num */void Insert(int[] nums, int num, int index) &#123; // 把索引 index 以及之后的所有元素向后移动一位 for (int i = nums.Length - 1; i &gt; index; i--) &#123; nums[i] = nums[i - 1]; &#125; // 将 num 赋给 index 处的元素 nums[index] = num;&#125; 4. 删除元素 若想删除索引 \\(i\\) 处的元素，则需要把索引 \\(i\\) 之后的元素都向前移动一位： 删除元素完成后，原先末尾的元素变得 “无意义” 了，所以我们无须特意去修改它 1234567/* 删除索引 index 处的元素 */void Remove(int[] nums, int index) &#123; // 把索引 index 之后的所有元素向前移动一位 for (int i = index; i &lt; nums.Length - 1; i++) &#123; nums[i] = nums[i + 1]; &#125;&#125; 5. 遍历数组 123456789101112/* 遍历数组 */void Traverse(int[] nums) &#123; int count = 0; // 通过索引遍历数组 for (int i = 0; i &lt; nums.Length; i++) &#123; count += nums[i]; &#125; // 直接遍历数组元素 foreach (int num in nums) &#123; count += num; &#125;&#125; 6. 查找元素 数组查找元素的操作是 “线性查找” ： 12345678/* 在数组中查找指定元素 */int Find(int[] nums, int target) &#123; for (int i = 0; i &lt; nums.Length; i++) &#123; if (nums[i] == target) return i; &#125; return -1;&#125; 7. 扩容数组 在复杂的系统环境中，程序难以保证数组之后的内存空间是可用的，从而无法安全地扩展数组容量。因此在大多数编程语言中，数组的长度是不可变的。 如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个 \\(O(n)\\) 的操作，在数组很大的情况下非常耗时。 1234567891011/* 扩展数组长度 */int[] Extend(int[] nums, int enlarge) &#123; // 初始化一个扩展长度后的数组 int[] res = new int[nums.Length + enlarge]; // 将原数组中的所有元素复制到新数组 for (int i = 0; i &lt; nums.Length; i++) &#123; res[i] = nums[i]; &#125; // 返回扩展后的新数组 return res;&#125; 数组小结 优缺点分析 优点： 空间效率高：数组为数据分配了连续的内存块，无须额外的结构开销，这也让访问、遍历、查找非常快 支持随机访问：数组允许在 \\(O(1)\\) 时间内访问任何元素 缓存局部性：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度 缺点： 插入、删除效率低：时间复杂度高（\\(O(n)\\)），需要移动大量元素 长度不可变：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大 空间浪费：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了 典型应用 随机访问：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。 排序和搜索：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。 查找表：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到 ASCII 码的映射，则可以将字符的 ASCII 码值作为索引，对应的元素存放在数组中的对应位置。 机器学习：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。 数据结构实现：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。","tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数据结构和算法","slug":"01-计算机科学/数据结构和算法","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"04-数组与链表","slug":"01-计算机科学/数据结构和算法/04-数组与链表","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"}]},{"title":"3.3 数字编码","date":"2025-07-15T02:25:59.000Z","path":"wiki/01-计算机科学/数据结构和算法/03-数据结构/3.3-数字编码/","text":"原码、反码和补码 在上一节的表格中我们发现，所有整数类型能够表示的负数都比正数多一个，例如 byte 的取值范围是 \\([-128, 127]\\) 。这个现象比较反直觉，我们需要先了解原码、反码和补码： 原码：我们将数字的二进制表示的最高位视为符号位，其中 0 表示正数， 1 表示负数，其余位表示数字的值。 反码：正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反。 补码：正数的补码与其原码相同，负数的补码是在其反码的基础上加 1 。 在计算机中，数字是以“补码”的形式存储的，这一点非常重要，但为什么不用原码呢？ 原码虽然最直观，但存在一些局限性。一方面，负数的原码不能直接用于运算。例如在原码下计算 \\(1 + (-2)\\) ，得到的结果是 \\(-3\\) ，这显然是不对的。 \\[ \\begin{align} 1 + (-2) &amp;= 0000\\,0001 + 1000\\,0010 \\\\ &amp;= 1000\\,0011 \\\\ &amp;= -3 \\end{align} \\] 为了解决此问题，计算机引入了反码： \\[ \\begin{align} 1 + (-2) &amp;= 0000\\,0001(原码) + 1000\\,0010(原码) \\\\ &amp;= 0000\\,0001(反码) + 1111\\,1101(反码) \\\\ &amp;= 1111\\,1110(反码) \\\\ &amp;= 1000\\,0001(原码) \\\\ &amp;= -1 \\end{align} \\] 另一方面，数字零的原码有 \\(-0\\) 和 \\(+0\\) 两种表示方式。如果是这样，计算机要处理零相关的判断需要同时处理这两个，降低运行效率。为了统一正负零，计算机引入了补码： \\[ \\begin{align} -0 &amp;= 1000\\,0000(原码) \\\\ &amp;= 1111\\,1111(反码) \\\\ &amp;= 1\\,0000\\,0001(补码) \\end{align} \\] 在负零的反码基础上加 1 会产生进位，但 byte 类型的长度只有 8 位，因此溢出到第 9 位的 1 会被舍弃。因此得到的补码中，正负零都是同一个值了。 然而，补码 \\(1000\\,0000\\) 是一个例外，它并没有对应的原码。根据转换方法，我们得到该补码的原码为 \\(0000\\,0000\\) 。这显然是矛盾的，因为该原码表示数字 \\(0\\) ，它的补码应该是自身。计算机规定这个特殊的补码 \\(1000\\,0000\\) 代表 \\(-128\\) 。实际上，\\((-1) + (-127)\\) 在补码下的计算结果就是 \\((-128)\\) 。 \\[ \\begin{align} (-127) + (-1) &amp;= 1111\\,1111(原码) + 1000\\,0001(原码) \\\\ &amp;= 1000\\,0000(反码) + 1111\\,1110(反码) \\\\ &amp;= 1000\\,0001(补码) + 1111\\,1111(补码) \\\\ &amp;= 1000\\,0000(补码) \\\\ &amp;= -128 \\end{align} \\] 你可能已经发现了，上述所有计算都是加法运算。这暗示着一个重要事实：计算机内部的硬件电路主要是基于加法运算设计的。这是因为加法运算相对于其他运算（比如乘法、除法和减法）来说，硬件实现起来更简单，更容易进行并行化处理，运算速度更快。 通过将加法与一些基本逻辑运算结合，计算机能够实现各种其他的数学运算。例如，计算减法 \\(a - b\\) 可以转换为计算加法 \\(a + (-b)\\) ；计算乘法和除法可以转换为计算多次加法或减法。 浮点数编码 我们这里所说的浮点数以 float 为准，double 是同理的 float 相较于 int 而言，两者都是 32 位的长度，但是 float 表示的值范围要大得多，但副作用是牺牲了精度：由于指数位的存在，浮点数 float 的数值越大，相邻两个数字之间的差值就会趋向越大。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数据结构和算法","slug":"01-计算机科学/数据结构和算法","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"03-数据结构","slug":"01-计算机科学/数据结构和算法/03-数据结构","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"3.2 基本数据类型","date":"2025-07-15T01:54:14.000Z","path":"wiki/01-计算机科学/数据结构和算法/03-数据结构/3.2-基本数据类型/","text":"基本数据类型是 CPU 可以直接进行运算的类型。基本数据类型以二进制的形式存储在计算机中。一个二进制位即为 1 比特。在绝大多数现代操作系统中，1 字节（byte）由 8 比特（bit）组成。 以下是 C# 中的基本数据类型 类型分类 符号 占用空间 最小值 最大值 默认值 整数 sbyte 1 字节 \\(-2^7\\) \\(2^7 - 1\\) 0 整数 byte 1 字节 \\(0\\) \\(2^8 - 1\\) 0 整数 short 2 字节 \\(-2^{15}\\) \\(2^{15} - 1\\) 0 整数 ushort 2 字节 \\(0\\) \\(2^{16} - 1\\) 0 整数 int 4 字节 \\(-2^{31}\\) \\(2^{31} - 1\\) 0 整数 uint 4 字节 \\(0\\) \\(2^{32} - 1\\) 0 整数 long 8 字节 \\(-2^{63}\\) \\(2^{63} - 1\\) 0 整数 ulong 8 字节 \\(0\\) \\(2^{64} - 1\\) 0 浮点数 float 4 字节 \\(\\approx -3.4 \\times 10^{38}\\) \\(\\approx 3.4 \\times 10^{38}\\) 0.0f 浮点数 double 8 字节 \\(\\approx -1.8 \\times 10^{308}\\) \\(\\approx 1.8 \\times 10^{308}\\) 0.0d 字符 char 2 字节 U+0000 U+FFFF \\0 布尔 bool 1 字节 false true false 需要注意： 字符 char 的大小在 C 和 C++ 中为 1 字节，在大多数编程语言中取决于特定的字符编码方法。 即使表示布尔量仅需 1 位（0 或 1），它在内存中通常也存储为 1 字节。这是因为现代计算机 CPU 通常将 1 字节作为最小寻址内存单元。 基本数据类型提供了数据的 “内容类型” ，而数据结构提供了数据的 “组织方式”","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数据结构和算法","slug":"01-计算机科学/数据结构和算法","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"03-数据结构","slug":"01-计算机科学/数据结构和算法/03-数据结构","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"3.1 数据结构的分类","date":"2025-07-15T01:41:15.000Z","path":"wiki/01-计算机科学/数据结构和算法/03-数据结构/3.1-数据结构的分类/","text":"常见的数据结构包括：数组、链表、栈、队列、哈希表、树、堆、图 数据结构的分类，按照逻辑结构分： 线性 非线性 按照物理结构分： 连续 分散 线性和非线性 线性数据结构：元素之间是一对一的顺序关系，比如数组、链表、栈、队列、哈希表 非线性数据结构：元素之间是一对多或者多对多的关系 树形结构（一对多）：树、堆、哈希表 网状结构（多对多）：图 连续与分散 当算法程序运行时，正在处理的数据主要存储在内存中。系统通过内存地址来访问目标位置的数据。 在数据结构与算法的设计中，内存资源是一个重要的考虑因素。算法所占用的内存峰值不应超过系统剩余空闲内存；如果缺少连续大块的内存空间，那么所选用的数据结构必须能够存储在分散的内存空间内。 值得说明的是，所有数据结构都是基于数组、链表或二者的组合实现的。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。 基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 \\(\\ge3\\) 的数组）等。 基于链表可实现：栈、队列、哈希表、树、堆、图等。 链表在初始化后，仍可以在程序运行过程中对其长度进行调整，因此也称“动态数据结构”。数组在初始化后长度不可变，因此也称“静态数据结构”。值得注意的是，数组可通过重新分配内存实现长度变化，从而具备一定的“动态性”。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数据结构和算法","slug":"01-计算机科学/数据结构和算法","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"03-数据结构","slug":"01-计算机科学/数据结构和算法/03-数据结构","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"01.方法和函数","date":"2025-07-15T01:34:16.000Z","path":"wiki/98-易混淆点/01.方法和函数/","text":"函数（function）可以被独立执行，所有参数都以显式传递。方法（method）与一个对象关联，被隐式传递给调用它的对象，能够对类的实例中包含的数据进行操作。 下面以几种常见的编程语言为例来说明： C 语言是过程式编程语言，没有面向对象的概念，所以只有函数。但我们可以通过创建结构体（struct）来模拟面向对象编程，与结构体相关联的函数就相当于其他编程语言中的方法。 Java 和 C# 是面向对象的编程语言，代码块（方法）通常作为某个类的一部分。静态方法的行为类似于函数，因为它被绑定在类上，不能访问特定的实例变量。 C++ 和 Python 既支持过程式编程（函数），也支持面向对象编程（方法）。","tags":[{"name":"易混淆点","slug":"易混淆点","permalink":"https://peiyuzou.github.io/tags/%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9/"}],"categories":[{"name":"98-易混淆点","slug":"98-易混淆点","permalink":"https://peiyuzou.github.io/categories/98-%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9/"}]},{"title":"03.中央处理器","date":"2025-07-14T13:56:30.000Z","path":"wiki/01-计算机科学/CrashCourse/03.中央处理器/","text":"中央处理器，常称 CPU（Central Processing Unit），我们本篇从一个高层次视角去了解 CPU 的组成，每一个根线不是指代真正的数据线，而是一组完善电路的抽象，代表这里有某种连接，这种高层次视角称 “微体系架构” （MicroArchitecture） CPU 组成 首先，我们要准备一个 RAM ，但注意内存不是 CPU 的组成部分，这里是为了演示 CPU 如何和内存打交道，进而解释它每个组成部分在其中发挥的作用。 为了简单，我们假设有一个只有 16 个地址的 RAM（如下图所示），因此它的地址可以用 4 位值表示（0 ~ 15），这 16 个地址中存储了若干的指令或者数据。对于数据来说，其中的 8 位都是值。对于指令来说，高 4 位代表操作码，低 4 位代表目标数据在内存或者寄存器中的地址。（这里只是举例，在实际的内存中可能和这个设计不一样，也可能更复杂） 设立寄存器 为了操作数据和存储临时数据，我们需要给 CPU 安排 4 个寄存器： 我们给 CPU 支持的所有指令分配一个操作码，对应上面指令中的高 4 位，比如下图： 我们还需要另外两个寄存器： 指令地址寄存器：用于追踪当前程序运行到哪里，存储的是指令在内存中的地址 指令寄存器：用于存储当前指令，方便 CPU 解码这个指令 计算机开始运行，所有寄存器被初始化为 0 ： 取指令 计算机从内存中取指令，然后一条一条执行，首先指令地址寄存器访问内存的第一个地址，并且将第一个地址的内容（一条指令）放入指令寄存器中： 解释并执行指令 得到了一条指令后，计算机需要将这条指令解释。它的高 4 位的值对应指令表中的第一条，即将指定内存地址的值放入寄存器 A 中： 继续取指令、解释、执行 执行完一条指令后，指令地址寄存器指向的内存地址 + 1 ，继续读取下一条指令，然后解释执行。 控制单元 由指令地址寄存器、指令寄存器、解码电路等部分组成了一个控制单元（Control Unit），我们可以将它抽象出来： 继续执行 第二条指令 CPU 继续取下一条指令并执行，第二条指令将内存地址 15 的值放在了寄存器 B 中： 第三条指令 第三条指令比较特殊，它代表将两个寄存器的值相加，并将结果放在指定的第二个寄存器中，这里寄存器 A 的地址为 00 ，寄存器 B 的地址为 01 ，因此是要将 B 中的值与 A 中的值相加，结果放入 A 中： 为了对两个值做算数运算，我们需要继续设立一个 ALU 进来，控制单元会将两个寄存器的值作为 ALU 的两个输入，然后传递 ALU 当前的操作码，计算得到的值并不会马上写入寄存器，而是放在一个临时的寄存器中（图中没有），当关闭 ALU 之后再写入寄存器 A ，防止 ALU 的值错误： 最后一条指令 最后一条指令，将寄存器 A 中的值写入内存中： 时钟 时钟（Clock）用来管理 CPU 的执行节奏。 它以精确的间隔来触发电信号，控制单元根据这个电信号去推动 CPU 的内部操作。这频率不能太快，因为电的传输也需要时间（很少很少）。 CPU 执行一次 “取指令-解码-执行” 的速度叫做 “时钟速度” ，它的单位是赫兹（Hz），现代 CPU 的主频已经达到了 GHz 级别，我们常说的超频就是允许 CPU 以更快的速度执行，但会增大用电量，并且可能损坏 CPU ，同样，许多 CPU 也有降频功能，在闲置的时间段内降频可以降低耗电量，这些都是通过改变时钟速度实现的。 对 CPU 做一次抽象 现在我们得到了一个简单的 CPU ，可以对它进行一次抽象： 从这里也可以看出来，RAM 不是 CPU 的组成部分，但它们息息相关 指令集 上面提到的操作码，在实际计算机中远不止 4 个，也不止 4 位，比如常见的让程序停止运行的 HALT 指令等。为了让指令能更多，有两个策略： 直接用更多位来表示指令，比如 32 位甚至 64 位 采用可变指令长度，比如 JUMP 指令占 8 位，但它后面需要跟一个立即值，代表要跳转的内存地址，这样设计的话，指令长度可以是任意的，但是 CPU 在读取阶段会更加复杂一些 CPU 可以识别的这样一批指令叫做指令集，现代的 CPU 拥有上千条的指令，光 ADD 指令都有很多变种，比我们例子中的要复杂很多，但是核心原理没有变。","tags":[{"name":"CS-101","slug":"CS-101","permalink":"https://peiyuzou.github.io/tags/CS-101/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"CrashCourse","slug":"01-计算机科学/CrashCourse","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/"}]},{"title":"2.4 空间复杂度","date":"2025-07-14T09:45:37.000Z","path":"wiki/01-计算机科学/数据结构和算法/02-复杂度分析/2.4-空间复杂度/","text":"空间复杂度（space complexity）用于衡量算法占用内存空间随着数据量变大时的增长趋势。 算法相关空间 算法在运行过程中使用的内存空间主要包括以下几种。 输入空间：用于存储算法的输入数据 暂存空间：用于存储算法在运行过程中的变量、对象、函数上下文等数据 暂存数据：用于保存算法运行过程中的各种常量、变量、对象等 栈帧空间：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放 指令空间：用于保存编译后的程序指令，在实际统计中通常忽略不计 输出空间：用于存储算法的输出数据 一般情况下，空间复杂度的统计范围是 “暂存空间” 加上 “输出空间” ： 代码举例： 1234567891011121314151617181920/* 结构体 */struct Node &#123; int val; Node *next; Node(int x) : val(x), next(nullptr) &#123;&#125;&#125;;/* 函数 */int func() &#123; // 执行某些操作... return 0;&#125;int algorithm(int n) &#123; // 输入数据 const int a = 0; // 暂存数据（常量） int b = 0; // 暂存数据（变量） Node* node = new Node(0); // 暂存数据（对象） int c = func(); // 栈帧空间（调用函数） return a + b + c; // 输出数据&#125; 推算方法 我们通常只关注最差空间复杂度。因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留： 以最差输入数据为准 以算法运行中的峰值内存为准 1234567void Algorithm(int n) &#123; int a = 0; // O(1) int[] b = new int[10000]; // O(1) if (n &gt; 10) &#123; int[] nums = new int[n]; // O(n) &#125;&#125; 上面这个例子，最差空间复杂度为 \\(O(n)\\) 在递归函数中，需要注意统计栈帧空间： 123456789101112131415int Function() &#123; // 执行某些操作 return 0;&#125;/* 循环的空间复杂度为 O(1) */void Loop(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; Function(); &#125;&#125;/* 递归的空间复杂度为 O(n) */int Recur(int n) &#123; if (n == 1) return 1; return Recur(n - 1);&#125; 常见类型 常数阶 \\(O(1)\\) 12345678910111213141516171819202122/* 函数 */int Function() &#123; // 执行某些操作 return 0;&#125;/* 常数阶 */void Constant(int n) &#123; // 常量、变量、对象占用 O(1) 空间 int a = 0; int b = 0; int[] nums = new int[10000]; ListNode node = new(0); // 循环中的变量占用 O(1) 空间 for (int i = 0; i &lt; n; i++) &#123; int c = 0; &#125; // 循环中的函数占用 O(1) 空间 for (int i = 0; i &lt; n; i++) &#123; Function(); &#125;&#125; 线性阶 \\(O(n)\\) 123456789101112131415/* 线性阶 */void Linear(int n) &#123; // 长度为 n 的数组占用 O(n) 空间 int[] nums = new int[n]; // 长度为 n 的列表占用 O(n) 空间 List&lt;ListNode&gt; nodes = []; for (int i = 0; i &lt; n; i++) &#123; nodes.Add(new ListNode(i)); &#125; // 长度为 n 的哈希表占用 O(n) 空间 Dictionary&lt;int, string&gt; map = []; for (int i = 0; i &lt; n; i++) &#123; map.Add(i, i.ToString()); &#125;&#125; 平方阶 \\(O(n^2)\\) 1234567891011121314/* 平方阶 */void Quadratic(int n) &#123; // 矩阵占用 O(n^2) 空间 int[,] numMatrix = new int[n, n]; // 二维列表占用 O(n^2) 空间 List&lt;List&lt;int&gt;&gt; numList = []; for (int i = 0; i &lt; n; i++) &#123; List&lt;int&gt; tmp = []; for (int j = 0; j &lt; n; j++) &#123; tmp.Add(0); &#125; numList.Add(tmp); &#125;&#125; 指数阶 \\(O(2^n)\\) 指数阶常见于二叉树 123456789/* 指数阶（建立满二叉树） */TreeNode? BuildTree(int n) &#123; if (n == 0) return null; TreeNode root = new(0) &#123; left = BuildTree(n - 1), right = BuildTree(n - 1) &#125;; return root;&#125; 对数阶 \\(O(log n)\\) 对数阶常见于分治算法。例如归并排序，输入长度为 n 的数组，每轮递归将数组从中点处划分为两半，形成高度为 \\(log_{2}n\\) 的递归树，使用 \\(O(log_{2}n)\\) 栈帧空间。 权衡时间与空间 降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然。我们将牺牲内存空间来提升算法运行速度的思路称为 “以空间换时间” ；反之，则称为 “以时间换空间” 。","tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数据结构和算法","slug":"01-计算机科学/数据结构和算法","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"02-复杂度分析","slug":"01-计算机科学/数据结构和算法/02-复杂度分析","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"}]},{"title":"2.3 时间复杂度","date":"2025-07-14T07:58:59.000Z","path":"wiki/01-计算机科学/数据结构和算法/02-复杂度分析/2.3-时间复杂度/","text":"时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势 统计时间增长趋势 12345678910111213141516// 算法 A 的时间复杂度：常数阶void algorithm_A(int n) &#123; cout &lt;&lt; 0 &lt;&lt; endl;&#125;// 算法 B 的时间复杂度：线性阶void algorithm_B(int n) &#123; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; 0 &lt;&lt; endl; &#125;&#125;// 算法 C 的时间复杂度：常数阶void algorithm_C(int n) &#123; for (int i = 0; i &lt; 1000000; i++) &#123; cout &lt;&lt; 0 &lt;&lt; endl; &#125;&#125; 分析这个例子： 算法 A 运行时间不随 n 的增大而增长，它的时间复杂度为 “常数阶” 算法 B 运行时间随着 n 增大呈线性增长。此算法的时间复杂度被称为 “线性阶” 算法 C 虽然运行时间很长，但它与输入数据大小与 n 无关，因此也是 “常数阶” 时间复杂度推算方法 第一步：统计操作数量 123456789101112void algorithm(int n) &#123; int a = 1; a = a + n; for (int i = 0; i &lt; 5 * n + 1; i++) &#123; cout &lt;&lt; 0 &lt;&lt; endl; &#125; for (int i = 0; i &lt; 2 * n; i++) &#123; for (int j = 0; j &lt; n + 1; j++) &#123; cout &lt;&lt; 0 &lt;&lt; endl; &#125; &#125;&#125; 以上代码如果精确地统计它的操作数量，应该是这样： \\[ T(n) = 2n(n + 1) + 5(n + 1) + 2 = 2n^2 + 7n + 3 \\] 它的时间复杂度为 \\(O(n^2)\\) （时间复杂度由 \\(T(n)\\) 中最高阶的项来决定），但我们可以通过技巧来快速推断： 舍掉常数和系数，因为它们不会影响最终的计算 循环嵌套时使用乘法 所以上述代码，我们可以直接得到操作数量： \\[ T(n) = n^2 + n \\] 转为时间复杂度为 \\(O(n^2)\\) 常见类型 以下分别用 C++ 代码举例： 常数阶 \\(O(1)\\) 12345678/* 常数阶 */int constant(int n) &#123; int count = 0; int size = 100000; for (int i = 0; i &lt; size; i++) count++; return count;&#125; 线性阶 \\(O(n)\\) 1234567/* 线性阶 */int linear(int n) &#123; int count = 0; for (int i = 0; i &lt; n; i++) count++; return count;&#125; 平方阶 \\(O(n^2)\\) 1234567891011/* 平方阶 */int quadratic(int n) &#123; int count = 0; // 循环次数与数据大小 n 成平方关系 for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; count++; &#125; &#125; return count;&#125; 指数阶 \\(O(2^n)\\) 以 “细胞分裂” 为例，每轮是上一次的两倍 12345678910111213/* 指数阶（循环实现） */int exponential(int n) &#123; int count = 0, base = 1; // 细胞每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1) for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; base; j++) &#123; count++; &#125; base *= 2; &#125; // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1 return count;&#125; 对数阶 \\(O(log n)\\) 与指数阶相反，对数阶反映了“每轮缩减到一半”的情况 123456789/* 对数阶（循环实现） */int logarithmic(int n) &#123; int count = 0; while (n &gt; 1) &#123; n = n / 2; count++; &#125; return count;&#125; 线性对数阶 \\(O(n log n)\\) 线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 \\(O(n)\\) 和 \\(O(log n)\\) 12345678910/* 线性对数阶 */int linearLogRecur(int n) &#123; if (n &lt;= 1) return 1; int count = linearLogRecur(n / 2) + linearLogRecur(n / 2); for (int i = 0; i &lt; n; i++) &#123; count++; &#125; return count;&#125; 阶乘阶 \\(O(n!)\\) 阶乘阶对应数学上的 “全排列” 问题 1234567891011/* 阶乘阶（递归实现） */int factorialRecur(int n) &#123; if (n == 0) return 1; int count = 0; // 从 1 个分裂出 n 个 for (int i = 0; i &lt; n; i++) &#123; count += factorialRecur(n - 1); &#125; return count;&#125; 最差、最佳、平均时间复杂度 算法的时间效率往往不是固定的，而是与输入数据的分布有关。因此我们的算法的时间复杂度可能会变化。 我们在实际中很少使用最佳时间复杂度，因为通常只有在很小概率下才能达到，可能会带来一定的误导性。而最差时间复杂度更为实用，因为它给出了一个效率安全值，让我们可以放心地使用算法。 平均时间复杂度则是体现算法在随机输入数据下的运行效率。","tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数据结构和算法","slug":"01-计算机科学/数据结构和算法","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"02-复杂度分析","slug":"01-计算机科学/数据结构和算法/02-复杂度分析","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"}]},{"title":"2.2 迭代和递归","date":"2025-07-14T07:36:59.000Z","path":"wiki/01-计算机科学/数据结构和算法/02-复杂度分析/2.2-迭代和递归/","text":"在算法中，重复执行某个任务是很常见的，它与复杂度分析息息相关。常见的重复执行有迭代和递归，这两者也经常被搞混 迭代 迭代是在满足一定的条件下重复执行某段代码，直到这个条件不再满足，一般有以下几种： for 循环 while 循环 嵌套循环 递归 递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。 递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到 “终止条件”。 归：触发 “终止条件” 后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。 而从实现的角度看，递归代码主要包含三个要素。 终止条件：用于决定什么时候由 “递” 转 “归”。 递归调用：对应 “递”，函数调用自身，通常输入更小或更简化的参数。 返回结果：对应 “归”，将当前递归层级的结果返回至上一层。 调用栈 递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果： 函数的上下文数据都存储在称为 “栈帧空间” 的内存区域中，直至函数返回后才会被释放。因此，递归通常比迭代更加耗费内存空间。 递归调用函数会产生额外的开销。因此递归通常比循环的时间效率更低。 在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出错误。 尾递归 如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。 为什么尾递归可以优化？因为尾递归中，递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。 递归树 当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。 思考实现一个斐波那契数列的计算，数列中的每个数字是前两个数字的和，即 \\(f(n) = f(n - 1) + f(n - 2)\\) ，C++ 函数实现如下： 12345678910/* 斐波那契数列：递归 */int fib(int n) &#123; // 终止条件 f(1) = 0, f(2) = 1 if (n == 1 || n == 2) return n - 1; // 递归调用 f(n) = f(n-1) + f(n-2) int res = fib(n - 1) + fib(n - 2); // 返回结果 f(n) return res;&#125; 我们在函数内递归调用了两个函数，这意味着从一个调用产生了两个调用分支。这样不断递归调用下去，最终将产生一棵层数为 n 的递归树（recursion tree）。 从本质上看，递归体现了 “将问题分解为更小子问题” 的思维范式，这种分治策略至关重要。 从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。 从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。 两者对比 迭代 递归 实现方式 循环结构 函数调用自身 时间效率 效率通常较高，无函数调用开销 每次函数调用都会产生开销 内存使用 通常使用固定大小的内存空间 累积函数调用可能使用大量的栈帧空间 适用问题 适用于简单循环任务，代码直观、可读性好 适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰","tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数据结构和算法","slug":"01-计算机科学/数据结构和算法","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"02-复杂度分析","slug":"01-计算机科学/数据结构和算法/02-复杂度分析","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"}]},{"title":"2.1 数据结构和算法概览","date":"2025-07-14T07:16:59.000Z","path":"wiki/01-计算机科学/数据结构和算法/02-复杂度分析/2.1-算法效率评估/","text":"算法的目标： 找到问题解法 寻找最优解法 所以算法效率是评价算法优劣的指标，包含两个维度： 时间效率 空间效率 效率评估的方法主要分：实际测试、理论估算 实际测试 对比两个算法最直接的方式是用一台计算机直接运行然后对比它们的运行时间和内存占用情况，但是这种方式也存在很大的局限性： 难以排除测试环境的干扰因素。测试机器的硬件会影响我们的测试，比如一个算法的并行度较高，那么它就更适合在多核 CPU 上运行，一个算法的内存操作密集，那么它在高性能内存上的表现就会更好。但我们不可能在大量机器上做测试对比。 展开完整测试非常耗费资源。随着输入数据量的变化，算法会表现出不同的效率。但我们的测试输入样例是有限的。 理论估算 由于实际测试具有较大的局限性，所以一般我们使用复杂度分析来评估算法，它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势。","tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数据结构和算法","slug":"01-计算机科学/数据结构和算法","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"02-复杂度分析","slug":"01-计算机科学/数据结构和算法/02-复杂度分析","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"}]},{"title":"1.1 数据结构和算法概览","date":"2025-07-14T07:02:48.000Z","path":"wiki/01-计算机科学/数据结构和算法/01-概览/1.1-数据结构和算法概览/","text":"数据结构与算法这部分的内容是对 Hello 算法（https://www.hello-algo.com/）做的个人笔记，转载请标注来源。 算法定义 算法（algorithm）是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性。 问题是明确的，包含清晰的输入和输出定义。 具有可行性，能够在有限步骤、时间和内存空间下完成。 各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。 数据结构定义 数据结构（data structure）是组织和存储数据的方式，涵盖数据内容、数据之间关系和数据操作方法，它具有以下设计目标。 空间占用尽量少，以节省计算机内存。 数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。 提供简洁的数据表示和逻辑信息，以便算法高效运行。 数据结构设计是一个充满权衡的过程。如果想在某方面取得提升，往往需要在另一方面作出妥协。下面举两个例子。 链表相较于数组，在数据添加和删除操作上更加便捷，但牺牲了数据访问速度。 图相较于链表，提供了更丰富的逻辑信息，但需要占用更大的内存空间。 数据结构与算法的关系 数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。 算法为数据结构注入生命力。数据结构本身仅存储数据信息，结合算法才能解决特定问题。 算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。","tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数据结构和算法","slug":"01-计算机科学/数据结构和算法","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"01-概览","slug":"01-计算机科学/数据结构和算法/01-概览","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/01-%E6%A6%82%E8%A7%88/"}]},{"title":"02.寄存器和内存","date":"2025-07-12T14:37:30.000Z","path":"wiki/01-计算机科学/CrashCourse/02.寄存器和内存/","text":"计算机的存储分为随机访问存储（RAM）和持久存储，这一节讨论的是前者，即：计算机在通电的状态下，如何存储数据 如何存储 1 bit 的数据 计算机通电后的电流都是单向流动的，所以要在通电时存储电信号，工程师对逻辑电路做了处理，让输出电信号回流到其中一个输出： 上面的两个电路分别可以存储 1 和 0，但是这还不够，毕竟它们的存储都是不可改变的，为此，逻辑电路被组合了起来： 这个电路被称为锁存器（AND-OR Latch），是因为它锁住了一个位的值，这样就真正意义上存储了 1 bit 的值！ 但是使用 设置 和 复位 两条线来输入比较难以理解，易用的结构应该是下面这样的： 所以又有了这样的电路，我们称之为门锁（Gate Latch）： 之所以称为门锁，是因为它可以打开和关上，我们不必过于关心它的实现细节，所以再次抽象： 这样，我们拥有了一个真正意义上可以存储 1 bit 数据的锁存器 寄存器（Register） 我们把 8 个锁存器并成一排形成一组，这样我们就得到了一个寄存器。 寄存器能够存储一个数字，寄存器有多少位，就叫 位宽。早期的计算机使用 8 位宽的寄存器，后面 16 位、32 位、直到如今的 64 位。 想象一下，如果我们要往一个寄存器里面写值，那么我们至少需要 8 根输入线和 8 根输出线，但 “允许写入线” 可以只用一根，将 8 个锁存器全部连通。这样，当寄存器要写入数据时，把 “允许写入线” 置 1 ，八根输入线写入数据后，再将 “允许写入线” 置 0 即可。 内存 现在我们的存储规模再次提升，超过单个寄存器，存储 256 位数据，线的数量就会来到 64 + 64 + 1 = 129 根！ 于是矩阵式的电路设计出现了。锁存器不再是单纯并排排布，而是网格排布，下图是存 256 位的 16x16 的锁存器布局，当我们要写入某个锁存器时，只需要同时启用对应的行线和列线： 这样，我们需要的线就变成了： 1 根数据线 1 根 “允许写入线” 16 行和 16 列的线用于选择锁存器 129 根线被优化为 1 + 1 + 16 + 16 = 34 根线，即使加上 “允许读取线” ，也才 35 根线 多路复用器 采用矩阵式电路设计后，我们用可以用行数加列数来表示一个锁存器的地址，比如第 12 行 8 列的锁存器地址是 11001000 。行和列分别占 4 bit ，如何把这个 4 位的值转换到电路上，就要用到多路复用器（Multiplexer） 两个多路复用器，分别用来转换行和列的地址 对内存抽象 以上的结构做一次抽象，得到下面的 256 bit 的内存： 它使用 8 位地址（4 位行和 4 位列），一条数据线，一条写入线和一条读取线 我们将 8 个 256 bit 内存并排排布，用 8 根线串联控制地址，用 2 根线串联分别控制写入和读取，再对每个内存单独用 1 根数据线（共 8 根数据线），可以实现在指定 8 位地址存储一个 8 位数字： 对这个电路再次做抽象，我们就得到了一个可寻址的内存，由于地址最多有 256 个，所以我们最多可以存储 256 个 8 位值： 由于可以随时访问任意位置，这样的内存被叫做 RAM (Random Access Memory，随机访问存储器)。现代的内存条可以达到几十 GB 容量，归根结底就是排布了大量类似这样的内存电路。","tags":[{"name":"CS-101","slug":"CS-101","permalink":"https://peiyuzou.github.io/tags/CS-101/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"CrashCourse","slug":"01-计算机科学/CrashCourse","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/"}]},{"title":"01.算数逻辑单元","date":"2025-07-12T13:28:47.000Z","path":"wiki/01-计算机科学/CrashCourse/01.算数逻辑单元/","text":"算数逻辑单元，通常叫做 ALU（Arithmetic &amp; Logic Unit），它包含两个单元：算数单元和逻辑单元 算数单元 算数单元负责了计算机的所有算数计算，了解它需要先理解半加器和全加器 半加器 思考我们在单个 bit（位） 上做二进制加法： 加法非常简单，但是结果无法用单个位存储，因为 1 + 1 的结果带有进位（Carry），所以我们需要有两个输出值： 因此，我们可以抽象出一个 半加器（half adder）： 全加器 如果我们要实现多位数的相加，那么除了最低位，其余位都要处理这个进位，所以输入的值会变成三个： 所以我们又抽象出了一个 全加器（full adder）： 制作 8 位加法器 通过半加器和全加器，我们可以对多位表示的数进行加法运算，由于最低位不计算进位，所以使用半加器去处理，剩余的位使用全加器： 由此我们得到了一个 8 位行波进位加法器（8-bit ripple carry adder） 注意最高位仍然有一个进位，当这个进位为 1，代表两个数字之和太大，发生了溢出 ALU 的其他算数能力 包含上面部分说的加法，ALU 一般还可以做以下的运算： 加法 带进位的加法 减法 带借位的减法 正负取反 自增 自减 数字无改变，通过（All bits of A are passed through unmodified） 对于简单的 ALU 来说，它们没有能直接处理乘法和除法的算数单元，但是可以通过多次简单的运算来达到目的，比如 12 x 5 变为 12 + 12 + 12 + 12 + 12，而现代计算的 CPU 比较先进，它们具备了专门做乘除法的算数单元 逻辑单元 逻辑单元用来处理一些逻辑运算，比如 AND、OR、NOT、XOR 等，也可以用于做一些简单的数值测试，比如检查 ALU 的输出是否为 0 ALU 的抽象 一般工程师使用下图的 “V” 型图标表示一个 ALU ： ALU 要求有两个 8 位的输入值，另外还要 4 位的操作码，以此来确定怎么处理两个函数的计算（比如 1000 代表相加），最终输出一个 8 位的值，另外还有一些标记位（单个 bit），比如图中的三个： Overflow：运算是否发生了溢出 Zero：运算结果是否为零，判断两个数值是否相等的时候很有用 Negative：运算结果是否为负，判断大小时有用 一些高级的 ALU 还会有其他的 Flags，但是这三个是比较通用的","tags":[{"name":"CS-101","slug":"CS-101","permalink":"https://peiyuzou.github.io/tags/CS-101/"}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"CrashCourse","slug":"01-计算机科学/CrashCourse","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/"}]},{"title":"01.Lz4压缩","date":"2025-07-10T11:06:13.000Z","path":"wiki/05-游戏编程/压缩算法/01.Lz4/","text":"概述 LZ4 是一种无损压缩算法，提供每核 &gt; 500 MB/s 的压缩速度，并可通过多核 CPU 进行扩展。它具有极快的解码器，每核速度可达数 GB/s，通常会达到多核系统的 RAM 速度极限。 作为 Unity AssetBundle 主推的压缩算法，它相比 Lzma 拥有更快的速度（大约是 Lzma 的十倍以上）。并且是基于块压缩的（Chunk Based），可以按需选择加载部分块，而不用将整个文件全部加载，这对于内存来说是更友好的。唯一相较于 Lzma 的劣势是压缩率，大约比 Lzma 高出 30% Lz4 的原理 Lz4 压缩后的文件由块组成，每一个压缩块则由若干序列组成，它的核心原理简单概括就是找出重复的字节序列，按照固定规则以更省空间的形式存储。先来看它的序列示意图： 首先，开头的一个字节称为一个标记（Token），这个标记由两个 4 位组成（因此值的范围从 0 到 15） 高 4 位用于存储字面量（Literal）的长度，字面量是指压缩过程中无法被压缩的原始字节。由于 4 位能表示的值范围有限，因此图中 Literal length+ （图中黄色区域）用于支持更大的长度值的存储，这是一个可选的区域。如果 4 位之内足够存储字面量的长度，这个区域就不存在，Token 之后会紧跟 Literals（字面量）。如果该 4 位存储的值为 0，则代表没有字面量。如果为 15（4 位全 1），则增加一个 Literal length+ 区域，其代表的值为 0 - 255（一个字节的大小），此时字面量的长度 = 15 + 这个字节的值。如果这个字节的值仍然满了（255），则继续增加一个新的字节，直到可以表示字面量的长度为止。（因此图中写的是 0-n bytes） 这两个区域之后，则是字面量的存储区域，字面量是未压缩的字节，按原样复制。 紧接着是偏移量（Offset），这是一个两个字节的值（0-65535），它表示要从中复制匹配的位置。请注意，0 是无效值，不会被使用。1 表示“当前位置 - 1 字节”，另外需要注意，这个值使用小端格式存储（低位在前，高位在后）。通过偏移量，我们可以得到重复字节的起始位置 我们使用重复字节的起始位置加上匹配长度的值，就可以得到重复位置从哪个位置开始到哪个位置结束。匹配长度是指从在 Token 的低 4 位值存储，如果不够，再启用后面的可选区域，可选区域的规则和字面量长度的规则一致，但这里有一点细小的差异，匹配长度要求最小值为 4，也就是说至少要 4 个重复的字节才可以压缩，这应该是为了压缩率至少不能超过 1 而设计的，毕竟压缩后变大了是不行的。这里存储的值如果为 0，代表匹配长度为 4 个字节，如果值为 15，代表匹配长度为 19+ 个字节（可能启用了可选区域） 进行一次计算 假设我们有上面这个字节序列，其中每个字节编号一个索引，最大值是F（11111111），现在开始对它进行模拟压缩，步骤如下： 压缩计算 现在我们得到： 字面量为[C, C, C, A, B, C, D, E, F, B, B, B]，长度为12。 偏移量为9 匹配长度为6 首先第一个序列用来存储字面量： 12345Token：- 高 4 位：12（字面量长度，小于 15 无需额外字节）- 低 4 位：0（不存储匹配）Literals：[C, C, C, A, B, C, D, E, F, B, B, B]Offset：由于该序列仅表示字面量，因此不存储Offset 第二个序列用来存储匹配数据： 12345678匹配信息:- 偏移量: 9- 匹配长度: 6Token:- 高4位: 0 (没有字面量)- 低4位: 2 (匹配长度 = 6-4 = 2)Token = 0x02偏移量编码: 0x0009 → 小端序 [0x09][0x00] 得到最终压缩结果： 123456[0xC0][C][C][C][A][B][C][D][E][F][B][B][B][0x02][0x09][0x00]原始数据: 18字节压缩数据: 16字节压缩率: 16/18 ≈ 88.9%节省: 2字节 (11.1%) 解压计算 解压Token1 (0xC0)： 1234字面量长度: 12匹配长度: 0操作: 复制12个字面量输出: C C C A B C D E F B B B 解压Token2 (0x02)： 12345字面量长度: 0匹配长度: 2+4 = 6偏移量: 9操作: 从位置3开始复制6个字节输出: A B C D E F (复制位置3-8) 最终结果与原数据一致： 1C C C A B C D E F B B B A B C D E F","tags":[{"name":"Compression","slug":"Compression","permalink":"https://peiyuzou.github.io/tags/Compression/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"压缩算法","slug":"05-游戏编程/压缩算法","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"}]},{"title":"05.Unity内存优化最佳实践","date":"2025-07-10T08:30:30.000Z","path":"wiki/05-游戏编程/Unity/Unity内存管理/05.Unity内存优化最佳实践/","text":"","tags":[{"name":"Unity","slug":"Unity","permalink":"https://peiyuzou.github.io/tags/Unity/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"Unity内存管理","slug":"05-游戏编程/Unity/Unity内存管理","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"04.Unity Managed Memory","date":"2025-07-10T05:43:59.000Z","path":"wiki/05-游戏编程/Unity/Unity内存管理/04.Unity Managed Memory/","text":"概览 VM 内存池 VM 返回内存给操作系统的条件 GC 机制 GC 机制考量 Throughput（回收能力） Pause Times（暂停时长） Fragmentation（碎片化） Mutator overhead（额外消耗） Scalability（可扩展性） Portability（可移植性） 使用的 GC Boehm Non-generaional Non-compacting Incremental GC（渐进式GC） Memory fragmentation（内存碎片化） Zombie Memory（僵尸内存） 无用内存 没有释放 通过代码管理和性能工具分析 VM 内存池 Unity 编辑器进程自身使用 Mono VM，打包后的实际游戏进程根据脚本后端选择不同，使用 IL2Cpp Runtime 或者 Mono VM。注意这里说的 VM 是指实际游戏进程使用的 VM。 Mono VM 的内存池，内存以 Block 的形式管理，当一个 Block 连续 6 次 GC 没有被访问到，这块内存会被返回给系统，条件苛刻，比较难触发。 IL2CPP 更容易触发，因为它的内存管理更像一个传统 C++ 程序的内存管理模式。 注意，GC 本身是不会把内存返还给操作系统的，它是回收给虚拟机。 Unity 的 GC 1. GC 机制的考量 Throughput（回收能力）：一次GC能收回多少内存 Pause times（暂停时长）：GC时对主线程的影响会多大（卡顿） Fragmentation（碎片化）：对整体内存池的碎片化影响多少 Mutator overhead（额外消耗）：GC时的消耗，GC时需要做很多的统计会产生消耗 Scalability（可拓展性）：拓展到多核多线程会不会有什么bug Portability（可移植性）：在不同的平台上是否可以使用 2. Boehm GC 和 Incremental GC Unity 用的 Boehm GC，简单粗暴，不分代。它有以下特点： Non-generational（非分代式），即全都堆在一起，因为这样会很快。分代的话就是例如大内存，小内存，超小内存分在不同的内存区域来进行管理（SGen GC的设计思想）。 Non-Compacting（非压缩式），即当有内存被释放的时候，这块区域就空着。而压缩式的会重新排布，填充空白区域，使内存紧密排布。 但目前 Unity 在 Mono 上已经使用 SGen GC （Scalable Generational GC，分代垃圾回收器）了，而 IL2CPP 则是嵌入了一个定制化后的 Boehm 结论如下表： Unity后端 使用的GC 是否 Boehm 是否支持分代 Mono（编辑器） Mono SGen GC 非 Boehm 是 IL2CPP Boehm GC（定制版） 是 否 DOTS/Burst 无托管堆 无GC N/A Unity 另外实装了 Incremental GC，主要解决主线程卡顿的问题，现在进行一次GC主线程被迫要停下来，遍历所有的 Memory Island，决定哪些要被 GC 掉，会造成一定时间的主线程卡顿。Incremental GC 把前面暂停主线程的事分帧做了，这样主线程不会出现峰值。 3. 内存碎片化 非压缩式的内存虽然快（避免了内存重新排布的时间消耗），但是容易造成内存碎片化。内存的碎片化容易间接内存异常上涨，比如内存总用量下降了，但是还在继续分配新的空间。例如，内存中有一些空白的内存区域时，分配了一块较大内存时，却没有任何的一个空间放得下（即使整体的空间足够），导致内存扩充很多。 因此建议在需要连续分配内存的情况下，先操作大内存，然后操作小内存，可以一定程度上减轻碎片化。 4. 僵尸内存 这个和内存泄漏常被人搞混在一起。僵尸内存是指碎片化内存之间空出的内存，这部分内存可能成为僵尸内存。这种情况实际上并不是内存泄露，因为这些内存并没有被泄露，泄露指这块内存没有任何人可以访问和管理，但实际上这块内存一直在内存池里。 Managed Memory 最佳实践 1. Don’t Null it, Destroy it 用 Destroy，别用 null，显示的调用 Destroy 才能真正的销毁掉。 2. Class 和 Struct 不要混用 这个不赘述 3. Pool In Pool 高频使用的部分自己建一个内存池去重用 4. Closures and anonymous methods（闭包和匿名函数） 所有的匿名函数和闭包在 C# 编 IL 代码时都会被 new 成一个 Class（匿名class），所以在里面所有变量以及new的东西，都是要占内存的。 5. Coroutines（协程） 协程属于闭包和匿名函数的特例，游戏开始启动一个协程直到游戏结束才释放，是错误的做法。因为协程只要没被释放，里面的所有变量，即使是局部变量（包括值类型），也都会在内存里。建议用的时候才生产一个协程，不用的时候就丢掉。 6. Configurations（配置表） 全部配置表一下全部进内存也是不明智的，可以考虑分关加载等策略。 7. Singleton（单例） 慎用单例，不要什么都往里放，因为里面的变量会一直占用内存。","tags":[{"name":"Unity","slug":"Unity","permalink":"https://peiyuzou.github.io/tags/Unity/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"Unity内存管理","slug":"05-游戏编程/Unity/Unity内存管理","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"03.Unity Native Memory","date":"2025-07-10T02:19:51.000Z","path":"wiki/05-游戏编程/Unity/Unity内存管理/03.Unity Native Memory/","text":"概览 Native Memory 介绍 Allocator与Memory Label GetRuntimeMemory NewAsRoot 会即时返还给操作系统 Native Memory 最佳实践 Scene Audio DSP buffer Force to mono Format Compression Format Code Size AssetBundle TypeTree Lz4 &amp; Lzma Size &amp; Count Resources R-B Tree Texture upload buffer r/w Mip Maps Mesh r/w Compression Assets Native Memory 介绍 1. Allocator与Memory Label Unity 在里面重载了 C++ 的所有分配内存的操作符，例如 alloc，new 等。每个操作符在被使用的时候要求有一个额外的参数就是 Memory Label，在 Memory Profiler （Windows/Analysis/Memory Profiler）中查看 Memory Details 里的 Name 很多就是 Memory Label。它指的就是当前的这一块内存内存要分配到哪个类型池里。 2. GetRuntimeMemory Unity 在底层会用 Allocator，使用重载过的分配符分配内存的时候，会根据 Memory Label 分配到不同的 Allocator池 里面。每个 Allocator 池，单独做自己的跟踪。当要在 Runtime 去 Get 一个 Memory Label 下面池的时候，可以从对应的 Allocator 中取，可以从中知道有什么东西，有多少兆。 3. NewAsRoot 前面提到的 Allocator 的生成是使用 NewAsRoot，生成一个所谓的 Memory Island，它下面会有很多的子内存。例如一个 Shader，当加载一个 shader 进内存的时候，首先会生成一个 shader 的 Root，也就是 Memory Island。然后 Shader 底下的数据，例如 Subshader，Pass，Parameters 等，会作为该 Root 底下的成员，依次的分配。所以最后统计 Runtime 的内存时，统计这些 Root 即可。 4. 返还操作系统 因为是 C++ 的，所以当 delete 或 free 一个内存的时候，会立刻返回给系统。这和托管内存不一样，托管内存需要 GC 后才返回。 Native Memory 最佳实践 在使用Unity的时候，如果某些方面使用不当，会造成 Native Memory 的增长，所以这部分也是可以优化调整的。 1. Scene 首当其冲，最常见的导致 Native Memory 增长的原因，就是Scene。因为 Unity 是 C++ 引擎，所有的实体最终都会反映在 C++ 上，而不会反映在托管堆上。所以当 Scene 构建一个 GameObject 的时候，实际上在 Unity 的底层会构建一个或多个 Object 来存储这一个 GameObject 的信息（Component信息等）。所以当一个 Scene 里面有过多的 GameObject 存在的时候，Native Memory 就会显著的上升，甚至可能导致内存溢出。 所以这里有一个经验之谈：当发现 Native Memory 大量上升时，首先去着重检查你的 Scene 2. Audio 2.1 DSP buffer 指一个声音的缓冲，当一个声音要播放的时候，需要向 CPU 去发送指令。如果声音的数据量非常的小，会造成频繁的向 CPU 发指令，造成 IO 压力。在 Unity 的 FMOD 声音引擎里面，一般会有一个 Buffer，当 Buffer 填充满了才会去向 CPU 发送一次播放声音的指令。所以 DSP Buffer大小的设置非常考究，一般会导致两种问题： 设置的值过大，会导致声音的延迟，因为填充满需要很多的声音数据，当我们声音数据不大的时候，就会产生延时。 设置的值过小，会导致 CPU 负担上升，因为会频繁的发送。 2.2 Audio Import Settings Force To Mono：​这个选项作用是强制单声道，很多声音为了追求质量会设置成双声道，导致声音在包体和内存中，占用的空间加倍，但是95%以上的声音，两个声道是完全一样的数据。因此对声音不是很敏感的项目建议勾选此项，来降低内存的占用。 Compression Format：不同的平台有不同的声音格式的支持，iOS 对 MP3 有硬件支持，Android 暂时没有硬件支持。建议 iOS 使用 ADPCM 和 MP3 格式，Android 使用 Vorbis 格式。 Load Type：决定声音在内存中的存在形态： - Decompress On Load：当audio clip被加载时，解压声音数据，适用于小型音频文件（&lt; 200kb） - Compressed In Memory：声音数据将以压缩的形式保存在内存当中，适用于中型音频文件（&gt;= 200kb） - Streaming：从磁盘读取声音数据，适用于大型音频文件，例如背景音 注： - Decompress On Load，要求文件必须小于 200kb，因为内部内存管理的问题，如果是大于 200kb 的文件，那么也还是只会被分配到不足 200kb 的内存。 - Bitrate：可以对音频文件本身进行压缩，降低文件的比特率（bitrate），前提音频品质不会被破坏太严重。 3. Code Size 代码文件也是占内存的，需要加载进内存执行。一个典型的例子是模板泛型的滥用，例如一个模板函数有四五个不同的泛型参数，类型也不尽相同（float，int，double等），最后展开得到的一个 cpp 文件可能会很大。因为实际上 C++ 编译的时候用的所有的 Class，所有的 Template 最终都会被展开成静态类型。因此当模板函数有很多排列组合时，最后编译会得到所有的排列组合代码，导致文件很大。 这不光会影响到最终代码文件的大小，导致 Native Memory 间接增长，同时也会影响IL2CPP编译速度，接触过 C++ 编译应该知道，单一一个 cpp 文件编译的话是没办法并行的，只能单核处理，所以也间接地导致打包慢。 4. AssetBundle 4.1 TypeTree 这个东西存在是为了做这件事：Unity前后有很多的版本，不同的版本中很多的类型可能会有数据结构的改变，为了做数据结构的兼容，会在生成数据类型序列化的时候，顺便生成一个叫 TypeTree 的东西。就是当前这个版本用到了哪些变量，它们对应的数据类型是什么，当进行反序列化的时候，根据 TypeTree 去做反序列化。如果上一个版本的类型在这个版本没有，那 TypeTree 里就没有它，所以不会去碰到它。如果有新的 TypeTree，但是在当前版本不存在的话，那要用它的默认值来序列化。从而保证了在不同版本之间不会序列化出错。 在构建 AssetBundle 的时候，可以通过以下代码关掉 TypeTree 的生成： 1BuildAssetBundleOptions.DisableWriteTypeTree 什么时候可以关呢？当你可以保证构建 AssetBundle 的 Unity版本和使用它的 Unity 的版本是一模一样的时候（对兼容性不会有影响），就可以关闭。这样有三个好处：一、可以减少内存；二、AssetBundle 包大小会减少；三、build 和 Runtime 会变快，因为不会去序列化和反序列化 TypeTree（如果开了 TypeTree，序列化会做两步，首先去序列化 TypeTree，然后再去序列化实际的东西，反序列化也一样） 4.2 压缩方式（Lz4 和 Lzma） Unity 目前主推 Lz4（也就是ChunkBased，BuildAssetBundleOptions.ChunkBasedCompression），Lz4 非常快，大概是 Lzma 的十倍以上的速度，但平均压缩比例比 Lzma 差 30% 左右，即包体更大。但 Lzma 基本可以不用了，因为 Lzma 解压和读取速度都非常慢，并且内存占比高，因为它的读取不是基于 ChunkBased，而是 Stream，也就是一次全解压出来。ChunkBased 可以逐块解压，每次解压可以重用之前的内存，减少内存的峰值。 Lz4目前是开源的，可以了解下它的原理：https://github.com/lz4/lz4 4.3 大小和数量 AssetBundle 分两部分，一部分是头（用于索引），一部分是实际的打包的数据部分。如果每个 Asset 都单独打成一个 AssetBundle，那么可能所有问题加起来头的部分比数据还大。所以这个大小不适合太大也不能太小，官方建议一个AssetBundle在 1-2M，但是现在进入 5g 时代的话，可以适当加大，因为网络带宽更大了。 5. Resources 如果使用 Resources 模式打包，Resources 文件夹里的内容被打进包的时候会做一个红黑树（R-B Tree）用做索引，即检索资源到底在什么位置。所以Resource越大，红黑树越大，它不可卸载，并在刚刚加载游戏的时候就会被一直加在内存里，极大的拖慢游戏的启动时间，因为红黑树没有分析和加载完，游戏是不会启动的，并造成持续的内存压力。所以建议不要使用Resource，使用AssetBundle。 6. Texture Upload Buffer：和声音的Buffer类似，填满后向 GPU push 一次 Read/Write：没必要的话就关闭，正常情况，Texture 读进内存解析完了搁到 Upload Buffer 里之后，内存里那部分就会 delete 掉。除非开了Read/Write，那就不会 delete 了，会在显存和内存里各一份。前面说过手机内存显存通用的，所以内存里会有两份。 ​Mip Maps：例如 UI 元素这类相对于相机Z轴的值不会有任何变化的纹理，关闭该选项。 Alpha Source：对于不透明纹理，关闭其alpha通道。 ​​- Max Size：根据平台不同，纹理的Max Size设成该平台最小值。 POT：纹理的大小尽量为2的幂次方（POT），因为有些压缩格式可能不支持非2的幂次方的。 压缩格式： Android 支持 OpenGL ES 3.0 的使用 ETC2，RGB 压缩为 RGB Compressed ETC2 4bits，RGBA 压缩为 RGBA Compressed ETC2 8bits 需要兼容 OpenGL ES 2.0 的使用 ETC，RGB 压缩为 RGB Compressed ETC 4bits，RGBA 压缩为 RGBA 16bits。（压缩大小不能接受的情况下，压缩为 2 张 RGB Compressed ETC 4bits） 目前主流正在从 ETC2 向 ASTC 转变，后者的压缩质量和大小上都有优势。它支持 OpenGL ES 3.1 和部分 OpenGL ES 3.0 的设备。目前市面上绝大多数安卓设备都支持，已经可以普及使用 iOS 支持 OpenGL ES 3.0 的使用ASTC，RGB 压缩为RGB CompressedASTC 6x6 block，RGBA 压缩为 RGBA Compressed ASTC 4x4 block。 对于法线贴图的压缩精度较高可以选择 RGB CompressedASTC 5x5 block。 需要兼容OpenGLES 2.0 的使用 PVRTC，RGB 压缩为PVRTC 4bits，RGBA压缩为 RGBA 16bits。（压缩大小不能接受的情况下，压缩为 2 张 RGB Compressed PVRTC 4bits） 截止目前 ASTC 合并了 RGB 和 RGBA 格式，压缩格式的选择上面更加方便了 7. Mesh Read/Write：同Texture，若开启，Unity会存储两份Mesh，导致运行时的内存用量变成两倍。 Compression：Mesh Compression 是使用压缩算法将Mesh数据进行压缩，结果是会减少占用硬盘的空间，但是在 Runtime 的时候会被解压为原始精度的数据，因此内存占用并不会减少。需要注意的是有些版本开了，实际解压之后内存占用大小会更严重。 Rig：如果没有使用动画，请关闭Rig，例如房子，石头这些。 ​​Blendshapes：如果没有用到Blendshapes，也关闭。 Material设置：如果Material没有用到法向量和切线信息，关闭可以减少额外信息。 8. Assets 和整个的 Asset 管理有关系，Unity 官网上有关于资源管理的文章，找到再补充。","tags":[{"name":"Unity","slug":"Unity","permalink":"https://peiyuzou.github.io/tags/Unity/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"Unity内存管理","slug":"05-游戏编程/Unity/Unity内存管理","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"02.Unity内存管理","date":"2025-07-09T15:39:20.000Z","path":"wiki/05-游戏编程/Unity/Unity内存管理/02.Unity内存简介/","text":"概览 Unity 是一个 C++ 引擎 底层代码完全由 C++ 实现 通过 Wrapper 提供给用户 API 用户代码会转换为 Cpp 代码（IL2CPP） VM 仍然存在（解决跨平台问题） Unity 的内存 按照分配方式分为： Native Memory Managed Memory Editor &amp; Runtime 是不同的 按照管理方式分为： 引擎管理的内存 用户管理的内存 Unity 监测不到的内存 用户的 Native 代码 Lua Unity 引擎概述 Unity 是一个 C++ 引擎，并不是 C# 引擎，底层代码全部是由 C++ 写的，除了一些 Editor 里面的 Services 可能会用到 NodeJS 这些网络的语言，Runtime 里面用到的每行 Unity 底层代码都是 C++ 的。 Unity 实际上分为三层： 最底层是 Runtime，全是 Native C++ 代码。 最上层是 C#，Unity 本身也有一些 C#，例如 Unity 的 Editor 是用 C# 写的，还有些 Package 也是 C# 写的。 中间还有一层叫 Binding，可以看见很多的 .bindings.cs 文件（基于 C# 的 binding 语言，一开始是 Unity 自定义的一种语言），这些文件的作用就是把 C++ 和 C# 联系在一起，为 C# 层提供所有的 API。因此使用 Unity 时看见的 C# API，都是在 Binding 层中自定义的。这些文件底层运行的时候还是 C++，只是个 Wrapper（封装）。 最早用户代码是运行在 C# 上，是 MonoRuntime。现在可以通过 IL2CPP 将其转成 C++ 代码，所以现在几乎没有纯正的 C# 在运行了。 Unity 的 VM（虚拟机：Virtual Machine）依旧还是存在，主要用于跨平台，有了一层 VM 抽象后，跨平台的工作会容易很多，IL2CPP 本质也是 VM。 Unity 的内存 Unity的内存，可以从以下几个层面去理解 1. 按照分配方式划分 按照分配方式分为：Native Memory（原生内存）和Managed Memory（托管内存）。Native Memory 并不会被系统自动管理，需要手动去释放。而 Managed Memory 的内存管理是自动的，会通过 GC 来释放。 此外 Unity 在 Editor 和 Runtime 下，内存的管理方式是不同的，除了内存大小不同，内存的分配时机以及分配方式也不同。例如 Asset，在Runtime 时，只有用户代码 Load 的时候才会进内存。而 Editor 模式下，为了编辑的便利性，只要打开 Unity 就会进内存（所以打开很慢）。后续有推出 Asset Pipeline 2.0，一开始导入一些基本的 Asset，剩下的 Asset 只有使用的时候才会导入，这样即使是很大的工程，也可以尽量减少使用者对不关心的 Asset 付出导入时间的代价。 2. 按照内存管理方式划分 按照管理方式分为：引擎管理内存和用户管理内存。引擎管理内存即引擎运行的时候分配的一些内存，例如很多的Manager和Singleton，这些内存开发者一般是碰触不到的。用户管理内存也就是开发者开发时使用到的内存，是我们平时接触最多的部分。 3. Unity 监测不到的内存 用户分配的Native内存。比如自己写的Native插件（C++插件）导入Unity，这部分Unity是检测不到的，因为Unity没法分析已编译的C++是如何分配和使用内存的 Lua，它完全自己管理的，Unity也没法统计到它内部的情况","tags":[{"name":"Unity","slug":"Unity","permalink":"https://peiyuzou.github.io/tags/Unity/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"Unity内存管理","slug":"05-游戏编程/Unity/Unity内存管理","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"01.什么是内存","date":"2025-07-09T14:38:36.000Z","path":"wiki/05-游戏编程/Unity/Unity内存管理/01.什么是内存/","text":"概览 物理内存 CPU 访问内存是一个慢速过程 减少 Cache miss ECS 和 DOTS 移动设备与台式设备内存架构差异 没有独立显卡 没有独立显存 CPU 板载面积更小，缓存级数更少，缓存大小更小 虚拟内存 内存交换 PC 设备支持 移动设备不支持 内存压缩 iOS 支持 Android 不支持 内存寻址范围 32 位 CPU 和 64 位 CPU 的寻址范围不一定谁更大（但可以普遍认为后者更大） Android 内存管理 内存基本单位：Page 内存杀手：low memory killer 内存指标：RSS、PSS、USS 物理内存 物理内存关注两个点：CPU 访问内存是一个慢速过程、理解移动设备的内存架构差异。这里只解释前者，后者比较简单，看大纲即可。 CPU 在访问内存之前，会先去依次访问 L1、L2、L3 Cache，如果没有得到想要的数据（称为一次 Cache Miss），则会访问主内存，然后回到 Cache。整个这个过程是比较慢的，如果执行指令或者内存地址不连续，这个过程会导致大量的 Cache Miss，造成大量的主内存和 Cache 之间的交换，大量的时间会被浪费在内存的读取上。 所以物理内存的一个核心问题是如何减少 Cache Miss。Unity 推出的 DOTS 技术的一个理念就是把不连续的内存尽量变为连续的内存，以此减少 Cache Miss。 虚拟内存 内存交换是指设备将无用的内存数据写入到硬盘，以腾出内存空间的行为。PC 设备支持内存交换，移动设备不支持，不支持的原因有以下两点： 移动设备的 IO 性能较差，做内存交换会严重影响性能 移动设备的外置存储可擦写次数较少，频繁的内存交换会减少外置存储的寿命 为了解决这个问题，iOS 支持了内存压缩，大致原理是把无用的内存数据压缩起来放到指定位置，以此节省内存空间。 Android 内存管理 Android 是基于 Linux 的操作系统，所以 Android 的内存管理与 Linux 的内存管理是类似的。 内存基本单位 它的内存基本单位是一个 Page，大小为 4KB（不代表所有数据是按照 4KB 进行内存对齐）。回收和分配以 Page 为单位。内存空间分为内核态和用户态，内核态的内存是用户态严格禁止访问的。 low memory killer 详细介绍参考：https://developer.android.com/games/optimize/vitals/lmk?hl=zh-cn lmk 的原理是根据进程的优先级，在内存不足时，优先杀死优先级低的进程。所以一般在前台游戏进程分配过多内存时，优先杀掉了后台进程，如果内存分配还在继续，则肯呢个会影响到声音、桌面，甚至杀掉当前前台进程，如果前台进程被杀掉时，内存分配没有来得及释放，则可能会导致系统崩溃，也就是最高到 System 这一级别。Native 内核层不会受影响。 lmk 通常受到忽略，比如后台被杀掉的其他进程，或者音乐停了，但是游戏还在运行。但我们仍然需要关注，这变向地暴露了游戏内存的过多分配。 内存指标 RSS：Resident Set Size，常驻内存。 PSS：Proportional Set Size，比例内存。 USS：Unique Set Size，唯一内存。 RSS 是你的应用占用的内存 + 由于调用公共库，公共库所分配出来的内存。PSS 和 RSS 类似，但是会根据公共库的共享程度进行比例分配，比如公共库被 10 个进程使用，它被分配了 10MB 的内存，那么每个进程的 PSS 就是 1MB。USS 是你的应用占用的内存，不包括公共库的内存。 所以一般如果我们 RSS 高但 USS 低，说明我们调用了某个复杂度较高的公共库。这些内存指标可以通过 Procrank 工具（一款用于 Android 平台的内存分析工具）查看。","tags":[{"name":"Unity","slug":"Unity","permalink":"https://peiyuzou.github.io/tags/Unity/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"Unity内存管理","slug":"05-游戏编程/Unity/Unity内存管理","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"}]},{"title":"03.协议族和套接字类型","date":"2025-07-04T03:38:58.000Z","path":"wiki/08-网络编程/Socket/03.协议族和套接字类型/","text":"在创建套接字的时候，我们调用了 socket 函数，函数签名如下： 123#include &lt;winsock2.h&gt;SOCKET socket(int af, int type, int protocol); af: 套接字使用的地址族（Address Family）或者协议族（Protocol Family） type: 套接字传输类型 protocol：最终使用的协议 协议族（Protocol Family） 以下是协议族的部分分类： 名称 协议族 PF_INET IPv4互联网协议族 PF_INET6 IPv6互联网协议族 PF_LOCAL 本地通信的UNIX协议族 PF_PACKET 底层套接字的协议族 PF_IPX IPX Novell协议族 只需关心 PF_INET 即可，例子中会用到它 套接字类型 这个参数指定了数据传输方式，这里介绍两种最具代表性的：SOCK_STREAM 和 SOCK_DGRAM 1.SOCK_STREAM SOCK_STREAM 又称为面向连接的套接字。它有以下特性： 基于连接：传输端和接收端必须一一对应（端对端传输），且需要先建立连接 数据可靠：保证数据不丢失且按序到达 数据边界：无消息边界，数据以字节流的形式传输 对应协议：TCP 2.SOCK_DGRAM SOCK_DGRAM 又称为面向消息的套接字。它有以下特性： 基于消息：不需要建立连接，直接发送 数据不可靠：可能丢包、重复、乱序 数据边界：有消息边界，一次发送的数据是一整个报文 对应协议：UDP 最终协议的选择 其实通过接口签名的前两个参数进行组合，大多数情况下程序就已经可以得到最终的协议了，比如，PF_INET + SOCK_STREAM 可以确定用户要使用 TCP 协议，所以这种情况下第三个参数传 0 也可以。 但是存在前两个参数组合也无法确认最终协议的情况：在同一个协议族中，存在多个使用相同传输方式的协议。 所以这里设计了第三个参数，用来指定这个最终的协议，所以使用 TCP 的 Socket 也可以这么写： 1hSocket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); AF 和 PF ? 在上述的 socket 函数签名中，第一个参数是 af ，但是我们实际调用的时候，传入的是 PF_INET： 12345// 函数签名SOCKET socket(int af, int type, int protocol);// 实际调用hSocket = socket(PF_INET, SOCK_STREAM, 0); 要解释这个传参的问题，要先从 AF 和 PF 本身讲起。 AF (Address Family) 指地址族，强调地址类型，比如 IPv4 在 AF 中指的是地址类型为 IPv4 PF (Protocol Family) 指协议族，IPv4 在 PF 中强调的是协议类型为 IPv4 从语义来说，这个函数的签名要求传入的是地址类型，但是我们之所以可以传入 PF_INET 的原因是：在 Winsock 和大多数系统中，AF_XXX 和 PF_XXX 是同一个值！如下图的定义： 这本质上是历史语义的问题，在实际的使用中，无论是 AF 还是 PF 都不会出现问题。","tags":[],"categories":[{"name":"08-网络编程","slug":"08-网络编程","permalink":"https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Socket","slug":"08-网络编程/Socket","permalink":"https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/"}]},{"title":"02.使用C语言实现一个WinSock简易例子","date":"2025-07-02T05:56:32.000Z","path":"wiki/08-网络编程/Socket/02.使用C语言实现一个WinSock简易例子/","text":"WinSock 是指 Windows Socket，是 Windows 平台的套接字。 服务端代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182// hello_server.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;winsock2.h&gt;void ErrorHandling(char *message);// 链接ws2_32.lib库，提供Windows Socket API#pragma comment(lib, &quot;ws2_32.lib&quot;)int main(int argc, char *argv[])&#123; WSADATA wsaData; // Windows Socket库信息结构体 SOCKET hServSock, hClntSock; // 服务器socket句柄和客户端socket句柄 SOCKADDR_IN servAddr, clntAddr; // 服务器和客户端地址信息结构体 int szClntAddt; // 客户端地址结构体大小 char message[] = &quot;nice day&quot;; // 要发送给客户端的消息 // 检查命令行参数数量，需要端口号 if(argc != 2) &#123; printf(&quot;Usage: %s &lt;port&gt;\\n&quot;, argv[0]); exit(1); &#125; // 初始化Windows Socket库，请求版本2.2 if(WSAStartup(MAKEWORD(2,2), &amp;wsaData) != 0) &#123; ErrorHandling(&quot;WSAStartup() error!&quot;); &#125; // 创建TCP socket (PF_INET: IPv4, SOCK_STREAM: TCP, 0: 默认协议) hServSock = socket(PF_INET, SOCK_STREAM, 0); if(hServSock == INVALID_SOCKET) &#123; ErrorHandling(&quot;socket() error!&quot;); &#125; // 配置服务器地址信息 memset(&amp;servAddr, 0, sizeof(servAddr)); // 清零结构体 servAddr.sin_family = AF_INET; // 设置地址族为IPv4 servAddr.sin_addr.s_addr = htonl(INADDR_ANY); // 绑定到所有可用网络接口 servAddr.sin_port = htons(atoi(argv[1])); // 设置端口号并转换为网络字节序 // 将socket绑定到指定地址和端口 if(bind(hServSock, (SOCKADDR*)&amp;servAddr, sizeof(servAddr)) == SOCKET_ERROR) &#123; ErrorHandling(&quot;bind() error!&quot;); &#125; // 开始监听连接请求，最大等待队列长度为5 if(listen(hServSock, 5) == SOCKET_ERROR) &#123; ErrorHandling(&quot;listen() error!&quot;); &#125; // 接受客户端连接请求 szClntAddt = sizeof(clntAddr); hClntSock = accept(hServSock, (SOCKADDR*)&amp;clntAddr, &amp;szClntAddt); if(hClntSock == INVALID_SOCKET) &#123; ErrorHandling(&quot;accept() error!&quot;); &#125; // 向客户端发送消息 send(hClntSock, message, sizeof(message), 0); // 关闭客户端和服务器socket，清理Windows Socket库 closesocket(hClntSock); closesocket(hServSock); WSACleanup(); return 0;&#125;// 错误处理函数：打印错误信息并退出程序void ErrorHandling(char *message)&#123; fputs(message, stderr); // 输出错误信息到标准错误流 fputc(&#x27;\\n&#x27;, stderr); // 换行 exit(1); // 退出程序，返回错误码1&#125; 客户端代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// hello_client.c#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;winsock2.h&gt;void ErrorHandling(char *message);// 链接ws2_32.lib库，提供Windows Socket API#pragma comment(lib, &quot;ws2_32.lib&quot;)int main(int argc, char *argv[])&#123; WSADATA wsaData; // Windows Socket库信息结构体 SOCKET hSocket; // 客户端socket句柄 SOCKADDR_IN servAddr; // 服务器地址信息结构体 char message[30]; // 存储从服务器接收的消息 int strLen = 0; // 累计接收的字节数 int idx = 0, readLen = 0; // idx: 消息缓冲区索引, readLen: 单次接收的字节数 // 检查命令行参数数量，需要IP地址和端口号 if(argc != 3) &#123; printf(&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\\n&quot;, argv[0]); exit(1); &#125; // 初始化Windows Socket库，请求版本2.2 if(WSAStartup(MAKEWORD(2,2), &amp;wsaData) != 0) &#123; ErrorHandling(&quot;WSAStartup() error!&quot;); &#125; // 创建TCP socket (PF_INET: IPv4, SOCK_STREAM: TCP, 0: 默认协议) hSocket = socket(PF_INET, SOCK_STREAM, 0); if (hSocket == INVALID_SOCKET) &#123; ErrorHandling(&quot;socket() error!&quot;); &#125; // 配置服务器地址信息 memset(&amp;servAddr, 0, sizeof(servAddr)); // 清零结构体 servAddr.sin_family = AF_INET; // 设置地址族为IPv4 servAddr.sin_addr.s_addr = inet_addr(argv[1]); // 设置服务器IP地址 servAddr.sin_port = htons(atoi(argv[2])); // 设置端口号并转换为网络字节序 // 连接到服务器 if(connect(hSocket, (SOCKADDR*)&amp;servAddr, sizeof(servAddr)) == SOCKET_ERROR) &#123; ErrorHandling(&quot;connect() error!&quot;); &#125; // 逐字节接收服务器发送的数据，直到连接关闭 while(readLen = recv(hSocket, &amp;message[idx++], 1, 0)) &#123; if(readLen == -1) // 接收出错 &#123; ErrorHandling(&quot;recv() error!&quot;); &#125; strLen += readLen; // 累计接收的总字节数 &#125; // 打印接收到的消息和总接收次数 printf(&quot;Message from server : %s \\n&quot;, message); printf(&quot;Function read call count : %d \\n&quot;, strLen); // 关闭socket并清理Windows Socket库 closesocket(hSocket); WSACleanup(); return 0;&#125;// 错误处理函数：打印错误信息并退出程序void ErrorHandling(char *message)&#123; fputs(message, stderr); // 输出错误信息到标准错误流 fputc(&#x27;\\n&#x27;, stderr); // 换行 exit(1); // 退出程序，返回错误码1&#125; 编译运行 注意需要链接 ws2_32.lib 库，有两种方法： 通过 Visual Studio 等集成开发环境，设置附加依赖项，把 ws2_32.lib 链接进来 在编译运行时，通过命令行链接 编译链接的命令行如下： 1gcc hello_client.c -o hClientWin -lws2_32 意味编译 hello_client.c 并与 ws2_32.lib 链接，最终输出 hClientWin.exe 文件。 运行服务端程序，指定一个端口号，会发现程序进入了等待状态，因为调用的 accept 函数还未返回。 12C:NetCoding\\Socket&gt;hServerWin 9190(空白) 接着运行客户端程序，指定对应的 ip 和 port，命令行得到打印结果，同时服务端程序也运行完毕。 123C:NetCoding\\Socket&gt;hClientWin 127.0.0.1 9190Message from server : nice dayFunction read call count : 9 需要注意的点 在客户端代码中，是逐字节接收服务器发送的数据。其实这里可以根据实际需求调整，不一定是一个字节一个字节地接收。这里这样写是因为想要展示非对称的传输：我们使用了 IPv4 + 流失传输的组合（下节介绍），符合这一组合的协议只有 TCP 协议，而 TCP 协议的传输是非对称的，即服务端的发送次数和客户端的接收次数不一定相等。","tags":[],"categories":[{"name":"08-网络编程","slug":"08-网络编程","permalink":"https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Socket","slug":"08-网络编程/Socket","permalink":"https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/"}]},{"title":"01.Socket概览","date":"2025-07-02T05:55:31.000Z","path":"wiki/08-网络编程/Socket/01.Socket概览/","text":"先入为主 网络编程的实际意义就是在两台连网的计算机之间交换数据。除开所需的物理连接外，只需要编写数据传输软件就可以做到了，然而我们通常不需要担心这点，因为操作系统已经为我们提供了名为 Socket 的部件来完成这个事。 由此可以得出定义：Socket（又名套接字）是操作系统层面提供的用于网络传输的软件部件。 套接字使用过程 创建套接字 分配IP地址和端口号 进入接收请求状态 受理连接请求 这是整个套接字编程的“轮廓” 文件描述符 在windows平台又称“文件句柄”。文件描述符是系统分配给文件或者套接字的一个整数值。它类似于一个图书馆中某本书的编号，在程序员和操作系统两者之间，对文件或者套接字操作提供的一个便利性的指代。 如果通过某个函数创建了一个套接字，一般会返回一整数，这个整数就是文件描述符，在下文的代码中，则可以使用这个句柄对套接字做一些操作，有点类似指针。","tags":[],"categories":[{"name":"08-网络编程","slug":"08-网络编程","permalink":"https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Socket","slug":"08-网络编程/Socket","permalink":"https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/"}]},{"title":"","date":"2025-07-01T12:26:56.425Z","path":"wiki/index/","text":"Back Number’s Blog","tags":[],"categories":[]},{"title":"","date":"2025-07-01T12:26:56.404Z","path":"wiki/07-图形学/Blank/","text":"","tags":[],"categories":[{"name":"07-图形学","slug":"07-图形学","permalink":"https://peiyuzou.github.io/categories/07-%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"","date":"2025-07-01T12:26:56.404Z","path":"wiki/06-引擎开发/Blank/","text":"","tags":[],"categories":[{"name":"06-引擎开发","slug":"06-引擎开发","permalink":"https://peiyuzou.github.io/categories/06-%E5%BC%95%E6%93%8E%E5%BC%80%E5%8F%91/"}]},{"title":"","date":"2025-07-01T12:26:56.366Z","path":"wiki/04-程序数学/Blank/","text":"","tags":[],"categories":[{"name":"04-程序数学","slug":"04-程序数学","permalink":"https://peiyuzou.github.io/categories/04-%E7%A8%8B%E5%BA%8F%E6%95%B0%E5%AD%A6/"}]},{"title":"5.x 虚拟机相关函数解读","date":"2025-01-16T02:12:00.000Z","path":"wiki/02-编程语言/Lua/源码阅读/05-虚拟机/5.x-虚拟机相关函数解读/","text":"luaL_loadfilex 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*** 用于加载 Lua 脚本文件或从标准输入读取脚本内容，并将其编译为 Lua 的字节码** 输入：** L - 当前状态机** filename - 脚本文件名称** mode - 指定加载模式（t - 文本，b - 二进制，bt or NULL - 根据首字符自动检查）** 输出：** 编译结果的状态（LUA_OK等）*/LUALIB_API int luaL_loadfilex (lua_State *L, const char *filename, const char *mode) &#123; LoadF lf; int status, readstatus; int c; // 得到文件名在栈上的位置 int fnameindex = lua_gettop(L) + 1; /* index of filename on the stack */ // 处理filename参数 // - 如果 filename 为 NULL，则从标准输入加载脚本并在栈顶压入 =stdin（标识输入来源） // - 如果提供了 filename，尝试以只读模式打开文件。如果失败，则调用 errfile 报错 if (filename == NULL) &#123; lua_pushliteral(L, &quot;=stdin&quot;); lf.f = stdin; &#125; else &#123; lua_pushfstring(L, &quot;@%s&quot;, filename); lf.f = fopen(filename, &quot;r&quot;); if (lf.f == NULL) return errfile(L, &quot;open&quot;, fnameindex); &#125; // 跳过文件中的注释 // - 调用 skipcomment 跳过文件中的注释部分。c 保存第一个非注释字符 // - 如果跳过注释后需要调整行号（如文件首行为注释），将换行符 \\n 添加到缓冲区 if (skipcomment(&amp;lf, &amp;c)) /* read initial portion */ lf.buff[lf.n++] = &#x27;\\n&#x27;; /* add line to correct line numbers */ // 如果是二进制文件，重新以二进制模式打开 // 如果文件的第一个字符与 LUA_SIGNATURE 匹配，表明可能是 Lua 的预编译二进制文件 if (c == LUA_SIGNATURE[0] &amp;&amp; filename) &#123; /* binary file? */ lf.f = freopen(filename, &quot;rb&quot;, lf.f); /* reopen in binary mode */ if (lf.f == NULL) return errfile(L, &quot;reopen&quot;, fnameindex); skipcomment(&amp;lf, &amp;c); /* re-read initial portion */ &#125; // 如果第一个字符是非空字符，将其存入缓冲区，作为流的第一个有效字符 if (c != EOF) lf.buff[lf.n++] = c; /* &#x27;c&#x27; is the first character of the stream */ // 调用 lua_load 编译文件内容为 Lua 字节码 // - 参数 getF 是一个回调函数，从 lf 中读取内容并提供给 lua_load status = lua_load(L, getF, &amp;lf, lua_tostring(L, -1), mode); // 使用 ferror 检查文件是否读取错误 // - 如果有错误，将 Lua 栈恢复到调用此函数之前的状态，并返回错误码 readstatus = ferror(lf.f); if (filename) fclose(lf.f); /* close file (even in case of errors) */ if (readstatus) &#123; lua_settop(L, fnameindex); /* ignore results from &#x27;lua_load&#x27; */ return errfile(L, &quot;read&quot;, fnameindex); &#125; // 清理和返回 // - 在成功加载文件后，移除栈上的文件名信息，保持栈的整洁 lua_remove(L, fnameindex); return status;&#125; lua_load 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*** 在编译解释阶段，负责两个事：** 1.在执行编译前加锁确保线程安全，并初始化一个文件读取流** 2.在编译完成后，给编译结果设置全局表作为第一个上值** 输入：** L - 当前状态机** reader - 回调函数，用于逐步读取代码块的内容** data - 传递给 reader 的用户数据，通常是文件流或内存中的字符串，在 luaL_loadfilex 传过来的是指定文件的文件流** chunkname - 代码块的名字，用于错误提示** mode - 编译模式，文本还是二进制** 输出：** 成功时返回 LUA_OK，并将编译后的 Lua 函数（LClosure）压入栈顶** 失败时返回错误代码，并将错误信息压入栈顶*/LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data, const char *chunkname, const char *mode) &#123; ZIO z; int status; // 加锁，确保线程安全 lua_lock(L); // 缺省 chunkname if (!chunkname) chunkname = &quot;?&quot;; // 初始化 ZIO 流 // - z 是一个 ZIO 结构，它封装了读取代码块内容的逻辑 // - 将 reader 和 data 指定给这个 ZIO，确保用 reader 指定的方式读取 data 的文件内容 luaZ_init(L, &amp;z, reader, data); // 调用解析器 // - 此函数负责对代码块的解析和编译，它运行在一个受保护的环境中，可以捕获并处理运行时错误 // - 解析完成后，将生成的 Lua 函数（LClosure）压入栈顶 status = luaD_protectedparser(L, &amp;z, chunkname, mode); // 设置全局环境 // - L-&gt;top - 1 指向的是上一步生成的放在栈顶的 Lua 函数对象 // - s2v 理解为 StackValue to TValue，它将一个栈元素转化为通用的 TValue 结构体 // - clLvalue 进一步将 TValue 转化为 LClosure (Lua闭包) // - 如果有上值，获取全局表并将全局表设置为该函数的第一个上值 // - luaC_barrier 确保垃圾回收的正确性，维护引用关系 if (status == LUA_OK) &#123; /* no errors? */ LClosure *f = clLvalue(s2v(L-&gt;top - 1)); /* get newly created function */ if (f-&gt;nupvalues &gt;= 1) &#123; /* does it have an upvalue? */ /* get global table from registry */ const TValue *gt = getGtable(L); /* set global table as 1st upvalue of &#x27;f&#x27; (may be LUA_ENV) */ setobj(L, f-&gt;upvals[0]-&gt;v, gt); luaC_barrier(L, f-&gt;upvals[0], gt); &#125; &#125; // 释放锁并返回结果 lua_unlock(L); return status;&#125; f_parser 12345678910111213141516171819202122232425262728293031323334353637/*** lua_load 函数工作流程的一部分** 输入：** L - 当前状态机** ud - 一个通用的用户数据指针，在这里是一个指向 SParser 结构体的指针，包含了解析需要的信息** 输出：** 没有返回，自动检查文件流是二进制还是文本，转发调用 luaU_undump 和 luaY_parser*/static void f_parser (lua_State *L, void *ud) &#123; LClosure *cl; // 将 ud 强制转换为 SParser 指针 // - SParser 包含解析时所需的输入流（z）、缓冲区（buff）、动态数据结构（dyd）以及源文件的名字（name） struct SParser *p = cast(struct SParser *, ud); // 检查文件流类型，转发调用解析函数 // - 二进制调用 luaU_undump // - 文本源码调用 luaY_parser int c = zgetc(p-&gt;z); /* read first character */ if (c == LUA_SIGNATURE[0]) &#123; checkmode(L, p-&gt;mode, &quot;binary&quot;); cl = luaU_undump(L, p-&gt;z, p-&gt;name); &#125; else &#123; checkmode(L, p-&gt;mode, &quot;text&quot;); cl = luaY_parser(L, p-&gt;z, &amp;p-&gt;buff, &amp;p-&gt;dyd, p-&gt;name, c); &#125; // 一致性校验，校验生成的闭包的实际 upvalues 数量是否等于函数原型中定义的数量 // - nupvalues: 闭包中实际的 upvalues 数量 // - sizeupvalues: 函数原型中声明的 upvalues 数量 lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues); // 初始化闭包的 Upvalues（外部变量的引用） // - Upvalues 是闭包执行环境的重要组成部分，确保函数可以正确访问外部变量 luaF_initupvals(L, cl);&#125; luaY_parser 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/*** lua_load 函数工作流程的核心部分，将文本流源码解析生成可执行的函数闭包** 输入：** L - 当前状态机** z - 输入流对象，封装了输入数据（源码的文本流）** buff - 动态缓冲区，用于存储解析过程中的临时数据** dyd - 动态数据结构，包含作用域变量、标签、跳转等动态信息** name - 源文件的名称，用于生成调试信息** firstchar - 输入流的第一个字符，通常在调用时已经读取** 输出：** 返回生成的函数闭包（注意词法分析器的表出栈了，函数闭包仍然在栈上）*/LClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff, Dyndata *dyd, const char *name, int firstchar) &#123; LexState lexstate; FuncState funcstate; // 创建主函数闭包 // - 使用 luaF_newLclosure 创建一个 LClosure 对象。主闭包对应整个 Lua 源码文件的顶层函数 // - 使用 setclLvalue2s 将闭包对象放置在 Lua 堆栈顶端，确保不会被垃圾回收器错误清理 // - 增加堆栈顶指针，以存放闭包 LClosure *cl = luaF_newLclosure(L, 1); /* create main closure */ setclLvalue2s(L, L-&gt;top, cl); /* anchor it (to avoid being collected) */ luaD_inctop(L); // 创建词法分析器的哈希表 // - 为词法分析器创建一张哈希表，存储标识符等信息 // - 将该表放置在 Lua 堆栈顶端，防止其被垃圾回收器清理 lexstate.h = luaH_new(L); /* create table for scanner */ sethvalue2s(L, L-&gt;top, lexstate.h); /* anchor it */ luaD_inctop(L); // 初始化函数原型 // - 创建函数原型: 调用 luaF_newproto 创建函数原型对象（Proto），并将其关联到闭包的 p 字段 // - 对象屏障: 使用 luaC_objbarrier 确保垃圾回收器正确处理新创建对象之间的引用 // - 设置调试信息: 将 source 字段设置为源码的名称 funcstate.f = cl-&gt;p = luaF_newproto(L); luaC_objbarrier(L, cl, cl-&gt;p); funcstate.f-&gt;source = luaS_new(L, name); /* create and anchor TString */ luaC_objbarrier(L, funcstate.f, funcstate.f-&gt;source); // 初始化词法和语法分析器 // - 关联动态数据: 将动态缓冲区和动态数据与词法分析器状态关联 // - 清空动态数据: 重置动态作用域变量、跳转目标和标签的计数 // - 设置输入流: 调用 luaX_setinput 初始化词法分析器，设置输入流 z、调试信息 source 和首字符 firstchar lexstate.buff = buff; lexstate.dyd = dyd; dyd-&gt;actvar.n = dyd-&gt;gt.n = dyd-&gt;label.n = 0; luaX_setinput(L, &amp;lexstate, z, funcstate.f-&gt;source, firstchar); // 解析主函数 // - 调用核心函数 mainfunc，解析整个 Lua 源码文件，构建语法树和函数原型 mainfunc(&amp;lexstate, &amp;funcstate); // 检查解析一致性 // - 检查语法解析是否正确结束： // - 没有多余的嵌套函数 // - FuncState 中的 nups（upvalue 数量）为 1 // - LexState 中 fs（当前的函数状态）为 NULL // - 检查动态数据是否清空 lua_assert(!funcstate.prev &amp;&amp; funcstate.nups == 1 &amp;&amp; !lexstate.fs); /* all scopes should be correctly finished */ lua_assert(dyd-&gt;actvar.n == 0 &amp;&amp; dyd-&gt;gt.n == 0 &amp;&amp; dyd-&gt;label.n == 0); // 清理堆栈并返回 L-&gt;top--; /* remove scanner&#x27;s table */ return cl; /* closure is on the stack, too */&#125;","tags":[],"categories":[{"name":"02-编程语言","slug":"02-编程语言","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"02-编程语言/Lua","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"源码阅读","slug":"02-编程语言/Lua/源码阅读","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"05-虚拟机","slug":"02-编程语言/Lua/源码阅读/05-虚拟机","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"5.1 Lua执行的大致过程","date":"2025-01-15T02:06:22.000Z","path":"wiki/02-编程语言/Lua/源码阅读/05-虚拟机/5.1-Lua执行的大致过程/","text":"和其他语言的执行差异 一般语言分为编译型语言（Compiled Language）和解释型语言（Interpreted Language）。前者会先将代码编译为目标机器可运行的机器码，而后由目标机器直接运行，编译型语言的特点是在编译阶段实现跨平台，不同平台的编译结果不一样，由于它能由机器直接执行，速度会很快。解释型语言则是将代码交给解释器翻译执行，它的特点是由解释器来实现跨平台，平台的差异由语言自身的解释器来解决，由于它需要由解释器来执行，相比前者会慢不少。 Lua 作为一门解释型语言，它实现了自己的虚拟机充当解释器的角色，来解释执行 Lua 代码。这里有一点需要注意，Lua 会先将代码进行语法词法分析，生成虚拟机能看懂的字节码（后称OpCode），再由虚拟机执行。现在不少解释型语言和 Lua 采用了一样的思路，虽然最终是在解释器中执行，但是仍然预先制定了一套语言定制化的编译规则，将代码编译为对应的字节码后再交给解释器执行，这样做会加快代码的执行速度但是仍然有部分语言是采用直接解释执行。比如 Bash、AWK、早期的 PHP、Basic 等 Lua 的即时编译和JIT的区别 Lua 虽然是先编译为字节码，再交由虚拟机执行，但编译也是发生在运行阶段的，也就是说 Lua 是即时编译的。即时编译并不会妨碍它作为解释型语言在运行时可修改的特性，但 Lua 的即时编译和传统的 JIT 有所不同。 Lua 的编译执行过程分为两个阶段： 即时编译阶段（源代码 –&gt; 字节码） 当 Lua 脚本被加载时，Lua 虚拟机会将源代码即时编译为字节码 这一步发生在运行时，即每次加载脚本时都会进行，这个编译过程由 lua_load 函数完成 解释运行阶段（字节码 –&gt; 执行） 编译后的字节码并不会被进一步编译为机器码，而是由 Lua 虚拟机逐条解释执行 Lua 的即时编译与真正的 JIT 编译的区别在于：Lua 即时编译的结果并非目标机器码，而是一种中间表示，只有它的虚拟机能够解释执行。 Lua 为何不采用 JIT 编译？ 它的官方解释器（PUC-Rio Lua）并没有集成 JIT 编译器，原因如下： 跨平台性： Lua 以简单和轻量为核心设计目标，官方解释器支持多种平台，而字节码和虚拟机的实现更容易移植 JIT 编译器需要针对特定的 CPU 架构生成机器码，移植性较差 嵌入式使用： Lua 主要被设计为嵌入式脚本语言，典型场景包括嵌入游戏引擎、应用程序等 字节码解释足以满足大部分需求，同时减少了 JIT 编译的复杂性和内存开销 性能需求： Lua 的性能在许多嵌入式场景下已经足够 对于更高性能需求的场景，可以使用 LuaJIT（Lua 的一个 JIT 编译器版本，将字节码直接编译为机器码，极大提升了性能） 虚拟机概览 除了 Lua，还有一些其他语言也实现了自己的虚拟机比如 Java 和 Python。一般一个语言的虚拟机的职责如下： 将源代码编译成虚拟机可识别执行的字节码 为函数调用准备调用栈 内部维持一个指令指针（IP，Instruction Pointer）来保存下一个将执行的指令地址。在 Lua 中，该 IP 对应的是 PC 指针，后续会讲 模拟一个 CPU 的运行：循环拿出由 IP 指向的字节码，根据字节码格式进行解码，然后执行 这样一来，一台抽象的计算机就出现了，这也是它们被称为虚拟机的原因。 虚拟机有两种实现方式：基于栈（stack-based）和基于寄存器（register-based），市面上常见的都是前者，而 Lua 属于后者。 基于栈的虚拟机 对于这种虚拟机，字节码的操作数从栈顶弹出，执行完操作后再压入栈顶，下图是一个加法操作后栈结构的变化： 这个操作对应的伪代码如下： 1234POP 2POP 1ADD 2,1,resultPUSH result 完成一个加法操作需要 4 条字节码，需要用额外的指令准备数据是这种设计的缺点。但是优点是指令不需要关心操作数的地址，在执行操作前已经将操作数准备在栈顶了 基于寄存器的虚拟机 和基于栈的虚拟机不同，这种虚拟机将操作数存放在 “CPU的寄存器” 中，这个寄存器不是物理意义上的寄存器，而是虚拟机的一种抽象实现。它实现前面的加法操作的示意图如下： 它对应的伪代码如下： 1ADD R1,R2,R3 #寄存器R1与R2相加结果保存在寄存器R3中 这种虚拟机的优点是，指令简短，但缺点是程序需要关注操作数的位置。Lua选择这种寄存器的主要目的是尽可能高效。 执行源码概览 这里以一个宏观的角度浏览整个编译解释和执行的流程，具体函数的分析参考函数解读 luaL_dofile 这是 Lua 执行文件的调用函数，本身是个宏，等效于先调用 luaL_loadfile，再调用 lua_ocall： 12#define luaL_dofile(L, fn) \\ (luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0)) luaL_loadfile 负责进行词法语法分析，lua_pcall 则将分析结果放到虚拟机中执行 编译解释流程","tags":[{"name":"Lua","slug":"Lua","permalink":"https://peiyuzou.github.io/tags/Lua/"}],"categories":[{"name":"02-编程语言","slug":"02-编程语言","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"02-编程语言/Lua","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"源码阅读","slug":"02-编程语言/Lua/源码阅读","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"05-虚拟机","slug":"02-编程语言/Lua/源码阅读/05-虚拟机","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]},{"title":"4.2 表相关的算法","date":"2025-01-14T03:05:06.000Z","path":"wiki/02-编程语言/Lua/源码阅读/04-表/4.2-表相关的算法/","text":"在上一节中，我们简要提到了表的数组部分和哈希部分会进行自适应调整；以正整数为键的数据可能会存储在数组部分，也可能存储在哈希部分；存储在数组部分时，它的键就是数组的索引；而存储在哈希部分时，就是单纯的键值对。Lua有一个标准去做这个调整，保证数组和哈希部分有最优的边界。 我们在来看这个例子： 123local t = &#123;&#125;t[1] = 0t[100] = 0 插入的这两个元素对外部使用者来说，并不能准确地知道它们究竟写入了数组还是哈希表。我们先跳过它的写入逻辑，来看看 table 是怎么处理查找的。 查找 table 处理查找的伪代码如下： 123456789if key &gt; 0 and key &lt;= 数组大小 then --在数组索引范围内 尝试在数组部分查找else 尝试在哈希部分查找 --[[ 1.计算出key的哈希值，根据哈希值访问Node数组得到哈希桶位置 2.遍历哈希桶链表，直到找到对应key ]]end 可以看出来，一个正整数，只有在数组索引范围内时，其存储才会落在数组部分。否则也会存储在哈希部分。 新增 上面关于查找的算法可以看出来，table 的哈希部分采用链地址法。Lua 将哈希桶所在的位置称为 mainposition。哈希部分的链表结构和普通链地址法的哈希表一致： 那么 Lua 在往 table 新增数据的时候，是如何处理的？让我们关注两个入口函数 luaH_set 和 luaH_setint： 12345678910111213141516void luaH_set (lua_State *L, Table *t, const TValue *key, TValue *value) &#123; const TValue *slot = luaH_get(t, key); luaH_finishset(L, t, key, slot, value);&#125;void luaH_setint (lua_State *L, Table *t, lua_Integer key, TValue *value) &#123; const TValue *p = luaH_getint(t, key); if (isabstkey(p)) &#123; TValue k; setivalue(&amp;k, key); luaH_newkey(L, t, &amp;k, value); &#125; else setobj2t(L, cast(TValue *, p), value);&#125; 和以前的版本不同，Lua 5.4.4 中并没有 luaH_setstr、luaH_setnum 等API，它使用了一个公共的 luaH_set 来满足全部类型数据的新增，这本身是得益于 TValue 结构的优化。 luaH_setint ? 而 luaH_setint 则是基于整数键做出的优化函数，它会判断整数键是否属于表的数组部分，从而绕过了非整数键的检查逻辑。这样具有更高的访问效率，减少了很多不必要的逻辑计算。 举个例子： 123local t = &#123;&#125;t[1] = &quot;a&quot; -- 整数键t[&quot;key&quot;] = &quot;b&quot; -- 字符串键 t[1] = \"a\" Lua会调用 luaH_setint 如果键 1 落在数组部分，直接将 \"a\" 存入数组部分 如果键超出数组范围或数组未分配足够大小，调整 alimit 或将键值存入哈希部分 t[\"key\"] = \"b\" Lua 会调用 luaH_set 根据键的类型（字符串），计算其哈希值，找到对应的哈希桶并插入 luaH_newkey 不管是调用 luaH_setint 还是 luaH_set，如果新增的键不存在，都牵涉到一个函数 luaH_newkey： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/*** inserts a new key into a hash table; first, check whether key&#x27;s main** position is free. If not, check whether colliding node is in its main** position or not: if it is not, move colliding node to an empty place and** put new key in its main position; otherwise (colliding node is in its main** position), new key goes to an empty position.*/void luaH_newkey (lua_State *L, Table *t, const TValue *key, TValue *value) &#123; Node *mp; TValue aux; if (l_unlikely(ttisnil(key))) luaG_runerror(L, &quot;table index is nil&quot;); else if (ttisfloat(key)) &#123; lua_Number f = fltvalue(key); lua_Integer k; if (luaV_flttointeger(f, &amp;k, F2Ieq)) &#123; /* does key fit in an integer? */ setivalue(&amp;aux, k); key = &amp;aux; /* insert it as an integer */ &#125; else if (l_unlikely(luai_numisnan(f))) luaG_runerror(L, &quot;table index is NaN&quot;); &#125; if (ttisnil(value)) return; /* do not insert nil values */ mp = mainpositionTV(t, key); if (!isempty(gval(mp)) || isdummy(t)) &#123; /* main position is taken? */ Node *othern; Node *f = getfreepos(t); /* get a free place */ if (f == NULL) &#123; /* cannot find a free place? */ rehash(L, t, key); /* grow table */ /* whatever called &#x27;newkey&#x27; takes care of TM cache */ luaH_set(L, t, key, value); /* insert key into grown table */ return; &#125; lua_assert(!isdummy(t)); othern = mainpositionfromnode(t, mp); if (othern != mp) &#123; /* is colliding node out of its main position? */ /* yes; move colliding node into free position */ while (othern + gnext(othern) != mp) /* find previous */ othern += gnext(othern); gnext(othern) = cast_int(f - othern); /* rechain to point to &#x27;f&#x27; */ *f = *mp; /* copy colliding node into free pos. (mp-&gt;next also goes) */ if (gnext(mp) != 0) &#123; gnext(f) += cast_int(mp - f); /* correct &#x27;next&#x27; */ gnext(mp) = 0; /* now &#x27;mp&#x27; is free */ &#125; setempty(gval(mp)); &#125; else &#123; /* colliding node is in its own main position */ /* new node will go into free position */ if (gnext(mp) != 0) gnext(f) = cast_int((mp + gnext(mp)) - f); /* chain new position */ else lua_assert(gnext(f) == 0); gnext(mp) = cast_int(f - mp); mp = f; &#125; &#125; setnodekey(L, mp, key); luaC_barrierback(L, obj2gco(t), key); lua_assert(isempty(gval(mp))); setobj2t(L, gval(mp), value);&#125; 我们逐段分析，看看这个函数做了什么。 首先是第 11 ~ 24 行，这一段针对 key 做了一些错误处理，中间的分支对于浮点数键做了处理：如果 key 是一个浮点数，但是它的值是一个整数，那么把 key 作为一个整型值插入。 第 25 行，计算得到 key 的哈希值 mainposition，也就是它在哈希数组中的哈希桶的地址 先看 58 ~ 61 行，该 mainposition 位置空闲，这里直接将 key 和 value 设置给该位置的 Node 再看 26 ~ 57 行，该 mainposition 位置冲突（我们暂且称这里存放的节点为冲突节点） 28 ~ 34 行，尝试找一个空闲位置，如果没有，执行一次 rehash 扩张一次 table，然后插入 key 和 value 36 行，有现成的空闲位置，那么计算这个冲突节点的 mainposition 37 ~ 48 行，冲突节点的 mainposition 在其它位置，那么把冲突节点移动到一个空闲位置 50 ~ 57 行，冲突节点的 mainposition 就在它当前位置，那么把当前 key 和 value 插入空闲位置 总结就是：首先，检查 key 的主位置是否空闲。如果不是，则检查冲突节点是否在其主位置：如果不是，则将冲突节点移至空位置并将 key 放入其主位置；否则（冲突节点在其主位置），key 将移至空位置 这里要重点注意，整个操作都是基于哈希表进行的，而没有关于数组的逻辑。因为在执行 luaH_newkey 之前，一定是通过 luaH_get 或者 luaH_getint 在数组部分检查过了，数组部分不存在的情况下，才会走进 luaH_newkey 的逻辑。 rehash 从前面的代码可见，在空闲空间不足的情况下，table 会自动执行一次 rehash，这个函数就是我们在前一节提到的自适应调整数组部分和哈希部分空间的算法，让我们来看看： 1234567891011121314151617181920212223/*** nums[i] = number of keys &#x27;k&#x27; where 2^(i - 1) &lt; k &lt;= 2^i*/static void rehash (lua_State *L, Table *t, const TValue *ek) &#123; unsigned int asize; /* optimal size for array part */ unsigned int na; /* number of keys in the array part */ unsigned int nums[MAXABITS + 1]; int i; int totaluse; for (i = 0; i &lt;= MAXABITS; i++) nums[i] = 0; /* reset counts */ setlimittosize(t); na = numusearray(t, nums); /* count keys in array part */ totaluse = na; /* all those keys are integer keys */ totaluse += numusehash(t, nums, &amp;na); /* count keys in hash part */ /* count extra key */ if (ttisinteger(ek)) na += countint(ivalue(ek), nums); totaluse++; /* compute new size for array part */ asize = computesizes(nums, &amp;na); /* resize the table to new computed sizes */ luaH_resize(L, t, asize, totaluse - na);&#125; 它的大致算法思路如下： 分配一个数组 nums，初始它的每个元素都是 0，假设它的下标用变量 i 表示，它的每个元素的含义是 key 的值在 \\({2^{(i-1)}}\\) ~ \\({2^i}\\) 之间的元素数量（左开右闭） 遍历数组部分，统计元素数量更新到 nums 遍历哈希部分，只统计正整数键，更新到 nums 此时，整个 table 的正整数 key 的分配已经统计在了 nums 中。接着遍历 nums 数组，找到范围区间内包含的整数数量大于50%，满足这个条件的索引可能有很多个，只要索引最大的那个 这个索引作为重新散列后的数组大小，也就是之前提到的 alimit，凡是超过这个值的 key，就分配到了哈希部分 从这个函数可以看出 Lua 的设计思想：简单高效、且尽量节省内存。在重新散列的过程中，除了要增大 table 的大小来容纳新的数据外，还借此机会调整了数组和哈希两个部分，让两部分都尽可能发挥其容纳效率。 下面的图是调整后的数组部分的示意图，每个 2 的幂之间的空间的存储率都大于 50%，这也是 Lua 认为数组达到最大容纳效率的标准： 代价？ 从上面的分析可以看出， Lua 解释器会自动进行重新散列，并且对使用者来说是透明的。从算法和以往对哈希表扩容的经验来看，这个操作的开销不会很小，然而我们在知晓其原理后，可以手动减少它的发生，来看一个例子： 1234local t = &#123;&#125;for i = 1, 3 do t[i] = trueend 这个代码执行会触发 3 次 rehash： 第一次，为了装下 t[1] , Lua 触发了一次 rehash，数组部分长度设置为 1 第二次，数组长度设置为 2 第三次，数组长度设置为 4 也就是说，如果数组部分要装下一个数，需要执行 n 次 rehash，保证 \\({2^n}\\) 大于 key。对于超多元素的表，比如100万个元素，其实也不过触发了 20 次 rehash。但是在一个需要创建大量小长度的表的情况下，这个问题会很严重。但是我们可以尽可能地减少它，来看对比： 我们使用预填充的方法，减少触发重新散列，这里的优化提高了一倍多的速度！ 迭代 1234567891011121314151617181920int luaH_next (lua_State *L, Table *t, StkId key) &#123; unsigned int asize = luaH_realasize(t); unsigned int i = findindex(L, t, s2v(key), asize); /* find original key */ for (; i &lt; asize; i++) &#123; /* try first array part */ if (!isempty(&amp;t-&gt;array[i])) &#123; /* a non-empty entry? */ setivalue(s2v(key), i + 1); setobj2s(L, key + 1, &amp;t-&gt;array[i]); return 1; &#125; &#125; for (i -= asize; cast_int(i) &lt; sizenode(t); i++) &#123; /* hash part */ if (!isempty(gval(gnode(t, i)))) &#123; /* a non-empty entry? */ Node *n = gnode(t, i); getnodekey(L, s2v(key), n); setobj2s(L, key + 1, gval(n)); return 1; &#125; &#125; return 0; /* no more elements */&#125; Lua 中表的迭代并没有设计迭代器，很大原因是为了兼容数组部分和哈希部分的访问。 luaH_next 大致的逻辑是在当前 key 的基础上找下一个有效键值对 如果 key 是 nil，表示从头开始遍历，否则找到该 key 的位置，然后从下一个位置继续 优先遍历数组部分，因为顺序表遍历更快，找到下一个非空值。 如果数组部分没有找到，再遍历哈希部分，这部分就需要遍历每个桶，找到下一个有效键值对 不管在是数组部分还是哈希部分找到，都将键和值压入 Lua 栈，并返回成功或失败（1或0） 取长度 在 Lua 中，我们可以提供元方法 __len 来自定义表的取长度方法，Lua 本身默认提供了 # 作为取长度符号。 它的取长度的结果不是 table 的全部元素的数量，而是 table 的序列部分的长度，这个序列部分指表的第一个键的值连续的数据子集，比如： 1print(#&#123;1,2,3,4,5,nil,10&#125;) -- 输出 5 这和数组部分无关，尽管它看起来像是数组，这个所谓的序列对哈希部分也是一样的规则： 123456789101112local t1 = &#123; [1] = 1, [2] = 2,&#125;print(#t1) -- 输出 2local t2 = &#123; [1] = 1, [2] = 2, [5] = 5,&#125;print(#t2) -- 输出 2 如果一个表混合了这两种风格，那么优先取数组部分的长度： 1print(#&#123;[1] = 1, [2] = 2, 1, 2, 3&#125;) -- 输出 3 取长度对应的源码函数是 luaH_getn，这里不赘述了，它的算法思路大致就是先在数组部分取长度，没有取成功就在哈希部分取 总结 Lua 的表内部分为数组部分和哈希部分，虽然对使用者是透明的，但是理解其存储原理会帮助我们更正确地使用它： 尽量避免混用数组和哈希，提升效率 可以通过预先分配的方式，减少 rehash","tags":[{"name":"Lua","slug":"Lua","permalink":"https://peiyuzou.github.io/tags/Lua/"}],"categories":[{"name":"02-编程语言","slug":"02-编程语言","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"02-编程语言/Lua","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"源码阅读","slug":"02-编程语言/Lua/源码阅读","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"04-表","slug":"02-编程语言/Lua/源码阅读/04-表","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/"}]},{"title":"2.1 Lua中的数据类型","date":"2024-12-10T09:27:20.000Z","path":"wiki/02-编程语言/Lua/源码阅读/02-数据类型/2.1-Lua中的数据类型/","text":"基础类型 123456789101112131415161718// (lua.h)/*** basic types*/#define LUA_TNONE (-1)#define LUA_TNIL 0#define LUA_TBOOLEAN 1#define LUA_TLIGHTUSERDATA 2#define LUA_TNUMBER 3#define LUA_TSTRING 4#define LUA_TTABLE 5#define LUA_TFUNCTION 6#define LUA_TUSERDATA 7#define LUA_TTHREAD 8#define LUA_NUMTYPES 9 宏 类型描述 对应数据结构 LUA_TNONE 无效类型 无 LUA_TNIL 空 无 LUA_TBOOLEAN 布尔 无 LUA_TLIGHTUSERDATA 指针 void * LUA_TNUMBER 数值 lua_Number LUA_TSTRING 字符串 TString LUA_TTABLE 表 Table LUA_TFUNCTION 函数 CClosure、LClosure LUA_TUSERDATA 指针 Udata LUA_TTHREAD Lua虚拟机、协程 lua_State 宏 LUA_NUMTYPES 指有效数据类型的数量，即0~8共9个 其中 LUA_TLIGHTUSERDATA 和 LUA_TUSERDATA 均是指针，userdata 指一些外部的用户知晓的内存块，它们的类型不被 Lua 定义，用指针来访问它们以在 Lua 中实现对外部数据的操作。两者的区别在于，LUA_TLIGHTUSERDATA 的分配释放由外部自己管理，所以 Lua 将它视为值类型，因为不需要分配任何额外空间来存储数据，仅仅只是一个指针而已。LUA_TUSERDATA 则由内部管理，Lua 为它定义了 Udata 结构，存储它的数据，并且加入GC的管理。 需要注意的是，这些宏并不是真正的类型，只是用某个数字代指这个类型，真正的类型是表格中的最后一列：对应数据结构 动态类型是如何实现的？ Lua 是动态类型的语言，动态类型指一个变量在不同时刻可以是不同类型的 它通过一个通用结构体 TValue 来定义任意的类型，源码如下： 12345678910/*** Tagged Values. This is the basic representation of values in Lua:** an actual value plus a tag with its type.*/#define TValuefields Value value_; lu_byte tt_typedef struct TValue &#123; TValuefields;&#125; TValue; 简单来说，tt_ 用于标记这个结构体是什么类型，value_ 则存储实际的值数据。当一个变量需要变为其他类型时，改变它的 tt_ 字段的值，同时设置对应的 Value_ 值即可做到。 类型标记（Type Tag） tt_ 全称是 Type Tag ，用于标记当前对象的类型，它被声明为 lu_byte 类型，lu_byte 宏代指 unsigned char 类型（占一个字节，范围0~255），由于基础类型的标记最高值是8，因此低4位被设计用于标记基础类型，其它的位设计如下： 7 bit 6 bit 5-4 bit 3-0 bit reserved GC Tag variant type tag basic type tag 从表中可以看到，除了低4位被用于标记基础类型，Lua还在 bits(4-5) 设计了变种类型，变种类型让 Lua 对类型标记进一步划分，用于内部更加多样化的数据支持、更加精确地处理数据、甚至是提升性能。如下是 Lua 将数值类型 LUA_TNUMBER 进行变种得到整型数和浮点数的代码： 123456789101112131415// (lobject.h)/*** tags for Tagged Values have the following use of bits:** bits 0-3: actual tag (a LUA_T* constant)** bits 4-5: variant bits** bit 6: whether value is collectable*//* add variant bits to a type */#define makevariant(t,v) ((t) | ((v) &lt;&lt; 4))/* Variant tags for numbers */#define LUA_VNUMINT makevariant(LUA_TNUMBER, 0) /* integer numbers */#define LUA_VNUMFLT makevariant(LUA_TNUMBER, 1) /* float numbers */ 除了 variant type tag 和 basic type tag，还有用于标记是否可被回收的 GC Tag。而 bit 7 目前保留没有任何作用 TValue的结构设计（Value、GCObject和GCUnion） TValue TValue 结构如上图所示，包含一个联合体 value_ 和一个类型标记 tt_，对应源码： 12345678910/*** Tagged Values. This is the basic representation of values in Lua:** an actual value plus a tag with its type.*/#define TValuefields Value value_; lu_byte tt_typedef struct TValue &#123; TValuefields;&#125; TValue; tt_ 标记了联合体 value_ 分配的空间中值的具体类型，由此知道该以什么样的结构使用这块内存。另外，前述内容也提到 tt_ 的第7位标记了当前类型是否是可回收类型，以下代码是判断一个对象是否是可回收的源码： 1234/* Bit mark for collectable types */#define BIT_ISCOLLECTABLE (1 &lt;&lt; 6)#define iscollectable(o) (rawtt(o) &amp; BIT_ISCOLLECTABLE) Value 再看 Value 的设计，这个域负责存储实际的值，我们知道 Lua 有自己的垃圾回收机制，因此它的类型设计包含了可回收和不可回收两种。 在 Value 这一层面，Lua 将这两种类型区分开了，可回收的对象表达为一个指针，而没有直接存储它。不可回收的类型则全部声明为联合体的域。整个联合体只是在栈上分配了一个空间，存储这些域的其中之一： GCObject *gc：指向一个可回收对象的内存地址 void *p：本质就是一个指针，Lua中称它为 lightuserdata，和 userdata 不同，前者不需要 Lua 管理内存，只是作为变量保存一个地址。后者则需要 Lua 负责管理内存 lua_CFunction f：本质上也是一个指针，指向一个 C 函数 lua_Integer i：存储整型数值 lua_Number n：存储浮点数值 GCUnion和GCObject 为了更好地理解 GCObject，我们要先了解 GCUnion 这个联合体 GCUnion 是真正定义GC对象存储位置的结构，Lua 中的全部可回收类型都定义为它的域 其中比较特殊的是 GCObject，它只包含一个 CommonHeader 宏，源码定义如下： 1234567891011/*** Common Header for all collectable objects (in macro form, to be** included in other objects)*/#define CommonHeader struct GCObject *next; lu_byte tt; lu_byte marked/* Common type for all collectable objects */typedef struct GCObject &#123; CommonHeader;&#125; GCObject; CommonHeader 包含三个域： GCObject *next：这个指针指向下一个 GC 对象，所有 GC 对象通过各自的 next 指针链接起来形成整个 GC 链表 lu_byte tt：也是类型标记，和 tt_ 相同，但由于 GCObject 在堆内存中单独分配，所以这里为它再存了一份，便于访问 lu_byte marked：GC 阶段的标记 Lua 中需要 GC 的类型很多，但在作为可回收对象时，都是统一作为 GCObject 类型。这里很多人会产生一个疑问：GCUnion 作为一个联合体，同一个内存如何转换 GCObject 和其他类型？ 要回答这个问题，需要看其他 GC 类型的定义： 1234567891011121314typedef struct TString &#123; CommonHeader; ... /* other fields */&#125; TString;typedef struct Udata &#123; CommonHeader; ... /* other fields */&#125; Udata;typedef struct Table &#123; CommonHeader; ... /* other fields */&#125; Table; 现在应该明白了，所有类型的内存头部都是相同的结构 CommonHeader，相当于需要把一个类型作为 GCObject 的时候，只是访问了这个头部结构的内存数据罢了。 除开 GCObject ，其他的类型我们先简单了解下： 类型 说明 TString 字符串 Udata 用户数据指针 Closure 闭包 Table 表 Proto 函数原型 lua_State Lua虚拟机 UpVal 上值","tags":[{"name":"Lua","slug":"Lua","permalink":"https://peiyuzou.github.io/tags/Lua/"}],"categories":[{"name":"02-编程语言","slug":"02-编程语言","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"02-编程语言/Lua","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"源码阅读","slug":"02-编程语言/Lua/源码阅读","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"02-数据类型","slug":"02-编程语言/Lua/源码阅读/02-数据类型","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"4.1 表的数据结构","date":"2024-12-10T06:59:20.000Z","path":"wiki/02-编程语言/Lua/源码阅读/04-表/4.1-表的数据结构/","text":"Lua 用 table 来表示一切数据结构，为了效率，Lua 将 table 的存储分为了 数组 和 哈希表 两个部分。 数组部分提供了紧凑且高效的随机访问。它的索引从1开始，这是 Lua 区别于其他语言的一个地方。 无法存进数组的其他数据则存储在哈希表中，它的键可以是除nil外的任意值。 这样的分开存储对使用者来说完全透明，但是我们需要掌握它存储的原理和逻辑，否则会造成预想不到的性能开销。它的数据结构定义如下： 1234567891011typedef struct Table &#123; CommonHeader; lu_byte flags; /* 1&lt;&lt;p means tagmethod(p) is not present */ lu_byte lsizenode; /* log2 of size of &#x27;node&#x27; array */ unsigned int alimit; /* &quot;limit&quot; of &#x27;array&#x27; array */ TValue *array; /* array part */ Node *node; Node *lastfree; /* any free position is before this position */ struct Table *metatable; GCObject *gclist;&#125; Table; 简单介绍下它的每个域： CommonHeader：可回收对象默认在头部分配的内存 flags：表示这个表提供了哪些元方法，置 1 的位代表对应的元方法没有实现，元方法对应的 bit 定义在 ltm.h 文件中 lsizenode：存储哈希表的大小，它的值是以2为底的对数。比如哈希表的长度是256，那么 lsizenode 的值为8，由此我们可以得到两个信息： 哈希表扩容是在原基础上加一倍，哈希表的内存大小始终是 2 的幂 这个域之所以是 byte 类型，是因为足够了 alimit：表示数组部分的逻辑边界，下文详解 array：指向数组部分的指针 node：指向哈希部分起始位置的指针 lastfree：指向哈希部分最后位置的指针 metatable：指向当前表的元表的指针 gclist：GC相关的链表，后续讲GC再探讨 alimit alimit 理解为 array limit，是 Lua 5.4 引入的一个字段，用于标记 Table 数组部分的 逻辑边界。它的主要作用是动态调整数组部分的有效范围，从而优化表的访问效率。 怎么理解所谓的逻辑边界？首先，Lua 对数组的内存分配并不是最大索引是多少就分配多少，而是一个和哈希表大小挂钩自适应调整大小的分配规则（下文会分析），最后数组的大小会调整为一个2的幂。而 alimit 代表当前数组部分实际使用的索引范围。 先说下这个自适应调整是什么意思，假设我们有以下代码： 123local t = &#123;&#125;t[1] = 0t[100] = 0 我们往一个 table 中插入了两个元素，这两个元素一定会分配在数组中吗？这是不一定的。Lua 会根据数组部分的有效索引和哈希部分的全部正整数 key（数组下标只能是正整数）的分布情况，以一个位图算法计算出一个边界，超过这个边界的部分会存储在哈希表中，这是整个自适应调整的大致逻辑，后面讲 table 相关算法时会详细分解。 那为什么需要 alimit ? 优化性能：在 Lua 中，数组部分的大小会根据表的使用情况动态调整，但实际使用的范围可能小于分配的大小。使用 alimit 可以快速判断哪些索引属于数组部分，而无需频繁操作内存。 支持稀疏数组：Lua 表可以是稀疏的，即索引并非连续的整数。alimit 帮助区分哪些索引属于数组部分，哪些应该存储在哈希部分。 使用 alimit 的场景 快速访问：通过 alimit，Lua 可以快速判断某个索引是否在数组部分的有效范围内，而无需逐一检查。 表的结构发生变化：如插入或删除元素，Lua 会重新评估表的分布（rehash）。在 rehash 过程中，Lua 会调整 alimit 以确保数组部分的逻辑边界是最优的。 为什么不再存储数组的实际大小（物理大小）？ 首先通过 alimit 可以非常迅速地计算出实际大小，两者同时存储有些浪费。alimit 对于判断索引范围帮助更大，因此没有存储实际大小。 通过 alimit 算实际大小，本质上是算一个大于 alimit 的最小2的幂。如果一个 table 频繁地 rehash，这部分也存在一定的计算开销，Lua 考虑到了这个问题，让我们看看通过 alimit 计算实际大小的源码： 1234567891011121314151617181920212223242526272829/*** True if value of &#x27;alimit&#x27; is equal to the real size of the array** part of table &#x27;t&#x27;. (Otherwise, the array part must be larger than** &#x27;alimit&#x27;.)*/#define limitequalsasize(t) (isrealasize(t) || ispow2((t)-&gt;alimit))/*** Returns the real size of the &#x27;array&#x27; array*/LUAI_FUNC unsigned int luaH_realasize (const Table *t) &#123; if (limitequalsasize(t)) return t-&gt;alimit; /* this is the size */ else &#123; unsigned int size = t-&gt;alimit; /* compute the smallest power of 2 not smaller than &#x27;n&#x27; */ size |= (size &gt;&gt; 1); size |= (size &gt;&gt; 2); size |= (size &gt;&gt; 4); size |= (size &gt;&gt; 8); size |= (size &gt;&gt; 16);#if (UINT_MAX &gt;&gt; 30) &gt; 3 size |= (size &gt;&gt; 32); /* unsigned int has more than 32 bits */#endif size++; lua_assert(ispow2(size) &amp;&amp; size/2 &lt; t-&gt;alimit &amp;&amp; t-&gt;alimit &lt; size); return size; &#125;&#125; Lua 对此做出的优化是，先判断当前 table 的 alimit 是否和实际大小一致，不一致再计算。它的核心是 isrealasize 方法，由此我们引申出下面的源码： 1234567891011/*** About &#x27;alimit&#x27;: if &#x27;isrealasize(t)&#x27; is true, then &#x27;alimit&#x27; is the** real size of &#x27;array&#x27;. Otherwise, the real size of &#x27;array&#x27; is the** smallest power of two not smaller than &#x27;alimit&#x27; (or zero iff &#x27;alimit&#x27;** is zero); &#x27;alimit&#x27; is then used as a hint for #t.*/#define BITRAS (1 &lt;&lt; 7)#define isrealasize(t) (!((t)-&gt;flags &amp; BITRAS))#define setrealasize(t) ((t)-&gt;flags &amp;= cast_byte(~BITRAS))#define setnorealasize(t) ((t)-&gt;flags |= BITRAS) 结合上面的代码和它们的调用，这里 Lua 实际上是把结果记录在了 flags 域中, 在第 8 位（bit 7）如果标记为 1，那么代表该表的 alimit 不等于数组的实际大小。这里会产生一个疑问，flags 本来是用于标记元方法是否有效，在第 8 位存储，不会影响元方法的判断吗？（TM_SUB 是元方法掩码 7） 这里其实在设计上已经被切开了，当前表如果是元表，那么它的 flags 域会被用于元方法标记，而不会有 BITRAS 的判断。如果当前表不是元表，那么 flags 会用于标记 BITRAS 哈希表的结构 上图可以看出，array 域指向一个数组部分的起始位置。node 域指向一个哈希表的起始位置， lastfree 则是指向哈希表最后的位置。 这里我们需要关注下哈希表的节点，它的类型是 Node，定义如下： 12345678910111213141516/*** Nodes for Hash tables: A pack of two TValue&#x27;s (key-value pairs)** plus a &#x27;next&#x27; field to link colliding entries. The distribution** of the key&#x27;s fields (&#x27;key_tt&#x27; and &#x27;key_val&#x27;) not forming a proper** &#x27;TValue&#x27; allows for a smaller size for &#x27;Node&#x27; both in 4-byte** and 8-byte alignments.*/typedef union Node &#123; struct NodeKey &#123; TValuefields; /* fields for value */ lu_byte key_tt; /* key type */ int next; /* for chaining */ Value key_val; /* key value */ &#125; u; TValue i_val; /* direct access to node&#x27;s value as a proper &#x27;TValue&#x27; */&#125; Node; Node 作为一个联合体，它头部的内存空间用于存储实际的值，这样可以通过 i_val 域直接访问。当需要访问键和链表的内容时，结合后续的内存作为 NodeKey 结构体访问。next 指向链表中的下一个节点，而 key_tt 和 key_val 存储了键的类型和实际值 表的创建和释放 1234567891011121314151617Table *luaH_new (lua_State *L) &#123; GCObject *o = luaC_newobj(L, LUA_VTABLE, sizeof(Table)); Table *t = gco2t(o); t-&gt;metatable = NULL; t-&gt;flags = cast_byte(maskflags); /* table has no metamethod fields */ t-&gt;array = NULL; t-&gt;alimit = 0; setnodevector(L, t, 0); return t;&#125;void luaH_free (lua_State *L, Table *t) &#123; freehash(L, t); luaM_freearray(L, t-&gt;array, luaH_realasize(t)); luaM_free(L, t);&#125; 创建和释放的逻辑很简单，创建时分配好内存空间，然后给初始化数组部分和哈希部分的指针。释放则是先释放掉哈希部分，然后是数组部分，最后释放掉整个表。 有一个点需要注意，设置哈希部分的逻辑是调用 setnodevector(L, t, 0)，它的逻辑如下： 123456789101112131415161718192021222324252627282930/*** Creates an array for the hash part of a table with the given** size, or reuses the dummy node if size is zero.** The computation for size overflow is in two steps: the first** comparison ensures that the shift in the second one does not** overflow.*/static void setnodevector (lua_State *L, Table *t, unsigned int size) &#123; if (size == 0) &#123; /* no elements to hash part? */ t-&gt;node = cast(Node *, dummynode); /* use common &#x27;dummynode&#x27; */ t-&gt;lsizenode = 0; t-&gt;lastfree = NULL; /* signal that it is using dummy node */ &#125; else &#123; int i; int lsize = luaO_ceillog2(size); if (lsize &gt; MAXHBITS || (1u &lt;&lt; lsize) &gt; MAXHSIZE) luaG_runerror(L, &quot;table overflow&quot;); size = twoto(lsize); t-&gt;node = luaM_newvector(L, size, Node); for (i = 0; i &lt; (int)size; i++) &#123; Node *n = gnode(t, i); gnext(n) = 0; setnilkey(n); setempty(gval(n)); &#125; t-&gt;lsizenode = cast_byte(lsize); t-&gt;lastfree = gnode(t, size); /* all positions are free */ &#125;&#125; 这里 Lua 为了减少空表的维护，定义了一个不可改写的空哈希表：dummynode。空表被初始化时，node 域直接指向这个全局节点。由于它是只读的，所以不会引起线程安全问题。","tags":[{"name":"Lua","slug":"Lua","permalink":"https://peiyuzou.github.io/tags/Lua/"}],"categories":[{"name":"02-编程语言","slug":"02-编程语言","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"02-编程语言/Lua","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"源码阅读","slug":"02-编程语言/Lua/源码阅读","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"04-表","slug":"02-编程语言/Lua/源码阅读/04-表","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/"}]},{"title":"3.2 字符串的相关实现","date":"2024-12-09T09:08:44.000Z","path":"wiki/02-编程语言/Lua/源码阅读/03-字符串/3.2-字符串的相关实现/","text":"字符串比较 短字符串的比较很简单，由于被内部化，只需要比较内存地址即可： 123456// lstring.h/*** equality for short strings, which are always internalized*/#define eqshrstr(a,b) check_exp((a)-&gt;tt == LUA_VSHRSTR, (a) == (b)) 对于长字符串，首先比较长度，长度相同的情况下需要逐字节比较： 12345678910/*** equality for long strings*/int luaS_eqlngstr (TString *a, TString *b) &#123; size_t len = a-&gt;u.lnglen; lua_assert(a-&gt;tt == LUA_VLNGSTR &amp;&amp; b-&gt;tt == LUA_VLNGSTR); return (a == b) || /* same instance or... */ ((len == b-&gt;u.lnglen) &amp;&amp; /* equal length and ... */ (memcmp(getstr(a), getstr(b), len) == 0)); /* equal contents */&#125; 短字符串的内部化 直接上内部化的代码： 123456789101112131415161718192021222324252627282930313233// lstring.c/*** Checks whether short string exists and reuses it or creates a new one.*/static TString *internshrstr (lua_State *L, const char *str, size_t l) &#123; TString *ts; global_State *g = G(L); stringtable *tb = &amp;g-&gt;strt; unsigned int h = luaS_hash(str, l, g-&gt;seed); TString **list = &amp;tb-&gt;hash[lmod(h, tb-&gt;size)]; lua_assert(str != NULL); /* otherwise &#x27;memcmp&#x27;/&#x27;memcpy&#x27; are undefined */ for (ts = *list; ts != NULL; ts = ts-&gt;u.hnext) &#123; if (l == ts-&gt;shrlen &amp;&amp; (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) &#123; /* found! */ if (isdead(g, ts)) /* dead (but not collected yet)? */ changewhite(ts); /* resurrect it */ return ts; &#125; &#125; /* else must create a new string */ if (tb-&gt;nuse &gt;= tb-&gt;size) &#123; /* need to grow string table? */ growstrtab(L, tb); list = &amp;tb-&gt;hash[lmod(h, tb-&gt;size)]; /* rehash with new size */ &#125; ts = createstrobj(L, l, LUA_VSHRSTR, h); memcpy(getstr(ts), str, l * sizeof(char)); ts-&gt;shrlen = cast_byte(l); ts-&gt;u.hnext = *list; *list = ts; tb-&gt;nuse++; return ts;&#125; 我们详细分析下： 12global_State *g = G(L);stringtable *tb = &amp;g-&gt;strt; 这里认证了短字符串存放在全局字符串表这个说法，strt 就是 string table 的简写 12unsigned int h = luaS_hash(str, l, g-&gt;seed);TString **list = &amp;tb-&gt;hash[lmod(h, tb-&gt;size)]; luaS_hash 在上节的Lua为应对DoS攻击做出的修改中有提到，这个函数用于计算字符串的哈希值。然后和经典的链式寻址哈希表的实现一致，lua也用形如 index = hash(key) % capacity 的逻辑计算得到哈希桶的下标。所以这里得到的 list 就是当前字符串存储的桶（链表） 12345678for (ts = *list; ts != NULL; ts = ts-&gt;u.hnext) &#123; if (l == ts-&gt;shrlen &amp;&amp; (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) &#123; /* found! */ if (isdead(g, ts)) /* dead (but not collected yet)? */ changewhite(ts); /* resurrect it */ return ts; &#125;&#125; 上面这部分就是在桶中查是否有已经存过的相同字符串，（这也是内部化的核心，合并相同内容的字符串）如果有，那么就直接返回它，不用再创建。值得注意的是这里的 isdead 和 changewhite 的处理，原文对这里有清楚地解释： 这里需要检查表中的字符串是否是死掉的字符串。这是因为Lua的垃圾收集过程是分步完成的。而向字符串池添加新字符串在任何步骤之间都可能发生。有可能在标记完字符串后发现有些字符串没有任何引用，但在下个步骤中又产生了相同的字符串导致这个字符串复活 12345678910111213141516171819202122232425262728293031323334353637383940if (tb-&gt;nuse &gt;= tb-&gt;size) &#123; /* need to grow string table? */ growstrtab(L, tb); list = &amp;tb-&gt;hash[lmod(h, tb-&gt;size)]; /* rehash with new size */&#125;// lstring.cstatic void growstrtab (lua_State *L, stringtable *tb) &#123; if (l_unlikely(tb-&gt;nuse == MAX_INT)) &#123; /* too many strings? */ luaC_fullgc(L, 1); /* try to free some... */ if (tb-&gt;nuse == MAX_INT) /* still too many? */ luaM_error(L); /* cannot even create a message... */ &#125; if (tb-&gt;size &lt;= MAXSTRTB / 2) /* can grow string table? */ luaS_resize(L, tb-&gt;size * 2);&#125;/*** Resize the string table. If allocation fails, keep the current size.** (This can degrade performance, but any non-zero size should work** correctly.)*/void luaS_resize (lua_State *L, int nsize) &#123; stringtable *tb = &amp;G(L)-&gt;strt; int osize = tb-&gt;size; TString **newvect; if (nsize &lt; osize) /* shrinking table? */ tablerehash(tb-&gt;hash, osize, nsize); /* depopulate shrinking part */ newvect = luaM_reallocvector(L, tb-&gt;hash, osize, nsize, TString*); if (l_unlikely(newvect == NULL)) &#123; /* reallocation failed? */ if (nsize &lt; osize) /* was it shrinking table? */ tablerehash(tb-&gt;hash, nsize, osize); /* restore to original size */ /* leave table as it was */ &#125; else &#123; /* allocation succeeded */ tb-&gt;hash = newvect; tb-&gt;size = nsize; if (nsize &gt; osize) tablerehash(newvect, osize, nsize); /* rehash for new size */ &#125;&#125; 既然是哈希表，自然离不开负载因子过大（哈希冲突严重）导致扩容这个话题，上面的代码也给出了Lua的方案，可以看出Lua的负载因子默认是1，即 size / capacity = 1 时会触发扩容 1234567891011121314151617181920212223ts = createstrobj(L, l, LUA_VSHRSTR, h);memcpy(getstr(ts), str, l * sizeof(char));ts-&gt;shrlen = cast_byte(l);ts-&gt;u.hnext = *list;*list = ts;tb-&gt;nuse++;return ts;/*** creates a new string object*/static TString *createstrobj (lua_State *L, size_t l, int tag, unsigned int h) &#123; TString *ts; GCObject *o; size_t totalsize; /* total size of TString object */ totalsize = sizelstring(l); o = luaC_newobj(L, tag, totalsize); ts = gco2ts(o); ts-&gt;hash = h; ts-&gt;extra = 0; getstr(ts)[l] = &#x27;\\0&#x27;; /* ending 0 */ return ts;&#125; 剩下的这部分则是创建一个新的短字符串的逻辑，其核心是 createstrobj 函数，需要注意的是，为了兼容C接口，Lua会在字符串末尾加上一个 \\0，但这个结尾符并不计算在字符串长度内","tags":[{"name":"Lua","slug":"Lua","permalink":"https://peiyuzou.github.io/tags/Lua/"}],"categories":[{"name":"02-编程语言","slug":"02-编程语言","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"02-编程语言/Lua","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"源码阅读","slug":"02-编程语言/Lua/源码阅读","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"03-字符串","slug":"02-编程语言/Lua/源码阅读/03-字符串","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/03-%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"3.1 字符串的数据结构设计","date":"2024-12-09T05:47:03.000Z","path":"wiki/02-编程语言/Lua/源码阅读/03-字符串/3.1-字符串的数据结构设计/","text":"基本设计 由任意的8位字符组合形成字符串 存储形式是带长度的内存块，也就是存内容的同时，也有额外空间保存长度 为了兼容C库函数，Lua的字符串也在其内容的末尾添加 \\0，标记字符串结束 两种内部形式：长字符串和短字符串 对于外部来说，字符串只有一种类型，归属于Lua的9种基本类型之一，源码定义如下： 123456789101112131415161718// lua.h/*** basic types*/#define LUA_TNONE (-1)#define LUA_TNIL 0#define LUA_TBOOLEAN 1#define LUA_TLIGHTUSERDATA 2#define LUA_TNUMBER 3#define LUA_TSTRING 4#define LUA_TTABLE 5#define LUA_TFUNCTION 6#define LUA_TUSERDATA 7#define LUA_TTHREAD 8#define LUA_NUMTYPES 9 其中-1代表无效类型，0~8是9种基本类型的标识（其中字符串是4），LUA_NUMTYPES 是指基本类型的数量有9个 在字符串核心源码脚本 lstring.c 中，并没有用到 LUA_TSTRING，而是使用 LUA_VSHRSTR 和 LUA_VLNGSTR 两个变种类型，以此来对长短字符串作区分以实现不同的内部处理，长短字符串的类型定义如下： 12345678// lobject.h/* add variant bits to a type */#define makevariant(t,v) ((t) | ((v) &lt;&lt; 4))/* Variant tags for strings */#define LUA_VSHRSTR makevariant(LUA_TSTRING, 0) /* short strings */#define LUA_VLNGSTR makevariant(LUA_TSTRING, 1) /* long strings */ makevariant 仅对类型作左移4位的操作，由此让Lua内部支持对类型进行细分，比如 nil 内部可以分为 nil、empty、abstkey，number 内部被分为浮点数和整型等。 1.长短字符如何界定？存储方式有何差异？ 12345678910111213// llimits.h// 注释翻译：短字符串（即内部化的字符串）的最大长度。//（不能小于元方法的保留字或标记，因为这些字符串必须内部化）/*** Maximum length for short strings, that is, strings that are** internalized. (Cannot be smaller than reserved words or tags for** metamethods, as these strings must be internalized;** #(&quot;function&quot;) = 8, #(&quot;__newindex&quot;) = 10.)*/#if !defined(LUAI_MAXSHORTLEN)#define LUAI_MAXSHORTLEN 40#endif 这里需要注意 内部化 的含义，内部化的意思是指，在同一个 Lua State 中，相同的字符串只会存在一份，合并相同的字符串可以大量减少内存占用，并且可以缩短比较时间，因为只需要比较内存地址是否相同即可，而不需要逐字节比较。Lua内部的保留字和标记也理所应当需要被内部化，其中最长的保留字是 __newindex 长度是10个字符，因此 LUAI_MAXSHORTLEN 不可以被设置小于10 这个值可以由用户自行决定，但Lua给出的默认界定值是40，超过40的字符串被认为是长字符串。 存储方式的差异： 短字符串存储在 全局字符串哈希表 中，即 global_State 中的 strt 字段，这个哈希表内部采用链地址法的方式，实现方式比较简单 长字符串则直接存储在字符串内部的字段中，在原文的Lua版本中，长字符串甚至不存储在 TString 的内存块内，而是紧跟着存储在 TString 的内存块后面 2.字符串类型的实现结构 12345678910111213141516// lobject.h/*** Header for a string value.*/typedef struct TString &#123; CommonHeader; lu_byte extra; /* reserved words for short strings; &quot;has hash&quot; for longs */ lu_byte shrlen; /* length for short strings */ unsigned int hash; union &#123; size_t lnglen; /* length for long strings */ struct TString *hnext; /* linked list for hash table */ &#125; u; char contents[1];&#125; TString; 2.1 CommonHeader 我们先看第一个宏 CommonHeader，它的定义如下： 12345/*** Common Header for all collectable objects (in macro form, to be** included in other objects)*/#define CommonHeader struct GCObject *next; lu_byte tt; lu_byte marked CommonHeader 并不是字符串专属，Lua对一切需要被垃圾收集器管理的对象，均会插入这个宏。它会在垃圾回收的章节中细讲，这里不赘述。我们这里关注一个域：tt 让我们回想上面的内容，字符串在基本类型中的定义是 LUA_TSTRING，并且在内部还细分为了 LUA_VSHRSTR 和 LUA_VLNGSTR，这里怎么又有一个 TString 类型，到底哪个才是字符串类型？ 要回答这个问题，就需要了解 tt 的设计，Lua为了清楚地知道每一个对象的实际类型，需要对每一个参与垃圾收集的对象做类型标记（type tag，简写为tt），也就是花了一个域的空间来存储这个对象的类型，因此 tt 也可以理解为 类型的类型 或者 类型的值。 所以 LUA_TSTRING 、LUA_VSHRSTR 和 LUA_VLNGSTR 并不是字符串的类型定义，它们仅仅标记当前这个字符串的内部类型，真正定义一个字符串结构的是 TString 2.2 extra 这个域的作用和注释解释的一样： 对短字符串来说，它用来标记当前字符串是否是保留字，这会用于词法分析 对长字符串来说，它表示是否计算了hash，这用于惰性求哈希值 惰性：在取Hash值时才判断是否已经计算，已经计算则返回计算好的结果，否则当场计算 从外部压入一个长字符串时，没有立刻计算其hash值，只是简单地复制一遍字符串内容，然后标记一下extra域，标记为没有hash。直到需要对字符串做键匹配时，才惰性计算hash值，加快之后的键比较过程 2.3 shrlen 如果当前字符串是短字符串，存储短字符串的长度 2.4 hash 当前字符串的哈希值，由于短字符串存储在 2.5 lnglen、hnext以及u的设计 首先我们看 lnglen 和 hnext 的含义，再来看为何要结合两者形成 u lnglen 存储长字符串的长度，区别于 shrlen 只有一个 lu_byte (unsigned char)) 的大小，它给了一个 size_t (unsigned int64) 的大小给的很充足 hnext 则与长字符串无关，由于采用链表寻址，短字符串存储在全局字符哈希表中的单个哈希桶中，该指针指向哈希桶的下一个链表节点，也就是哈希冲突的下一个元素。这个指针的作用是在删除当前短字符串，或者全局哈希表触发了 rehash 操作的时候，亦或是新建字符串触发 内部化 查询的时候，帮助Lua内部更高效地处理哈希表 Union 是一种共用体，允许多个成员共用同一段内存，而不是分别占用内存。像 lnglen 和 hnext 特别使用 Union，因为它们的应用场景是互斥的，只可能有两者之一被使用，这样一来节省了字符串字段的内存占用。其实这里 lnglen 和 shrlen 也是互斥的，但是这里明显使用 hnext 更优，毕竟指针最少占用4字节（64位操作系统就是64÷8=8个字节），将两个占用大的声明在一起更节省，这种细节设计也是比较精彩的 2.6 contents 长字符串存储实际字符串内容的数组，从一个 TString 类型的对象中取实际字符串内容的API： 1234/*** Get the actual string (array of bytes) from a &#x27;TString&#x27;.*/#define getstr(ts) ((ts)-&gt;contents) Hash DoS 在Lua5.2.0及之前，字符串不管长短一律内部化后存放在字符串表中，当时字符串哈希值的计算代码如下： 12345678unsigned int luaS_hash (const char *str, size_t l) &#123; unsigned int h = cast(unsigned int, l); size_t step = (1&gt;&gt;5)+1; size_t l1; for (l1=l; l1&gt;=step; l1-=step) h = h ^ ((h&lt;&lt;5)+(h&gt;&gt;2)+cast(unsigned char, str[l1-l])); return h;&#125; 原文：Lua5.2.0发布不久，有人在邮件列表中提出，Lua的这个设计有可能对其给于 Hash Dos 攻击的机会。攻击者可以轻易构造出上千万拥有相同哈希值的不同字符串，以此数十倍的降低Lua从外部压入字符串进入内部字符串表的效率。当Lua用于大量依赖字符串处理的诸如HTTP服务的处理时，输入的字符串不可控制，很容易被人恶意利用 从Lua5.2.1开始，为了解决这个问题做了如下改动： 长字符串独立出来，不再通过内部化进入全局字符串表 使用一个随机种子用于哈希值的计算，使攻击者无法轻易构造出拥有相同哈希值的不同字符串 这里我们看下5.4.4版本的实现： 12345678// lstring.cunsigned int luaS_hash (const char *str, size_t l, unsigned int seed) &#123; unsigned int h = seed ^ cast_uint(l); for (; l &gt; 0; l--) h ^= ((h&lt;&lt;5) + (h&gt;&gt;2) + cast_byte(str[l - 1])); return h;&#125; 这个随机种子 seed 在默认情况下是在 Lua State 创建时放在全局表中的，它利用了构造状态机的内存地址随机性，以及用户可配置的一个随机量（默认是使用time函数获取时间构造种子）同时决定，如下是相关代码： 123456789101112131415161718192021// lstate.c/*** Compute an initial seed with some level of randomness.** Rely on Address Space Layout Randomization (if present) and** current time.*/#define addbuff(b,p,e) \\ &#123; size_t t = cast_sizet(e); \\ memcpy(b + p, &amp;t, sizeof(t)); p += sizeof(t); &#125;static unsigned int luai_makeseed (lua_State *L) &#123; char buff[3 * sizeof(size_t)]; unsigned int h = cast_uint(time(NULL)); int p = 0; addbuff(buff, p, L); /* heap variable */ addbuff(buff, p, &amp;h); /* local variable */ addbuff(buff, p, &amp;lua_newstate); /* public function */ lua_assert(p == sizeof(buff)); return luaS_hash(buff, p, h);&#125; 种子的存放和使用，相关代码： 123456789101112131415161718192021// lstate.c/* 创建状态机时存放在全局状态机种 */LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) &#123; ... g-&gt;seed = luai_makeseed(L); ...&#125;/* 返回或者构建短字符串 */static TString *internshrstr (lua_State *L, const char *str, size_t l) &#123; ... unsigned int h = luaS_hash(str, l, g-&gt;seed); ...&#125;/* 构建长字符串 */TString *luaS_createlngstrobj (lua_State *L, size_t l) &#123; TString *ts = createstrobj(L, l, LUA_VLNGSTR, G(L)-&gt;seed); ...&#125;","tags":[{"name":"Lua","slug":"Lua","permalink":"https://peiyuzou.github.io/tags/Lua/"}],"categories":[{"name":"02-编程语言","slug":"02-编程语言","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"02-编程语言/Lua","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"源码阅读","slug":"02-编程语言/Lua/源码阅读","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"03-字符串","slug":"02-编程语言/Lua/源码阅读/03-字符串","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/03-%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"2.1 全局状态机及内存管理","date":"2024-12-05T09:05:55.000Z","path":"wiki/02-编程语言/Lua/源码阅读/02-全局状态机及内存/2.1-全局状态机及内存管理/","text":"luaL_newstate 从创建Lua虚拟机的函数 luaL_newstate 入手，这个函数可能是外部最常见的函数之一，它无需参数，返回一个指向 lua_State 类型内存地址的指针，在xLua中，它对应如下接口声明： 1234// LuaDLL.cs[DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)]public static extern IntPtr luaL_newstate(); luaL_newstate 的源码片段如下，注意它的函数签名，和C#中声明动态链接库时的签名是一致的： 12345678910/* lauxlib.c */LUALIB_API lua_State *luaL_newstate (void) &#123; lua_State *L = lua_newstate(l_alloc, NULL); if (l_likely(L)) &#123; lua_atpanic(L, &amp;panic); lua_setwarnf(L, warnfoff, L); /* default is warnings off */ &#125; return L;&#125; 分析这段源码： 1、LUALIB_API是什么？ 跳转到定义，可以发现Lua对API的封装分为了以下三个等级： LUA_API：核心API LUALIB_API：辅助库函数 LUAMOD_API：标准库开放函数 但实际的定义，后两者都同LUA_API（More often than not the libs go together with the core. 很多时候，库与核心结合在一起。） 在编译为动态链接库（DLL）时，可以通过宏定义决定该标记的函数是从DLL中导出还是从其他DLL中导入，非DLL的情况下，表示该符号标记的函数是外部的（extern） 12345678910111213141516171819202122232425262728293031/* luaconf.h *//*@@ LUA_API is a mark for all core API functions.@@ LUALIB_API is a mark for all auxiliary library functions.@@ LUAMOD_API is a mark for all standard library opening functions.** CHANGE them if you need to define those functions in some special way.** For instance, if you want to create one Windows DLL with the core and** the libraries, you may want to use the following definition (define** LUA_BUILD_AS_DLL to get it).*/#if defined(LUA_BUILD_AS_DLL) /* &#123; */ // 编译为动态链接库#if defined(LUA_CORE) || defined(LUA_LIB) /* &#123; */#define LUA_API __declspec(dllexport) // 从DLL中导出#else /* &#125;&#123; */#define LUA_API __declspec(dllimport) // 从其他DLL中导入#endif /* &#125; */#else /* &#125;&#123; */#define LUA_API extern // 非DLL的情况，等效于extern#endif /* &#125; *//*** More often than not the libs go together with the core.*/#define LUALIB_API LUA_API#define LUAMOD_API LUA_API 2、从 lua_State *L = lua_newstate(l_alloc, NULL); 得到的信息？ lua_newstate是核心库提供的函数，提供给外部创建一个虚拟机的接口，也就是说 luaL_newstate 本质上就是对 lua_newstate 做了一次封装，提供了一个更加方便和常用的版本。lua_newstate在本文后面会单独作一次分析，这里不赘述。 此外，lua_newstate 要求传入一个内存管理函数，这里使用的内部定义好的 l_alloc 函数，同样下文具体分析，先跳过。 3、l_likely 是何含义？ 跳到定义： 1234567891011121314151617181920212223242526/* luaconf.h *//*** macros to improve jump prediction, used mostly for error handling** and debug facilities. (Some macros in the Lua API use these macros.** Define LUA_NOBUILTIN if you do not want &#x27;__builtin_expect&#x27; in your** code.)*/#if !defined(luai_likely)#if defined(__GNUC__) &amp;&amp; !defined(LUA_NOBUILTIN)#define luai_likely(x) (__builtin_expect(((x) != 0), 1))#define luai_unlikely(x) (__builtin_expect(((x) != 0), 0))#else#define luai_likely(x) (x)#define luai_unlikely(x) (x)#endif#endif#if defined(LUA_CORE) || defined(LUA_LIB)/* shorter names for Lua&#x27;s own use */#define l_likely(x) luai_likely(x)#define l_unlikely(x) luai_unlikely(x)#endif 在编译时，l_likely 代表该条件分支的结果大概率为真，l_unlikely 代表大概率为假，类似于断言，但又不一样，这俩的本质是 __builtin_expect, 代表了一种逻辑期望。 使用它们的目的是帮助编译器进行分支预测优化，从而提高程序的执行效率。通过告知编译器哪些分支更可能被执行，或者哪些分支较少被执行，编译器可以更有效地安排指令的执行，减少因错误预测而导致的性能损失。 4、lua_atpanic 和 lua_setwarnf lua_atpanic 对新的虚拟机注册一个函数，在 Lua 遇到致命错误时（如内存分配失败或其他无法恢复的错误）调用这个函数 lua_setwarnf 对新的虚拟机注册一个警告函数，当 Lua 执行时产生警告时，这个回调函数就会被调用。 内置的内存管理函数（l_alloc） 先来看函数签名： 123// lua.htypedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize); ud：指 userdata，代表一些lua无法定义的外部结构或者类型 ptr：指向当前要更改的内存起始地址的指针 osize：指 old size，当前指针指向的内存块的原始大小 nsize：指 new size，当前指针指向的内存块的新大小 相比C标准库中的内存分配函数，Lua的内存管理函数会额外给出osize（内存块的原始大小），这对定制一个高效的自定义内存管理函数来说非常重要，可以帮助我们更加精准地设计和节省内存。（C标准库的内存分配函数仅包含一个内存地址指针和需要分配的大小，要做到精准定制，一般需要在内存块的前面加了一个cookie ，把内存块尺寸存放在里面） ud是一个额外的指针，允许我们带入额外的处理逻辑。比如让内存管理模块工作在不同的堆上。恰当的定制内存管理器，就可以回避线程安全问题。不考虑线程安全的因素，我们可以让内存管理工作更为高效。 从Lua5.2开始，当 ptr 传入 NULL 时，osize的含义是对象的类型，这样做让我们知道当前是在分配一个什么类型的对象，便于统计和优化 然后我们再来看看内置的内存管理函数： 1234567891011// lauxlib.cstatic void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) &#123; (void)ud; (void)osize; /* not used */ if (nsize == 0) &#123; free(ptr); // C标准库的内存释放函数 return NULL; &#125; else return realloc(ptr, nsize); // C标准库的内存分配函数&#125; 这个函数的逻辑比较简单，当nsize指定为0时，释放当前指针指向的内存。否则，分配一个nsize大小的内存块 Lua内存管理 Lua使用了一组宏来管理不同类别的内存：单个对象、数组、可变长数组等。这组宏定义在 lmem.h 中。 这组宏的核心是一个内部API：luaM_realloc_ 它的实现本质是调用 global_State 中注册的内存分配器（也就是我们之前了解的l_alloc或者我们自己定义的内存管理函数），我们在创建一个新的虚拟机时，传入的内存管理函数其实就是注册给了全局状态机 原文对这里的说明：这些工作不仅仅是分配新的内存，释放不用的内存，扩展不够用的内存。Lua也会通过 realloc 试图释放掉预申请过大的内存的后半部分，当然，这取决于用户提供的内存管理器能不能缩小内存块了 还有一个需要注意的细节， luaM_realloc_ 并不能直接调用，Lua在这里围绕它定义了很多宏，应对不同类型和调用场景。这其实是一种优化思路，因为很多调用的传入参数都是常数，直接用宏定义，可以让常量计算在编译时就完成，节省运行时的计算和开销。（Lua有很多这样精致的设计思路，这也是它的源码被盛赞的原因之一） 以下是它的具体代码： 1234567891011121314151617/*** Generic allocation routine.*/void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) &#123; void *newblock; global_State *g = G(L); lua_assert((osize == 0) == (block == NULL)); newblock = firsttry(g, block, osize, nsize); if (l_unlikely(newblock == NULL &amp;&amp; nsize &gt; 0)) &#123; newblock = tryagain(L, block, osize, nsize); if (newblock == NULL) /* still no memory? */ return NULL; /* do not update &#x27;GCdebt&#x27; */ &#125; lua_assert((nsize == 0) == (newblock == NULL)); g-&gt;GCdebt = (g-&gt;GCdebt + nsize) - osize; return newblock;&#125; 整个代码逻辑可以分为三个部分： 第一部分是利用全局状态机分配一块新的内存 newblock，这里要细看firsttry的定义： 123// lmem.c#define firsttry(g,block,os,ns) ((*g-&gt;frealloc)(g-&gt;ud, block, os, ns)) firsttry其实就是调用全局状态机frealloc指针指向的方法，这个就是创建虚拟机时传入的内存管理函数 第二部分是出现可能性很小的分配失败的情况，这里执行了 tryagain，实现如下： 123456789101112131415161718// lmem.c/*** In case of allocation fail, this function will do an emergency** collection to free some memory and then try the allocation again.** The GC should not be called while state is not fully built, as the** collector is not yet fully initialized. Also, it should not be called** when &#x27;gcstopem&#x27; is true, because then the interpreter is in the** middle of a collection step.*/static void *tryagain (lua_State *L, void *block, size_t osize, size_t nsize) &#123; global_State *g = G(L); if (completestate(g) &amp;&amp; !g-&gt;gcstopem) &#123; luaC_fullgc(L, 1); /* try to free some memory... */ return (*g-&gt;frealloc)(g-&gt;ud, block, osize, nsize); /* try again */ &#125; else return NULL; /* cannot free any memory without a full state */&#125; 注释的解释： 如果分配失败，此函数将执行紧急收集以释放一些内存，然后再次尝试分配。 在虚拟机未完全构建时不应调用 GC，因为收集器尚未完全初始化。此外，当“gcstopem”为真时不应调用它，因为解释器正处于收集步骤的中间。 总结就是在GC收集器完成时，会进行一次 Full GC，尝试释放掉一些内存，并再次分配 第三部分是将新分配的大小更新到 GCdebt，这用于内部感知内存大小，在内存不够时会主动尝试GC操作 原书中还提到了 luaM_growaux_，这个API用于管理可变长数组，其策略是当数组空间不够时，扩大为原来的2倍。 1234567891011121314151617181920212223242526272829303132// lmem.c/*** Minimum size for arrays during parsing, to avoid overhead of** reallocating to size 1, then 2, and then 4. All these arrays** will be reallocated to exact sizes or erased when parsing ends.*/#define MINSIZEARRAY 4void *luaM_growaux_ (lua_State *L, void *block, int nelems, int *psize, int size_elems, int limit, const char *what) &#123; void *newblock; int size = *psize; if (nelems + 1 &lt;= size) /* does one extra element still fit? */ return block; /* nothing to be done */ if (size &gt;= limit / 2) &#123; /* cannot double it? */ if (l_unlikely(size &gt;= limit)) /* cannot grow even a little? */ luaG_runerror(L, &quot;too many %s (limit is %d)&quot;, what, limit); size = limit; /* still have at least one free place */ &#125; else &#123; size *= 2; if (size &lt; MINSIZEARRAY) size = MINSIZEARRAY; /* minimum size */ &#125; lua_assert(nelems + 1 &lt;= size &amp;&amp; size &lt;= limit); /* &#x27;limit&#x27; ensures that multiplication will not overflow */ newblock = luaM_saferealloc_(L, block, cast_sizet(*psize) * size_elems, cast_sizet(size) * size_elems); *psize = size; /* update only when everything else is OK */ return newblock;&#125; 全局状态机 1、全局状态机作用？创建虚拟机时如何被引用？ 对于Lua使用者而言，global_State 即全局状态机，是不可见的，我们也不需要引用它，但是仍然需要了解它。 全局状态机的作用： 有对主线程（创建新的虚拟机时分配的 lua_State）的引用 有注册表管理所有全局数据，有全局字符串表 内存管理函数 GC需要的信息 一切工作内存 通过 lua_newstate 创建一个新的Lua虚拟机时，会申请一块内存存放一个LG类型的结构，其中保存了主线程和全局状态机，代码和示意图如下： 123456789101112131415161718// lstate.c/*** thread state + extra space*/typedef struct LX &#123; lu_byte extra_[LUA_EXTRASPACE]; lua_State l;&#125; LX;/*** Main thread combines a thread state and the global state*/typedef struct LG &#123; LX l; global_State g;&#125; LG; 释义： LG：包含主线程 lua_State 和全局状态机 global_State 的结构体，取首字母组成了“LG” LX：对主线程的一次封装，只是额外多了一块预定义大小的内存块。 extra_：据源码注释解释，这个称为主线程的原始内存大小，访问速度非常快，如果需要不同大小，可以自行更改，但没有给出明确的使用，估计是可以根据用户需要去自定义用途。 lua_State：主线程 global_State：全局状态机 2、原文中提到的内存布局的细节 这里，主线程必须定义在结构的前面，否则关闭虚拟机的时候（如下代码）就无法正确的释放内存。 1(*g-&gt;frealloc)(g-&gt;ud, fromstate(L), sizeof(LG), 0); /* free main block */ 这里其实就是搞懂fromstate到底做了啥 123// lstate.c#define fromstate(L) (cast(LX *, cast(lu_byte *, (L)) - offsetof(LX, l))) 释义： cast(lu_byte *, (L))：将 L 从 lua_State * 类型转换为 lu_byte * 类型的指针。也就是转为字节级指针，方便进行字节偏移 offsetof(LX, l)：这部分的意思是取 l 这个字段在 LX 这个结构体中的偏移量 第一步中的主线程的字节指针减去自身在 LX 结构体中的偏移量，实际就是取存储自身的 LX 的内存地址 最后将类型转换为 LX *，得到一个指向 LX 结构体的指针，即得到主线程外包装的 LX 回过头，原文所描述的内存布局顺序，确实会影响内存的释放。因为要从LG的内存起始位置释放，也就是LX定义在前才不会出错 3、初步阅读 Lua_newstate 的内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// lstate.cLUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) &#123; int i; lua_State *L; global_State *g; LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG))); if (l == NULL) return NULL; L = &amp;l-&gt;l.l; g = &amp;l-&gt;g; L-&gt;tt = LUA_VTHREAD; g-&gt;currentwhite = bitmask(WHITE0BIT); L-&gt;marked = luaC_white(g); preinit_thread(L, g); g-&gt;allgc = obj2gco(L); /* by now, only object is the main thread */ L-&gt;next = NULL; incnny(L); /* main thread is always non yieldable */ g-&gt;frealloc = f; g-&gt;ud = ud; g-&gt;warnf = NULL; g-&gt;ud_warn = NULL; g-&gt;mainthread = L; g-&gt;seed = luai_makeseed(L); g-&gt;gcstp = GCSTPGC; /* no GC while building state */ g-&gt;strt.size = g-&gt;strt.nuse = 0; g-&gt;strt.hash = NULL; setnilvalue(&amp;g-&gt;l_registry); g-&gt;panic = NULL; g-&gt;gcstate = GCSpause; g-&gt;gckind = KGC_INC; g-&gt;gcstopem = 0; g-&gt;gcemergency = 0; g-&gt;finobj = g-&gt;tobefnz = g-&gt;fixedgc = NULL; g-&gt;firstold1 = g-&gt;survival = g-&gt;old1 = g-&gt;reallyold = NULL; g-&gt;finobjsur = g-&gt;finobjold1 = g-&gt;finobjrold = NULL; g-&gt;sweepgc = NULL; g-&gt;gray = g-&gt;grayagain = NULL; g-&gt;weak = g-&gt;ephemeron = g-&gt;allweak = NULL; g-&gt;twups = NULL; g-&gt;totalbytes = sizeof(LG); g-&gt;GCdebt = 0; g-&gt;lastatomic = 0; setivalue(&amp;g-&gt;nilvalue, 0); /* to signal that state is not yet built */ setgcparam(g-&gt;gcpause, LUAI_GCPAUSE); setgcparam(g-&gt;gcstepmul, LUAI_GCMUL); g-&gt;gcstepsize = LUAI_GCSTEPSIZE; setgcparam(g-&gt;genmajormul, LUAI_GENMAJORMUL); g-&gt;genminormul = LUAI_GENMINORMUL; for (i=0; i &lt; LUA_NUMTAGS; i++) g-&gt;mt[i] = NULL; if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) &#123; /* memory allocation error: free partial state */ close_state(L); L = NULL; &#125; return L;&#125;/*** open parts of the state that may cause memory-allocation errors.*/static void f_luaopen (lua_State *L, void *ud) &#123; global_State *g = G(L); UNUSED(ud); stack_init(L, L); /* init stack */ //初始化主线程的数据栈 init_registry(L, g); //初始化注册表 luaS_init(L); //初始化字符串池 luaT_init(L); //初始化元表用的字符串 luaX_init(L); //初始化词法分析用的token串 g-&gt;gcstp = 0; /* allow gc */ setnilvalue(&amp;g-&gt;nilvalue); /* now state is complete */ luai_userstateopen(L);&#125; 这里我使用的Lua5.4.4版本作为参考，和原文中的有些不一致，但总体实现大差不差 函数实现中包含了诸如GC、字符串、内存管理等等相关的逻辑，在之后的章节会仔细分析。 这里我们着重看下最后一个条件分支的逻辑：如果Lua调用 f_luaopen 检查我们虚拟机的主线程，如果未通过检查，则会释放掉它。另外一个点是，虚拟机初始化的过程分两步：第一步是 f_luaopen 之前的逻辑，这一堆逻辑没有额外分配内存。真正会引起内存分配的初始化逻辑其实在 f_luaopen 中。第二步则是执行 f_luaopen 来初始化虚拟机 结合以上两点，其实可以看出Lua对创建虚拟机的处理非常小心。内存管理函数可能是外部传入的，也就有可能引起错误的内存分配。这里的思路是先初始化不需要额外内存分配的部分，把异常处理机制先建立起来。然后去调用可能引起内存分配失败的初始化代码，这里的容错机制设计是很精妙的。","tags":[{"name":"Lua","slug":"Lua","permalink":"https://peiyuzou.github.io/tags/Lua/"}],"categories":[{"name":"02-编程语言","slug":"02-编程语言","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"02-编程语言/Lua","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"源码阅读","slug":"02-编程语言/Lua/源码阅读","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"02-全局状态机及内存","slug":"02-编程语言/Lua/源码阅读/02-全局状态机及内存","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/02-%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E6%9C%BA%E5%8F%8A%E5%86%85%E5%AD%98/"}]},{"title":"1.1 概览","date":"2024-12-05T09:02:48.000Z","path":"wiki/02-编程语言/Lua/源码阅读/01-概览/1.1-概览/","text":"参考：云风的《Lua源码欣赏》 他在书中将源码分为四个部分： 核心 代码翻译及预编译字节码 内嵌库 独立解析器及字节码编译器 并提供了一个建议阅读顺序（来自LuaJIT的作者Mike Pall）： 阅读外围的库是如何实现功能扩展的 阅读 API 的具体实现 了解 Lua VM 的实现 分别理解函数调用、返回，string 、table 、metatable 等如何实现 debug 模块 parser 等等编译相关的部分 垃圾收集 与原文中的5.2版本不同，本文是基于Lua5.4.4版本，结合了个人理解写成，仅供参考","tags":[{"name":"Lua","slug":"Lua","permalink":"https://peiyuzou.github.io/tags/Lua/"}],"categories":[{"name":"02-编程语言","slug":"02-编程语言","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"02-编程语言/Lua","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"源码阅读","slug":"02-编程语言/Lua/源码阅读","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"01-概览","slug":"02-编程语言/Lua/源码阅读/01-概览","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/01-%E6%A6%82%E8%A7%88/"}]},{"title":"01.总览","date":"2024-08-06T11:33:10.000Z","path":"wiki/03-开发设计/游戏编程设计模式/01.总览/","text":"这个章节的绝大部分内容来自对Robert Nystrom的《Game Programming Patterns》一书的个人提炼。 和原书一致，将全部内容分为三个部分： 第一个部分是对设计模式的客观评价、它并不是百利无害的。在游戏领域中，它对架构、性能会造成多种影响，这些影响有正面的也有负面的 第二个部分是对GoF合著的《设计模式：可复用面向对象软件要素》一书的经典设计模式的解读 第三个部分被分为四类，共十三种有用的设计模式（对游戏开发而言至少是有用） 序列模式 行为模式 解耦模式 优化模式 GoF：四人组的英文简写，《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为四人组（Gang of Four）。","tags":[{"name":"游戏编程设计模式","slug":"游戏编程设计模式","permalink":"https://peiyuzou.github.io/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"03-开发设计","slug":"03-开发设计","permalink":"https://peiyuzou.github.io/categories/03-%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/"},{"name":"游戏编程设计模式","slug":"03-开发设计/游戏编程设计模式","permalink":"https://peiyuzou.github.io/categories/03-%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"List源码浅析","date":"2024-04-13T01:06:41.000Z","path":"wiki/02-编程语言/CSharp/List源码浅析/","text":"基础知识虽然枯燥但十分重要，反复打磨基础才能有新的启发。 List作为C#最常用的容器，有必要对它深入了解，最直接的就是读源码。下面是它的源码网址： https://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs 本篇是记录个人对它的一些常用方法源码的理解剖析 继承、构造、基础成员字段 1234567891011121314151617181920212223242526272829303132public class List&lt;T&gt; : IList&lt;T&gt;, System.Collections.IList, IReadOnlyList&lt;T&gt;&#123; private const int _defaultCapacity = 4; private T[] _items; private int _size; private int _version; static readonly T[] _emptyArray = new T[0]; // Constructs a List. The list is initially empty and has a capacity // of zero. Upon adding the first element to the list the capacity is // increased to 16, and then increased in multiples of two as required. public List() &#123; _items = _emptyArray; &#125; // Constructs a List with a given initial capacity. The list is // initially empty, but will have room for the given number of elements // before any reallocations are required. // public List(int capacity) &#123; if (capacity &lt; 0) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum); Contract.EndContractBlock(); if (capacity == 0) _items = _emptyArray; else _items = new T[capacity]; &#125;&#125; 继承接口 继承IList，提供主要接口： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#if CONTRACTS_FULL [ContractClass(typeof(IListContract&lt;&gt;))]#endif // CONTRACTS_FULL public interface IList&lt;T&gt; : ICollection&lt;T&gt; &#123; // The Item property provides methods to read and edit entries in the List. T this[int index] &#123; get; set; &#125; // Returns the index of a particular item, if it is in the list. // Returns -1 if the item isn&#x27;t in the list. int IndexOf(T item); // Inserts value into the list at position index. // index must be non-negative and less than or equal to the // number of elements in the list. If index equals the number // of items in the list, then value is appended to the end. void Insert(int index, T item); // Removes the item at position index. void RemoveAt(int index); &#125;#if CONTRACTS_FULL [ContractClassFor(typeof(IList&lt;&gt;))] internal abstract class IListContract&lt;T&gt; : IList&lt;T&gt; &#123; T IList&lt;T&gt;.this[int index] &#123; get &#123; //Contract.Requires(index &gt;= 0); //Contract.Requires(index &lt; ((ICollection&lt;T&gt;)this).Count); return default(T); &#125; set &#123; //Contract.Requires(index &gt;= 0); //Contract.Requires(index &lt; ((ICollection&lt;T&gt;)this).Count); &#125; &#125; IEnumerator System.Collections.IEnumerable.GetEnumerator() &#123; return default(IEnumerator); &#125; IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator() &#123; return default(IEnumerator&lt;T&gt;); &#125; [Pure] int IList&lt;T&gt;.IndexOf(T value) &#123; Contract.Ensures(Contract.Result&lt;int&gt;() &gt;= -1); Contract.Ensures(Contract.Result&lt;int&gt;() &lt; ((ICollection&lt;T&gt;)this).Count); return default(int); &#125; void IList&lt;T&gt;.Insert(int index, T value) &#123; //Contract.Requires(index &gt;= 0); //Contract.Requires(index &lt;= ((ICollection&lt;T&gt;)this).Count); // For inserting immediately after the end. //Contract.Ensures(((ICollection&lt;T&gt;)this).Count == Contract.OldValue(((ICollection&lt;T&gt;)this).Count) + 1); // Not threadsafe &#125; void IList&lt;T&gt;.RemoveAt(int index) &#123; //Contract.Requires(index &gt;= 0); //Contract.Requires(index &lt; ((ICollection&lt;T&gt;)this).Count); //Contract.Ensures(((ICollection&lt;T&gt;)this).Count == Contract.OldValue(((ICollection&lt;T&gt;)this).Count) - 1); // Not threadsafe &#125; #region ICollection&lt;T&gt; Members void ICollection&lt;T&gt;.Add(T value) &#123; //Contract.Ensures(((ICollection&lt;T&gt;)this).Count == Contract.OldValue(((ICollection&lt;T&gt;)this).Count) + 1); // Not threadsafe &#125; bool ICollection&lt;T&gt;.IsReadOnly &#123; get &#123; return default(bool); &#125; &#125; int ICollection&lt;T&gt;.Count &#123; get &#123; return default(int); &#125; &#125; void ICollection&lt;T&gt;.Clear() &#123; // For fixed-sized collections like arrays, Clear will not change the Count property. // But we can&#x27;t express that in a contract because we have no IsFixedSize property on // our generic collection interfaces. &#125; bool ICollection&lt;T&gt;.Contains(T value) &#123; return default(bool); &#125; void ICollection&lt;T&gt;.CopyTo(T[] array, int startIndex) &#123; //Contract.Requires(array != null); //Contract.Requires(startIndex &gt;= 0); //Contract.Requires(startIndex + ((ICollection&lt;T&gt;)this).Count &lt;= array.Length); &#125; bool ICollection&lt;T&gt;.Remove(T value) &#123; // No information if removal fails. return default(bool); &#125; #endregion &#125;#endif // CONTRACTS_FULL 继承IReadOnlyList，则是提供泛型迭代器和Count属性等接口 1234567891011121314151617181920212223242526272829303132333435363738#if CONTRACTS_FULL [ContractClass(typeof(IReadOnlyListContract&lt;&gt;))]#endif // If we ever implement more interfaces on IReadOnlyList, we should also update RuntimeTypeCache.PopulateInterfaces() in rttype.cs public interface IReadOnlyList&lt;out T&gt; : IReadOnlyCollection&lt;T&gt; &#123; T this[int index] &#123; get; &#125; &#125;#if CONTRACTS_FULL [ContractClassFor(typeof(IReadOnlyList&lt;&gt;))] internal abstract class IReadOnlyListContract&lt;T&gt; : IReadOnlyList&lt;T&gt; &#123; T IReadOnlyList&lt;T&gt;.this[int index] &#123; get &#123; //Contract.Requires(index &gt;= 0); //Contract.Requires(index &lt; ((ICollection&lt;T&gt;)this).Count); return default(T); &#125; &#125; int IReadOnlyCollection&lt;T&gt;.Count &#123; get &#123; return default(int); &#125; &#125; IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator() &#123; return default(IEnumerator&lt;T&gt;); &#125; IEnumerator IEnumerable.GetEnumerator() &#123; return default(IEnumerator); &#125; &#125;#endif 构造函数 1234567891011121314151617181920// Constructs a List. The list is initially empty and has a capacity// of zero. Upon adding the first element to the list the capacity is// increased to 16, and then increased in multiples of two as required.public List() &#123; _items = _emptyArray;&#125;// Constructs a List with a given initial capacity. The list is// initially empty, but will have room for the given number of elements// before any reallocations are required.//public List(int capacity) &#123; if (capacity &lt; 0) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum); Contract.EndContractBlock(); if (capacity == 0) _items = _emptyArray; else _items = new T[capacity];&#125; 从构造函数得出，List内部也是由数组实现，并且支持在一开始就指定容量；无参构造函数的注释中，说明了数组一开始容量是0，一旦添加了一个元素，容量会增长至16，这个说法其实不对，真实是增长到4，也就是默认的容量（_defaultCapacity），后面关于Add的内容会看到算法和测试的结果；容量每次扩大都是上一次的两倍（也就是容量4再增长即是8，再扩容就是16，以此类推）。","tags":[{"name":"C#","slug":"C","permalink":"https://peiyuzou.github.io/tags/C/"}],"categories":[{"name":"02-编程语言","slug":"02-编程语言","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"CSharp","slug":"02-编程语言/CSharp","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/"}]},{"title":"组件使用","date":"2023-07-09T07:23:32.000Z","path":"wiki/05-游戏编程/Unity/粒子系统/0.1组件使用/","text":"一、主模块 Duration：不勾循环的情况下，粒子发射器的发射持续时间，单位秒 Looping：是否循环发射粒子 Prewarm：开启该选项的粒子系统在场景中实例化或者由Deactive转为active时，会立即执行一次完整的模拟。以“火焰”为例，Prewarm开启时，加载后第一帧即能看到“大火”，而不是从“火苗”开始逐渐变大 Start Delay：粒子发射器初始化发射的延迟时间，单位秒，如果勾选了Prewarm，则该选项失效 Start Lifetime：粒子本身的生命周期，单位秒，指一个粒子被发射后，经过多少时间消失 Start Speed：粒子开始时的初始速度 3D Start Size：勾选的话，则可以在xyz三个轴上调整粒子的尺寸，当然在布告板模式下，z轴的调节没有意义 Start Size：同步设置xyz轴的尺寸 3D Start Rotation：粒子可以绕着xyz三个设定不同的角度 Start Rotation：只设置ｚ轴方向旋转角度 Flip Rotation：反跳旋转，设置一个[0, 1]闭区间的值，假设Start Rotation值为10，0代表旋转值不变即10，1代表方向完全取反即-10。01中间的值代表权重，将以该权重从1010之间随机 Start Color：粒子初始颜色 Gravity Modifier：粒子施加一个向下的力，负值是向上的 Simulation Space：粒子的运动所使用的空间坐标 Local：使用自身粒子系统的游戏物体的坐标 World：使用世界坐标，就是场景坐标 Custom：使用另一个物体的坐标。当这个物体坐标变化时，粒子也会跟着变化的，比如物体的位移会带动粒子位移 Simulation Speed：整体改变粒子的运动快慢，注意不只是粒子的速度。而是粒子总体属性，在空间位置中的变化，整体放慢或加快 Delta Time：粒子系统推进的方式 Scaled：该粒子系统按照时间推进（不同刷新率的的设备有相同表现） Unscaled：完全按照帧来推进 Scaling Mode：缩放模式 Hierarchy：根据其Transform及其所有父级进行缩放 Local：仅粒子系统自身节点应用缩放，忽略任何父级 Shape：将缩放应用于粒子起始位置，但不影响粒子大小 Play on Awake：如果启用此属性，则粒子系统会在创建对象时自动启动 Emitter Velocity：选择粒子系统如何计算继承速度和发射模块使用的速度。系统可以使用 Rigidbody 组件（如果存在）或通过跟踪 Transform 组件的运动来计算速度。如果不存在 Rigidbody 组件，系统默认使用其 Transform 组件 Max Particles：系统中同时允许的最多粒子数。如果达到限制，则移除一些粒子 Auto Random Seed：如果启用此属性，则每次播放时粒子系统看起来都会不同。设置为 false 时，每次播放时系统都完全相同 Random Seed：禁用自动随机种子时，此值用于创建唯一的可重复效果 Stop Action：当属于系统的所有粒子都已完成时，可使系统执行某种操作。当一个系统的所有粒子都已死亡，并且系统存活时间已超过 Duration 设定的值时，判定该系统已停止。对于循环系统，只有在通过脚本停止系统时才会发生这种情况 None：什么都不做 Disable：禁用游戏对象 Destroy：销毁游戏对象。 Callback：将 OnParticleSystemStopped 回调发送给附加到游戏对象的任何脚本 Culling Mode：粒子在屏幕外时如何处理模拟 Automatic：自动，Looping使用Pause，而所有其他使用Always Simulate Pause And Catch-up：系统在屏幕外时停止模拟。当重新进入视图时，模拟会执行一大步以到达在不暂停的情况下可实现的程度。在复杂系统中，此选项可能会导致性能尖峰 Pause：系统在屏幕外时停止模拟 Always Simulate：无论是否在屏幕上，系统始终处理每个帧的模拟 Ring Buffer Mode：保持粒子存活直到它们达到 Max Particles 计数，此时新粒子会取代最早的粒子，而不是在它们的寿命终结时才删除粒子 Disabled：禁用 Ring Buffer Mode，以便系统在粒子生命周期终结时删除粒子 Pause Until Replaced：在粒子生命周期结束时暂停旧粒子，直至达到 Max Particle 限制，此时系统会进行粒子再循环，因此旧粒子会重新显示为新粒子 Loop Until Replaced：在粒子生命周期结束时，粒子将倒回到其生命周期的指定比例，直至达到 Max Particle 限制，此时系统会进行粒子再循环，因此旧粒子会重新显示为新粒子 二、Emission（发射器） Rate over Time（按时间频率发射）：每经过1秒发射的数量 Rate over Distance（按距离频率发射）：每移动1个单位距离发射的数量 Bursts（迸发）：从第几（Time）秒开始，发射多少个（Count），这次发射循环几次（Cycles），每次循环间隔多久（Interval） 三、Shape（发射器形状） Shape：发射器的基本形状，默认是Cone（锥体） Sphere：球体 Hemisphere：半球体 Cone：锥体 Donut：甜甜圈 Box：正方体 Mesh：网格 Mesh Renderer：网格渲染 Skinned Mesh Renderer：骨骼网格渲染（特效随骨骼运动发射时用这个） Sprite：精灵 Sprite Renderer：精灵渲染 Circle：圆形 Edge：一条线 Rectangle：矩形 这里以默认的Cone为例： Angle：锥体角度 Radius：锥体半径 Radius Thickness：锥体体积，0~1的值 Arc：锥体发射的弧度范围 Mode：锥体发射模式 Random：整个锥体区域随机发射 Loop：正俯视视角下，调整锥体体积变成一个圆环，这样的视角下比较明显。Loop模式是一个在锥体底部的圆上的一个点，按照顺时针方向旋转并且发射 Ping Pong：和Loop一样，不过在点触碰X正轴时回弹 Burst Spread（迸发散布）：这个要联合Emission（发射器）折叠菜单中的Bursts（迸发）选项来看，此选项定义了迸发的形状。可以把Rate Over Time指定为0，专心看迸发的形状 Spread：散布值（0~1的值）。这个值是指将有效发射区域按照分为多少份。比如Arc指定弧度范围为360度，如果想平均分成5份，那么此值填0.2，最终效果迸发将均匀分为5份发射出来 Emit from（发射来自）: Base：基础。只有一个底部发射粒子 Volume：体积。形成一个真正的圆锥体发射粒子 Length：在Emit from指定Volume时，指定锥体的高度 Texture：设置一张图片在发射器上，根据这图片的颜色和透明区域，可影响粒子的颜色和透明度 Clip Channel：选择纹理中用于丢弃粒子的通道，要配合Clip Threshold使用 Clip Threshold：将粒子映射到纹理上的位置时，丢弃像素颜色低于此阈值的所有粒子 Color affects Particles：粒子颜色受纹理颜色影响 Alpha affects Particles：粒子Alpha受纹理Alpha影响 Bilinear Filtering：在读取纹理时，进行双线性过滤插值（无论纹理尺寸如何，均组合4个相邻样本以获得更平滑的粒子颜色变化） 类似这个效果 Position、Rotation、Scale：类似发射器的Transform Align to Direction：让粒子朝向和发射方向对齐 Randomize Direction：粒子发射方向随机权重 Spherize Direction：将粒子方向朝球面方向混合 Randomize position：随机发射位置，这个值是一个允许的距离偏移 四、Velocity over Lifetime（生命周期内的速度） Linear：给粒子一个线性的速率向量 Space：速率向量作用的空间坐标系 Orbital（轨道）：可以使粒子绕着某个轴自行旋转 Offset（偏移）：在Orbital旋转的过程中在施加一个轴方向的速度 Radial（半径）：绕轴旋转形成的螺旋线半径 Speed Modifier：增加粒子整体运动速度 五、Limit Velocity over Lifetime（生命周期内限制速度） Speed（速度）：限制后的速度。时间轴是duration时间。 Dampen（抑制）：抑制的含义是在粒子生命期间的速度由初始速度改为当前设置的速度，值越小抑制的越晚。值越大抑制的越早。值0是整个粒子生命时间内没有抑制。1是整个时间内完全抑制。抑制速度不会大于初始速度 Drag：指定在粒子的整个生命周期内施加给粒子的反方向拉拽速度的数量 Multiply by Size：拉拽速度的大小根据粒子大小关联，粒子越大拉拽力越大 Multiply by velocity：拉拽速度的大小根据粒子速度关联，粒子速度越大拉拽力越大 Separate Axes：限制后的速度分别在xyz轴上定义 六、Inherit Velocity（继承速率） 继承速度的含义是粒子继承了粒子系统这个物体位移速度。前提是粒子使用的空间坐标是world才行 Mode（模式）：提供了两种initial（初始）current（当前的） Multiplier（乘值）：是速度要乘的数，速度是粒子系统在（世界）空间坐标中的速度， initial（初始）：计算粒子出生时的粒子系统速度。1就是原始速度，2，就是2倍速度。小数，速度会变慢。 current（当前的）：计算的是实时的粒子系统速度。粒子系统愈快，粒子的运行速度就越快。但值为1的时候，粒子移动速度和粒子系统速度一致，所以视觉上看不出粒子的位移，大于1或小于1时才有意义 七、Force over Lifetime（生命周期内受到的力） X、Y、Z：在三个轴上施加的力 Space：选择是在局部空间还是在世界空间中施力 Randomize：使用 Two Constants 或 Two Curves 模式时，此属性会导致在每个帧上在定义的范围内选择新的作用力方向。因此会产生更动荡、更不稳定的运动 八、Color over Lifetime（生命周期内使用的颜色值） 这个就是调整颜色的 九、Color by Speed（颜色受速度影响） Speed Range（速度范围）：设定受到颜色影响最小速度和最大速度 十、Size Over Lifetime（生命周期内的大小） Size：曲线指定粒子大小的变化 十一、Size by Speed（大小随速度变化） Speed Range：指定曲线x轴的开始和结束速度 十二、Rotation over Lifetime（生命周期内的旋转） 十三、Rotation by speed（旋转受到速度影响） 十四、External Forces（受外部力影响） Multiplier：受到的外力影响的倍率 十五、Noise（为粒子添加噪波影响） Strength：噪波影响强度 Frequency：影响频率 Scroll Speed：噪声图滚动的速度 Damping（减震）：当噪波强度和频率都很大时效果明显，可以将强度与频率匹配，从而达到一个较稳定的噪声表现 Octaves：噪波叠加的层数 Octaves multiplier（分层乘值）：就是和原始图的混合程度，0是没有混合，1是完全和原始图一致 Octaves scale（分层尺寸）：值1是和原始图一样大。值越越大细节越小 Quality（质量）：就是提供了1D的噪波、2D的噪波和3D选择的地方 Remap（重置图）：重新调节噪波图的黑白。类似于曲线的功能。可以从新定义粒子收到的影响 Position Amount：粒子受到的位移影响 rotation Amount：粒子受到的旋转影响 Size Amount：粒子受到的缩放影响 十六、collision（碰撞） Type（类型）：提供了两种plan和world类型。World主要针对场景中有collider组件的物体（包含terrain）会产生碰撞。Plan是指定一个的物体的transform，作为一个面产生碰撞 Planes（面）：指定物体的transform为面。这个物体可以是场景中的也可以是资源中的。主要是用他的变换值。一版是和场景中的物体互动是有意义的，如果只是想得到一个碰撞可以使用空物体，会剩一点 Visualization（形象）：有Grid（网格）和Solid（固体）两种。只是便于查看的显示方式 Scale Plane（缩放片）:就是缩放Visualization这个片，还是为了便于观察 Dampen（抑制力）：碰撞后，粒子的速度被抑制多少，1是抑制到速度为0，粒子会停留在片上，0是没有抑制 Bounce（弹力）：碰撞后弹起的情况。1跟初始速度一样的速度反弹。0是不反弹，粒子会朝平面方向运动 Lifetime Loss（生命损耗）：碰撞后，粒子生命所短的数量。1是缩短到最大。碰撞后粒子生命结束。0是没有损耗 Min Kill Speed（速度小于值消灭粒子）：碰撞后的粒子速度小于这个值被摧毁 Max Kill Speed（速度大于值消灭粒子）：碰撞后的粒子速度大于这个值被摧毁 Radius Scale（半径的尺寸）：其实粒子的碰撞是和场景中其他碰撞是一个原理的，每个粒子都有一个圆的碰撞组件。计算碰撞就是计算这个组件和其他物体的碰撞的。这里调节半径尺寸是调的每个粒子碰撞大小 Send Collision Messages（发送碰撞信息）：程序相关，程序会得到相关信息作出处理 Visualize Bounds（显示界限）：就是显示出碰撞框 十七、Triggers（触发） 设置了Inside（内部）Outside（外部）Enter（进入）Exit（出去）四种状态的Ignore（忽略）、kill（消灭）、callback（回调）三种情况。回调的含义是给程序返回一个内容。 Colliders（碰撞的物体）：应该是个模型才有意义。真正起作用的是物体上面的collider组件。 Radius Scale（半径的尺寸）和Visualize Bounds（显示界限）碰撞功能一样 十八、Sub Emitters（子发射器） 指定什么时候触发一个子粒子系统，这个子粒子系统会继承哪些属性，并且有多少概率触发 十九、Texture Sheet Animation（纹理片动画） 分为两种模式：Grid和Sprites Tiles（平铺数）：一张图标被切割的数量。x是横轴的数量，y是纵轴数量。 Animation（动画）：有两种形式， Whole Sheet（全部小片）：从左至右、从上至下播放整个图片里的小方框。 Single Row（单排）：只播一横排，因为可能会有很多排。当勾选了Random Row（随机行）时，随机选中一行播放。不够时，有一个Row值供手选使用哪一行。 Frame over Time（时间内的帧数）：通常设置曲线是有意义的，设置数值只会显示固定的一帧（并非是帧，而是第几个小图）。注意的是小图片的第一张的序号是0。 Start Frame（开始帧）：从第几帧开始播放，仍会完整读取序列。 Cycles（循环）：正常图片的整个循环是在粒子的生命时间内循环一次。这里可以改变循环几次 二十、Light（光照） Light（灯）：设置一盏灯，使粒子出生时同时有实时光照的效果，实质上就一个粒子一盏灯。 Ratio（比率）：产生的粒子会有多大比例有灯照，0是一个也没有，1是全部粒子都有。 Random Distribution（随机分布）：当Ratio不是1时，设置产生灯照的粒子的分布情况，随机就是随机分布，勾掉则会根据粒子情况每隔多少秒出现一个灯照。 Use Particle Color（使用粒子颜色）：灯照颜色使用粒子的颜色。 Size Affect Range（尺寸作用与范围）：粒子的尺寸会影响灯照的范围。 Alpha Affect Intensity（透明度作用于亮度）：粒子的透明度会影响灯照的亮度，调整粒子的生命颜色时就可以实现控制灯照的亮度了。 Range multiplier（范围乘值）：增大灯照的范围。 Intensity Multiplier（亮度乘值）：增大灯照的亮度。 Maximum Lights（最大灯数）：因为是实时光照。灯的数量可能会根据粒子数量产生非常多，消耗会非常巨大。这里的值控制最多可以有多少个灯照被创建 二十一、Trails（拖尾） Particle（粒子）：使用这个模式使粒子产生一个拖尾。 Ratio（比例）：粒子会产生拖尾的比例。1是全部粒子都会有拖尾。 Lifetime（生命）：拖尾的生命值。就是拖尾开始消失的时间。1是和粒子生命一样长。注意的是，默认Die with particle勾上时，粒子消失后拖尾也会消失，这个消失跟拖尾的Lifetime没有关系，只是被摧毁了。拖尾的生命时间就是开始消失的时间。 Minimum Vertex Distance(最小顶点距离)：mesh的两个顶点的距离。也就是细节程度，值越小，效果越好。实质上是产生一次mesh的时间。当然时间越小整个生命里产生的网格越多了。早先版本trail的产生是按每多少帧产生mesh的数量算的，所以会造成一旦卡了，trail就完全没法看了，这里是按时间算的，不用担心掉帧了。 World Space（世界空间）：勾上时，这个拖尾会受到空间位移的影响。不勾是，只会相对于自身粒子系统进行拖尾。 Die with particle（跟随粒子消亡）：勾上时，粒子消失后，拖尾一起消失。 Texture Mode(图片模式)： Stretch(拉伸):在整个mesh上拉伸整张图的U Tile（平铺）：U不会被拉伸，超出部分是重复平铺 Distribute Per Segment（每段都分配）：和Stretch效果差不多，但计算的切入点不一样，Stretch是先计算出trail的长度，在拉伸图片。这个是先计算又多少个网格，每个网格上应该分配多少图片的信息。理论上应该更精细 Repeat Per Segment（每段重复）：每一个网格上分配一个图片 Size affects width（尺寸影响宽度）：勾上时，默认宽度和粒子大小一致。而且宽度也随粒子大小变化了。 Size affects lifetime（尺寸影响寿命）：勾上时，生命时间（也就是开始消失的时间）会受到尺寸的影响。 当粒子变的巨大和很小时，智能的缩减拖尾时间很有必要。 Inherit particle color（继承粒子颜色）：勾上时，拖尾颜色会受到粒子颜色的影响。 Color over lifetime（生命期内颜色）：拖尾生命时间内的颜色情况，是时间层面的，使用Gradient模式可以设置随时间变化颜色，开始是什么色，后面是什么色。跟粒子生命时间内颜色类似。 Color over trail（拖尾颜色的情况）：拖尾自身的颜色变化情况。是空间层面。使用Gradient模式可以设前段是什么色，后段是什么色。注意和Color over lifetime区别。 Width over trail（拖尾的宽度情况）：重要调节，来真正影响拖尾的宽度的值。曲线模式下可调节拖尾的前后宽度，横轴是整体长度，竖轴是宽度。 Generate Lighting Data（生成光照信息）：让trail可以收到光照 Ribbon（丝带）：让产生的粒子链接起来。目前来说功能很匮乏，效果很尴尬。 Ribbon count（丝带数量）：就是使用几条丝带来将所有粒子链接起来。1就是只有一条。当丝带数大于场景中的粒子数时，就不在会产生粒子。多说下粒子系的事情，每个粒子系统的粒子都是有序号的，假设一个序号为1的粒子2秒后消失，内存上说但他并不是真的消失了，它会从新回到发射器原点，模拟一个新的粒子出生，拥有新的生命和速度大小等。而这里的丝带链接目标是和序号有紧密关系的（坑深不挖）。所以当你看到条带数是粒子数的一半时，是两两链接的。 Split Sub Emitter Ribbons（分离子发射器的丝带）：就是如果当期粒子系统是一个子发射器。让每个粒子产生的新的发射器和其他产生的发射器不关联 二十二、Renderer（渲染器） Normal Direction（法线方向）：改变粒子片的法线方向。当粒子受到光照时（关键是shader要支持），将一个片模拟成一个受光照的体积 Material（材质）：粒子的材质。图片通过shader生成一个材质。 Trail Material（拖尾材质）：拖尾材质。 Sort Mode（排序模式）：给粒子排列先后顺序，它是针对粒子系统自身发出的粒子进行排序。而且粒子材质球是可排序的才有意义。就是材质要是透明材质才行。 None（无）：不排序，混乱的。 By Distance（依据距离）：根据粒子距离摄像机的远近排序。比较常用。 Oldest in Front（最早在前）：谁先出生排列在前，后出生排列早后。平面上可能有用。 Youngest in Front（最新的在前）：谁后出生排列在前、后出生排列在后。 Sorting Fudge（排序欺骗）：作者的意思大概是说这是一个欺骗性的排序，它让粒子假装往前或者往后移动的多少距离。负值是原理镜头、正值是靠近镜头，靠近镜头的肯定会在前面。当然材质球也必须是可排序的材质球才行。例如相加、相乘、透明混合等。 Min particle Size（最小粒子尺寸）：简单说小于这个值的粒子都会被放大到这个值这么大。这个值是屏幕大小，值1就是一个平面那么大。做屏幕特效时有用，不必去把粒子设的很大，用这个就能准确设定大小 Max particle Size（最大粒子尺寸）：这个值同样只屏幕大小。当粒子显示大于这个值时，会被缩小。避免细小的粒子冲向摄像机时变的巨大。 Render Alignment（显示队列）：指定粒子朝向方向，也就是z轴朝向。 View（视野）：粒子片z轴朝向你观察的方向。 World（时间）：粒子片z轴朝向世界的z轴。 Local（自身）：粒子片z轴朝向粒子系统自身的z轴。这时就可以旋转它了，就是真实粒子片的状态。 Facing（面朝）：粒子片z轴朝向摄像机位置。和view效果很像，但是却不并不一样。这里朝向时，会去掉透视关系，只是拿z这个面朝向你。Mesh状态下能看的更清楚。 Velocity（速率）：粒子片z轴朝向自身运动的方向 Pivot（中心点）：设置了三个方向可以调节中心点。在Stretched Billboard会有大用 Visualize pivot（可视化中心点）：使粒子的中心点显示出来。粒子真正的运行位置，调节pivot时有用 Masking（遮挡）：是关于sprite遮挡的功能。简而言之，sprite有个组件可以把图片做成一个遮照放到场景中。处理超出这个遮照范围外就会消失，或者只在范围外显示。通常用于平面类型特效上面 No Masking（无遮挡）：不会有遮挡 Visible Inside Mask（遮照内部可见）：只在Sprite Mask内部显示粒子。超出不显示 Visible Outside Mask（遮照外部可见）：只在Sprite Mask外部显示粒子。内部不显示 Custom Vertex Streams（自定义顶点流）：程序相关，脚本调用。主要处理顶点色。 Cast Shadows（投射阴影）：可以投射阴影。但材质必须是不透明类型的。Off（关）On（开）Two Sided（双面）shadows Only（只有阴影。-） Receive Shadow（接收阴影）：公共版模式下意义不大因为是一个片接收到阴影并不舒服，建议mesh模型下使用。 Motion Vectors（移动向量）：和摄像机的运动向量有关。不太明白意义是什么。可以确定的是和特效制作没关系了。 Sorting Layer（排序层）：设置一个层处理前后关系，越早创建的层越靠后，越新创建的层越靠前。 Order in Layer（层中排序）：在这里可以在同一个Sorting Layer层里设置前后关系。值越大越靠前。 要注意这两个功能和Sorting Fudge是有区别的。Sorting Fudge是假设他在场景中的位置，负值是离镜头较远、正值是离镜头较近。近的肯定是会覆盖掉远的，从而调节先后关系。而这里是真正更改渲染顺序的。在unity中整个排序是这样的，先计算shader上面的顺序，然后是Sorting layer的前后，然后是Order in layer大小，最后才是Sorting Fudge的影响。 Light Probes（光照探针）： Reflection Probes（反射探针）： 这两项和其拓展出的功能都和灯光探测有关，坑深不挖。特效制作基本不用","tags":[{"name":"Unity","slug":"Unity","permalink":"https://peiyuzou.github.io/tags/Unity/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"粒子系统","slug":"05-游戏编程/Unity/粒子系统","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/"}]},{"title":"浮点数运算问题","date":"2023-03-11T12:10:10.000Z","path":"wiki/99-问题记录/浮点数运算问题/","text":"一、问题 最近工作中遇到一个C#单精度浮点数丢精度的问题，直接上发生问题的代码： 第一种写法发生了严重的精度丢失，但其实不是全部的数都会发生这个问题，所以平时开发时并没有发现。要理解造成这个现象的原因，需要从浮点数的运算和存储的基础知识出发去追溯。 二、运算 首先，我们看下这段代码的IL，搞清楚CPU处理这段逻辑大概做了什么操作： 第一种写法，vectorX和scale加载到寄存器后，执行的第一个操作是conv.r4，也就是将int32类型的scale转换为了float。然后再执行乘法，紧接着将结果强转int64，最后输出。从IL看没有什么问题，下面我们按照IL的步骤手动运算一下。 1、得到两个变量在机器中的真实值 整个问题运算的核心是1.3f和10.0f这两个单精度浮点数运算： 十进制数1.3转换为二进制数为\\(1.01001100110011..._{(2)}\\) 由浮点数存储规则：V = \\((-1)^S\\) x M x \\(2^E\\) 符号位S，因为是正数，所以为0 阶数E = $log_2$1 = 0，float的偏置量bias是\\(2^k\\) - 1 = \\(2^8 - 1\\) = 127，所以exponent = E + bias = 127，得到8位阶码01111111 fraction直接等于二进制小数位，由于float的尾数位有23个，所以保留前23，得到尾数二进制01001100110011001100110 拼起来就是如下： 00111111 10100110 01100110 01100110 我们再从这个值推算阶数E和fraction（这里需要注意：这个二进制值不是由E和fraction计算得到的吗，什么又要推算回去？答：因为在计算实际的存储中，fraction由于只有23位，可能发生截断，如果截断后最低位是1，那么还会发生进位舍入，导致机器存储的实际值和数学意义上的值不一致） E = \\(2^6\\) + \\(2^5\\) + \\(2^4\\) + \\(2^3\\) + \\(2^2\\) + \\(2^1\\) - 127 = 0 fraction = 0.01001100110011001100110 M = 1 + fraction = 1.01001100110011001100110 = 1.0100110011001100110011（最低位的0对于数学计算来说没有用，可以忽略） 所以1.3可以表示为：\\((-1)^S\\) x M x \\(2^E\\) = \\(2^0\\) x \\(1.0100110011001100110011_{(2)}\\) 同理，10.0表示为：\\(2^3\\) x \\(1.01_{(2)}\\) 2、二进制乘法 由上面得到的机器值结果： 1.3 x 10.0 = \\(2^0\\) x \\(1.0100110011001100110011_{(2)}\\) x \\(2^3\\) x \\(1.01_{(2)}\\) = \\(2^3\\) x \\(1.0100110011001100110011_{(2)}\\) x \\(1.01_{(2)}\\) \\(1.0100110011001100110011_{(2)}\\) x \\(1.01_{(2)}\\)的二进制乘法结果如下： 取小数点后23位10011111111111111111111 所以最终，ALU计算得到的值是\\(2^3\\) x \\(1.10011111111111111111111_{(2)}\\) 三、存储 ALU已经得到了值\\(2^3\\) x \\(1.10011111111111111111111_{(2)}\\) E = 3，所以exponent = 3 + 127 = 130，阶码为1000001 0 整个结果表示为： 01000001 01001111 11111111 11111111 在现代CPU架构中，乘法和除法乘法和除法运算是使用两个累加器（主累加器 EAX 与从累加器 EDX）进行临时存储（例如，MUL ECX 将把两个 32 位寄存器 ECX 与 EAX 相乘，64 位结果放入 EAX 与 EDX） 所以，累加器中的二进制值如下： EAX： 01000001 01001111 11111111 11111111 EDX： 00000000 00000000 00000000 00000000 这里存储的实际值是12.99999904632568359375 接下来的处理是关键的地方，这个值被不同类型的变量去存，会有不同的二进制表现： 1、存储在float中 EAX中的32位值会被加载给栈上float变量的32位，这里由于最低位是1，会发生进位舍入，所以float变量的存储是： ### 01000001 01010000 00000000 00000000 这个值是最终程序用到的值：\\(2^3\\) x (1 + \\(2^{-1}\\) + \\(2^{-3}\\)) = 8 * 1.625 = 13 这也是为什么第二种写法得到正确结果的原因，12.99999904632568359375先存入float变量，发生了进位舍入变为了13，再强转long时，小数截断完仍然是13 2、存储在int或者long中 浮点数转整型，会直接发生小数截断，也就是直接舍弃所有小数点后的值，12.99999904632568359375直接截断为12，这也是第一种写法发生精度丢失的原因 3、存储在double中 由于double和float的阶码位和尾数位不一样，所以8位的阶码会重新计算成11位阶码，然后23位fraction会存储在52位fraction中，不足的低位用0布满，所以double变量的存储是这样： ### 01000000 00101001 11111111 11111111 ### 11111100 00000000 00000000 00000000 这个值是：12.99999988079071044921875 所以理论上，如果我们在强转long之前不是用float去存而是用double存，也会被截断为12，我们验证下： 需要注意的是，第一种写法和第三种写法导致精度丢失的原因并不一样。第一种是因为累加器的值直接截断了；第三种是因为double存储，没有发生进位，同时也被截断了。 四、总结 个人认为，其实从浮点数的设计来看，精度丢失无法避免。如果程序对精度有要求，最好是通过整型存储一个放大的值来处理。 如果无法使用整型来处理，尽量选择float，虽然也无法完全准确地表述一个真实值，但是对于强转整型发生时来说，float的表现更好，因为进位舍入能一定程度上中和掉小数截断导致的严重精度丢失，double存储位太多了，通常更容易形成一个我们不期望的近似值。 最后，如果精度要求过高，float无法完成任务，这时还是选择使用double","tags":[{"name":"Issues","slug":"Issues","permalink":"https://peiyuzou.github.io/tags/Issues/"}],"categories":[{"name":"99-问题记录","slug":"99-问题记录","permalink":"https://peiyuzou.github.io/categories/99-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"（八）踩坑和可视化调试工具","date":"2023-02-05T06:36:59.000Z","path":"wiki/05-游戏编程/Unity/UI/UIElements/（八）踩坑和可视化调试工具/","text":"记录一下调研过程中遇到的坑和解决方案，顺便提一嘴可视化调试工具 在摸索UXML附加到C#根节点的时候，有这么一段代码： 1234// Import UXMLvar visualTree = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(&quot;Assets/Editor/PresetWindow/PresetWindow.uxml&quot;);VisualElement labelFromUXML = visualTree.CloneTree();root.Add(labelFromUXML); 这样确实能成功将UXML定义的树结构添加到root下，但是当我使用flex-grow对子元素填充全屏时，发现无论如何都没有生效。 更离谱的是，打印root的layout信息，root的高度和宽度都是正常的。但是全屏元素打印layout，高宽永远都是0和0 最后利用可视化调试工具Window——Analysis——UIElements Debuger发现了端倪： 这里夹了一层TemplateContainer，这其实由于写法导致的，上面代码中我们得到的labelFromUXML对象会默认形成这一个节点，如果要正确地附加UXML的内容给root，需要这样写： 123// Import UXMLvar visualTree = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(&quot;Assets/Editor/Tutorials/01VisualTree/VisualTreeWindow.uxml&quot;);visualTree.CloneTree(root); 这样TemplateContainer就消失了：","tags":[{"name":"UIElements","slug":"UIElements","permalink":"https://peiyuzou.github.io/tags/UIElements/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"UI","slug":"05-游戏编程/Unity/UI","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/"},{"name":"UIElements","slug":"05-游戏编程/Unity/UI/UIElements","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/UIElements/"}]},{"title":"（七）技术拆解——绑定","date":"2023-02-05T06:30:21.000Z","path":"wiki/05-游戏编程/Unity/UI/UIElements/（七）技术拆解——绑定/","text":"绑定是指属性和对属性进行修改的可视化控件之间建立链接，也就是将对象属性同步到可见的UI 理论上任何序列化的对象都可以和继承IBindable的VisualElement之间进行绑定 示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253using UnityEditor;using UnityEngine;using UnityEditor.UIElements;using UnityEngine.UIElements;namespace UIElementsExamples&#123; public class SimpleBindingExample : EditorWindow &#123; TextField m_ObjectNameBinding; [MenuItem(&quot;Window/UIElements/SimpleBindingExample&quot;)] public static void ShowDefaultWindow() &#123; var wnd = GetWindow&lt;SimpleBindingExample&gt;(); wnd.titleContent = new GUIContent(&quot;Simple Binding&quot;); &#125; public void OnEnable() &#123; var root = this.rootVisualElement; m_ObjectNameBinding = new TextField(&quot;Object Name Binding&quot;); m_ObjectNameBinding.bindingPath = &quot;m_Name&quot;; root.Add(m_ObjectNameBinding); OnSelectionChange(); &#125; public void OnSelectionChange() &#123; GameObject selectedObject = Selection.activeObject as GameObject; if (selectedObject != null) &#123; // 创建序列化对象 SerializedObject so = new SerializedObject(selectedObject); // 将其绑定到层级视图的根目录。它将找到要绑定的正确对象... rootVisualElement.Bind(so); // ... 或者，也可以将其绑定到 TextField 本身。 // m_ObjectNameBinding.Bind(so); &#125; else &#123; // 取消对象与实际视觉元素的绑定 rootVisualElement.Unbind(); // m_ObjectNameBinding.Unbind(); // 删除绑定后，清除 TextField m_ObjectNameBinding.value = &quot;&quot;; &#125; &#125; &#125;&#125;","tags":[{"name":"UIElements","slug":"UIElements","permalink":"https://peiyuzou.github.io/tags/UIElements/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"UI","slug":"05-游戏编程/Unity/UI","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/"},{"name":"UIElements","slug":"05-游戏编程/Unity/UI/UIElements","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/UIElements/"}]},{"title":"（六）技术拆解——事件系统","date":"2023-02-05T05:25:06.000Z","path":"wiki/05-游戏编程/Unity/UI/UIElements/（六）技术拆解——事件系统/","text":"一、事件传播路径和事件目标 UIElements事件系统的传播路径如下图所示： 路径从视觉元素树的根部开始，并朝着目标下降。此阶段称为涓滴 (trickle-down) 阶段。 目标元素接收事件。此阶段称为目标阶段。 然后事件沿着树上升到根。此阶段称为冒泡 (bubble-up) 阶段 。 事件目标可以通过事件对象获取，有以下两种： IEventHandler.target：不管哪个元素接收到事件，都是目标元素对象 IEventHandler.currentTarget：会随着事件传播路径，更新为当前正在处理该事件的视觉元素 二、事件的监听 事件监听的注册的写法如下： 12345678910111213// 通用格式// T 派生自 UnityEngine.UIElements.EventBasemyElement.RegisterCallback&lt;T&gt;(Callback);// 注册鼠标移动事件回调（监听默认在目标阶段和冒泡阶段执行）myElement.RegisterCallback&lt;MouseMoveEvent&gt;(OnMouseMove);// 注册鼠标移动事件回调（为涓滴阶段注册回调，这样会优先于子元素响应）myElement.RegisterCallback&lt;MouseMoveEvent&gt;(OnMouseMove, TrickleDown.TrickleDown);// 注册鼠标按下事件myElement.RegisterCallback&lt;MouseDownEvent&gt;(OnMouseDown);// 回调签名void OnMouseDown(MouseDownEvent evt) &#123; /* ...*/ &#125; 三、验证传播路径和目标 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172using UnityEditor;using UnityEngine;using UnityEngine.UIElements;using UnityEditor.UIElements;public class EventDispatch : EditorWindow&#123; [MenuItem(&quot;Window/UIElements/EventDispatch&quot;)] public static void ShowExample() &#123; EventDispatch wnd = GetWindow&lt;EventDispatch&gt;(); wnd.titleContent = new GUIContent(&quot;EventDispatch&quot;); &#125; public void CreateGUI() &#123; // Each editor window contains a root VisualElement object VisualElement root = rootVisualElement; // Import UXML var visualTree = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(&quot;Assets/Editor/Tutorials/05EventDispatch/EventDispatch.uxml&quot;); visualTree.CloneTree(root); // The style will be applied to the VisualElement and all of its children. var styleSheet = AssetDatabase.LoadAssetAtPath&lt;StyleSheet&gt;(&quot;Assets/Editor/Tutorials/05EventDispatch/EventDispatch.uss&quot;); root.styleSheets.Add(styleSheet); var container = root.Q&lt;VisualElement&gt;(&quot;Container&quot;); var leftPanel = root.Q&lt;VisualElement&gt;(&quot;LeftPanel&quot;); var rightPanel = root.Q&lt;VisualElement&gt;(&quot;RightPanel&quot;); var rightTopPanel = root.Q&lt;VisualElement&gt;(&quot;RightTopPanel&quot;); var rightBottomPanel = root.Q&lt;VisualElement&gt;(&quot;RightBottomPanel&quot;); container.RegisterCallback&lt;MouseDownEvent&gt;(OnContainerMouseDown); leftPanel.RegisterCallback&lt;MouseDownEvent&gt;(OnLeftPanelMouseDown); rightPanel.RegisterCallback&lt;MouseDownEvent&gt;(OnRightPanelMouseDown, TrickleDown.TrickleDown); rightTopPanel.RegisterCallback&lt;MouseDownEvent&gt;(OnRightTopPanelMouseDown); rightBottomPanel.RegisterCallback&lt;MouseDownEvent&gt;(OnRightBottomPanelMouseDown); &#125; private void OnContainerMouseDown(MouseDownEvent evt) &#123; VisualElement target = (VisualElement) evt.target; VisualElement currentTarget = (VisualElement) evt.currentTarget; Debug.LogError($&quot;Recv By Container! Target:&#123;target.name&#125; CurrentTarget:&#123;currentTarget.name&#125;&quot;); &#125; private void OnLeftPanelMouseDown(MouseDownEvent evt) &#123; VisualElement target = (VisualElement) evt.target; VisualElement currentTarget = (VisualElement) evt.currentTarget; Debug.LogError($&quot;Recv By LeftPanel! Target:&#123;target.name&#125; CurrentTarget:&#123;currentTarget.name&#125;&quot;); &#125; private void OnRightPanelMouseDown(MouseDownEvent evt) &#123; VisualElement target = (VisualElement) evt.target; VisualElement currentTarget = (VisualElement) evt.currentTarget; Debug.LogError($&quot;Recv By RightPanel! Target:&#123;target.name&#125; CurrentTarget:&#123;currentTarget.name&#125;&quot;); &#125; private void OnRightTopPanelMouseDown(MouseDownEvent evt) &#123; VisualElement target = (VisualElement) evt.target; VisualElement currentTarget = (VisualElement) evt.currentTarget; Debug.LogError($&quot;Recv By RightTopPanel! Target:&#123;target.name&#125; CurrentTarget:&#123;currentTarget.name&#125;&quot;); &#125; private void OnRightBottomPanelMouseDown(MouseDownEvent evt) &#123; VisualElement target = (VisualElement) evt.target; VisualElement currentTarget = (VisualElement) evt.currentTarget; Debug.LogError($&quot;Recv By RightBottomPanel! Target:&#123;target.name&#125; CurrentTarget:&#123;currentTarget.name&#125;&quot;); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445#Container &#123; background-color: #333333; display: flex; flex-direction: row; width: auto; color: rgb(51, 51, 51); flex-grow: 1;&#125;#RightPanel&#123; position: relative; flex: 1; width: auto; border-width: 2px; border-color: rgba(21, 132, 67,1);&#125;#LeftPanel&#123; display: flex; -unity-text-align: middle-center; flex: 1; width: auto; border-width: 2px; border-color: rgba(21, 132, 67,1);&#125;#RightTopPanel&#123; border-width: 1px; border-color: rgba(21, 132, 67,1); -unity-text-align: middle-center; display: flex; flex: 1;&#125;#RightBottomPanel&#123; border-width: 1px; border-color: rgba(21, 132, 67,1); -unity-text-align: middle-center; display: flex; flex: 1;&#125; 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;engine:UXML xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:engine=&quot;UnityEngine.UIElements&quot; xmlns:editor=&quot;UnityEditor.UIElements&quot; xsi:noNamespaceSchemaLocation=&quot;../../../../UIElementsSchema/UIElements.xsd&quot;&gt; &lt;engine:VisualElement name=&quot;Container&quot;&gt; &lt;engine:VisualElement name=&quot;LeftPanel&quot;&gt; &lt;/engine:VisualElement&gt; &lt;engine:VisualElement name=&quot;RightPanel&quot;&gt; &lt;engine:VisualElement name=&quot;RightTopPanel&quot;&gt; &lt;/engine:VisualElement&gt; &lt;engine:VisualElement name=&quot;RightBottomPanel&quot;&gt; &lt;/engine:VisualElement&gt; &lt;/engine:VisualElement&gt; &lt;/engine:VisualElement&gt;&lt;/engine:UXML&gt; 默认执行顺序： 涓滴执行优先于子元素： 四、为事件监听的回调透传自定义参数 1234//将用户数据一起发送到回调myElement.RegisterCallback&lt;MouseDownEvent, MyType&gt;(MyCallbackWithData, myData);void MyCallbackWithData(MouseDownEvent evt, MyType data) &#123; /* ...*/ &#125; 五、官方提供的事件类型 https://docs.unity3d.com/cn/2019.4/Manual/UIE-Events-Reference.html 内容太多了，这里举例鼠标捕获事件作为参考 捕获事件 鼠标捕获是指一个元素强制独占鼠标事件的下一次事件发送并响应。 例如：如果您在文本框中单击，则该文本框会捕获鼠标。鼠标仍然可以在屏幕上移动，但不会触发文本框外的事件。只要文本框捕获了您的鼠标，它就不会触发其他事件。当用户在文本框外按下鼠标上的按钮时，该框会释放其鼠标捕获。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using UnityEditor;using UnityEngine;using UnityEngine.UIElements;using UnityEditor.UIElements;public class CaptureEventTestWindow : EditorWindow&#123; [MenuItem(&quot;Window/UIElements/CaptureEventTestWindow&quot;)] public static void ShowExample() &#123; CaptureEventTestWindow wnd = GetWindow&lt;CaptureEventTestWindow&gt;(); wnd.titleContent = new GUIContent(&quot;CaptureEventTestWindow&quot;); &#125; private bool m_IsCapturing = false; public void CreateGUI() &#123; // 添加一些可点击的标签，在点击时将消息打印到控制台 for (int i = 0; i &lt; 4; i++) &#123; Label clickableLabel = new Label($&quot;Label &#123;i&#125; - Click Me!&quot;); clickableLabel.RegisterCallback&lt;MouseDownEvent&gt;((evt) =&gt; &#123; Debug.Log($&quot;Clicked on label &#x27;&#123;(evt.target as Label).text&#125;&#x27;&quot;); &#125;); rootVisualElement.Add(clickableLabel); &#125; // 现在添加一个捕获指针的标签 Label capturingLabel = new Label(&quot;Click here to capture mouse&quot;); capturingLabel.RegisterCallback&lt;MouseDownEvent&gt;((evt) =&gt; &#123; if (!m_IsCapturing) &#123; capturingLabel.text = &quot;Click here to release mouse&quot;; MouseCaptureController.CaptureMouse(capturingLabel); m_IsCapturing = true; &#125; else &#123; capturingLabel.text = &quot;Click here to capture mouse&quot;; MouseCaptureController.ReleaseMouse(capturingLabel); m_IsCapturing = false; &#125; &#125;); rootVisualElement.Add(capturingLabel); // 注册回调以在鼠标被捕获或释放时打印消息 rootVisualElement.RegisterCallback&lt;MouseCaptureEvent&gt;((evt) =&gt; &#123; Debug.Log(&quot;Mouse captured&quot;); &#125;); rootVisualElement.RegisterCallback&lt;MouseCaptureOutEvent&gt;((evt) =&gt; &#123; Debug.Log(&quot;Mouse captured released&quot;); &#125;); &#125;&#125;","tags":[{"name":"UIElements","slug":"UIElements","permalink":"https://peiyuzou.github.io/tags/UIElements/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"UI","slug":"05-游戏编程/Unity/UI","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/"},{"name":"UIElements","slug":"05-游戏编程/Unity/UI/UIElements","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/UIElements/"}]},{"title":"（五）技术拆解——USS","date":"2023-02-05T01:24:53.000Z","path":"wiki/05-游戏编程/Unity/UI/UIElements/（五）技术拆解——USS/","text":"USS的语法以及使用规则同CSS大同小异，熟悉CSS的开发者可以迅速上手编写 一、将USS附加到VisualElement USS主要作用就是附加到视觉元素上，从而达到美化界面的效果，如上图所示。使用下面的代码，可以将USS附加给某个VisualElement，生效的范围是该VisualElement以及它的所有子节点。 123// The style will be applied to the VisualElement and all of its children.var styleSheet = AssetDatabase.LoadAssetAtPath&lt;StyleSheet&gt;(&quot;Assets/Editor/Tutorials/04UseUss/UseUss.uss&quot;);root.styleSheets.Add(styleSheet); 二、USS的选择器 CSS的语法和原理基于选择器，USS同理，并且USS的选择器语法和CSS几乎一致。 选择器将根据规则匹配作用范围内的所有标签，对应的标签会添加上USS定义的样式。 接下来我们枚举出所有的USS选择器，假设我们UXML如下： 123&lt;engine:Label class=&quot;classA&quot; name=&quot;One&quot;/&gt;&lt;engine:Label class=&quot;classA&quot; name=&quot;Two&quot;/&gt;&lt;engine:Label class=&quot;classB&quot; name=&quot;Three&quot;/&gt; 1. 类型选择器 123TypeName &#123; ... &#125;Label &#123; ... &#125; TypeName指定C#定义好的类型，比如Label、Button等内置的类型或者我们自己扩展的类型，注意不能使用命名空间（类名重复问题不应该放在USS层面解决，要在C#层面或者UXML层面解决好） 2. 名称选择器 123#name &#123; ... &#125;#One &#123; ... &#125; 名称选择器会匹配指定name属性值的标签 3. 类名选择器 123.class &#123; ... &#125;.classA &#123; ... &#125; 类名选择器会匹配指定class属性值的标签，上面的例子中会匹配到Two和Three 4. 通配符 1* &#123; ... &#125; USS也支持通配符，上面这样声明则是匹配所有标签 5. 伪状态 1:pseudo-state &#123; ... &#125; 伪状态在某些状态下触发，触发时会被USS匹配并加入样式，以下是USS支持的伪状态以及它们的触发时机： hover：光标悬停在视觉元素上。 active：正在与视觉元素交互。 inactive：不再与视觉元素交互。 focus：视觉元素具有焦点。 disabled：视觉元素设置为 enabled == false。 enabled：视觉元素设置为 enabled == true。 checked：视觉元素是一个 Toggle 元素并已选中。 root：树中的最高层级视觉元素时触发。 6. 复杂选择器 选择器之间可以互相组合，形成复杂的选择器，例如： 1Label#Two.ClassA:hover &#123; ... &#125; 该选择器将在name为Two，class为ClassA的Label被光标悬停时应用样式 7. 选择器优先级 优先级从高到低： C#中直接设置的样式 通配符* 类型选择器（Type） 类名选择器（Class） 名称选择器（Name） 三、USS属性 直接观看文档：https://docs.unity3d.com/cn/2019.4/Manual/UIE-USS-SupportedProperties.html 四、BEM BEM是一种规范化类名选择器的语法规则，一般web前端开发大多都遵循它来使系统更加明朗。 举例： 12345&lt;VisualElement class=&quot;menu&quot;&gt; &lt;Label class=&quot;menu__item&quot; text=&quot;Banana&quot; /&gt; &lt;Label class=&quot;menu__item&quot; text=&quot;Apple&quot; /&gt; &lt;Label class=&quot;menu__item menu__item--disabled&quot; text=&quot;Orange&quot; /&gt;&lt;/VisualElement&gt; 对于选择器来说，语法规则不变： 12345678.menu &#123;&#125;.menu__item &#123;&#125;.menu__item--disabled &#123;&#125;","tags":[{"name":"UIElements","slug":"UIElements","permalink":"https://peiyuzou.github.io/tags/UIElements/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"UI","slug":"05-游戏编程/Unity/UI","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/"},{"name":"UIElements","slug":"05-游戏编程/Unity/UI/UIElements","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/UIElements/"}]},{"title":"（四）技术拆解——UXML","date":"2023-02-04T20:15:13.000Z","path":"wiki/05-游戏编程/Unity/UI/UIElements/（四）技术拆解——UXML/","text":"一、UXML基本概念 UXML类似于HTML和XAML、XML的结合版，它用于定义UI的逻辑结构。UXML语法上和前三者非常类似。 二、UXML文件的结构 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;UXML xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;UnityEngine.UIElements&quot; xmlns:editor=&quot;UnityEditor.UIElements&quot; xsi:noNamespaceSchemaLocation=&quot;../UIElementsSchema/UIElements.xsd&quot; xsi:schemaLocation=&quot;UnityEngine.UIElements ../UIElementsSchema/UnityEngine.UIElements.xsd&quot;&gt; &lt;Label text=&quot;Select something to remove from your suitcase:&quot;/&gt; &lt;Box&gt; &lt;Toggle name=&quot;boots&quot; label=&quot;Boots&quot; value=&quot;false&quot; /&gt; &lt;Toggle name=&quot;helmet&quot; label=&quot;Helmet&quot; value=&quot;false&quot; /&gt; &lt;Toggle name=&quot;cloak&quot; label=&quot;Cloak of invisibility&quot; value=&quot;false&quot;/&gt; &lt;/Box&gt; &lt;Box&gt; &lt;Button name=&quot;cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;Button name=&quot;ok&quot; text=&quot;OK&quot; /&gt; &lt;/Box&gt;&lt;/UXML&gt; 1. XML声明 第1行，指定文档使用的版本和编码 2. 根标签 第2-8行以及19行，声明该文档引用的命名空间和架构文件： 2.1 xmlns属性 全称XML NameSpace，用于引入命名空间并进行别名，比如第5行： 1xmlns:editor=&quot;UnityEditor.UIElements&quot; 这一行引入”UnityEditor.UIElements”命名空间并别名为editor，这样声明之后，整个文件中，都可以用editor代替并使用”UnityEditor.UIElements”命名空间 再看第4行： 1xmlns=&quot;UnityEngine.UIElements&quot; 这样不带别名进行引入，则是声明默认命名空间，也就是可以不用带前缀直接使用该命名空间中定义的标签。如果上面文件中去掉第4行，那么所有标签都应该加上”UnityEngine.UIElements”命名空间作为前缀，比如： 12345&lt;UnityEngine.UIElements:UXML/&gt;&lt;UnityEngine.UIElements:Label/&gt;&lt;UnityEngine.UIElements:Box/&gt;&lt;UnityEngine.UIElements:Toggle/&gt;&lt;UnityEngine.UIElements:Button/&gt; 2.2 xsd文件 全称XML Schema Definition，用于预先定义XML文档使用的架构，也就是标签和规则的一个集合。 下面是定义和使用xsd的部分（对应上文的第3、6、7行）： 1234xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:noNamespaceSchemaLocation=&quot;../UIElementsSchema/UIElements.xsd&quot;xsi:schemaLocation=&quot;UnityEngine.UIElements ../UIElementsSchema/UnityEngine.UIElements.xsd&quot; xmlns:xsi引入了XML公共架构的命名空间，并别名为xsi，这几乎是所有XML规范的共识写法。 其中noNamespaceSchemaLocation属性指定了没有任何命名空间的情况下，默认使用的架构文件。schemaLocation则是显示声明使用的架构文件 3. 正文 上文第9-18行内容，这块位置就按照XML规范编写文档内容即可，在UXML中，这里用于编写整个视觉树的结构代码 三、UXML文件的基本使用 1. 标签基本结构 1&lt;namspace:tag trait1=&quot;xx&quot; trait2=&quot;xx&quot; ... /&gt; 2. 从C#加载UXML 123456789// Load UXMLvar visualTree = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(&quot;Assets/Editor/Tutorials/01VisualTree/VisualTreeWindow.uxml&quot;);// First Way Link to Visula TreevisualTree.CloneTree(root);//Second Way Link to Visula TreeVisualElement labelFromUXML = visualTree.CloneTree();root.Add(labelFromUXML); 3. 向UXML添加样式 3.1 引入uss文件 12345&lt;engine:UXML ...&gt; &lt;engine:VisualElement class=&quot;root&quot;&gt; &lt;Style src=&quot;styles.uss&quot; /&gt; &lt;/engine:VisualElement&gt;&lt;/engine:UXML&gt; 12345# root &#123; width: 200px; height: 200px; background-color: red;&#125; 3.2 内联声明style 123&lt;engine:UXML ...&gt; &lt;engine:VisualElement style=&quot;width: 200px; height: 200px; background-color: red;&quot; /&gt;&lt;/engine:UXML&gt; 4. 引用其他UXML文件 比如我们首先有一个可供复用的UXML文件如下： 1234567&lt;engine:UXML ...&gt; &lt;engine:VisualElement class=&quot;portrait&quot;&gt; &lt;engine:Image name=&quot;portaitImage&quot; style=&quot;--unity-image: url(\\&quot;a.png\\&quot;)&quot;/&gt; &lt;engine:Label name=&quot;nameLabel&quot; text=&quot;Name&quot;/&gt; &lt;engine:Label name=&quot;levelLabel&quot; text=&quot;42&quot;/&gt; &lt;/engine:VisualElement&gt;&lt;/engine:UXML&gt; 可以将 Portrait 组件嵌入到其他 UXML 模板中，如下所示： 1234567&lt;engine:UXML ...&gt; &lt;engine:Template src=&quot;/Assets/Portrait.uxml&quot; name=&quot;Portrait&quot;/&gt; &lt;engine:VisualElement name=&quot;players&quot;&gt; &lt;engine:Instance template=&quot;Portrait&quot; name=&quot;player1&quot;/&gt; &lt;engine:Instance template=&quot;Portrait&quot; name=&quot;player2&quot;/&gt; &lt;/engine:VisualElement&gt;&lt;/engine:UXML&gt; 5. src和path 在上文中，不管是引入uss文件的&lt;Style&gt;标签，还是引入其他UXML模板的&lt;Template&gt;标签，他们都可以通过属性src或者path去标注文件路径，但是两者有区别需要注意： 5.1 src src允许使用相对路径，且在文件丢失时会提供错误信息。src声明的路径需要包含文件扩展名 5.2 path path不允许使用相对路径，在导入时不提供错误报告；但是它允许使用Unity资源机制，接受位于Resources文件夹或Editor Default Resources文件夹中的文件： 如果文件位于Resources文件夹中，不得包含文件扩展名。例如，为位于 Assets/Resources/template.uxml 的文件编写 path=“template” 如果文件位于Editor Default Resources文件夹中，必须包含文件扩展名。例如，为位于 Assets/Editor Default Resources/template.uxml 的文件编写 path=“template.uxml” 6. C#查询UXML中声明的ViusalElement 使用以下语句进行查询： 123Button button = root.Query&lt;Button&gt;(&quot;btn&quot;);//或者直接简写QVisualElement ve = root.Q&lt;VisualElement&gt;(&quot;foo&quot;); 查询的前提是，UXML声明的结构已经连接到视觉树中 四、UXML的扩展 1. 添加一个自定义的标签 12345678910111213141516using UnityEngine.UIElements;public class CustomElement : VisualElement&#123; string m_status; public string Status &#123; get; set; &#125; //必须包含显示构造函数 public CustomElement() &#123; m_status = string.Empty; &#125; //为了读取UXML时，每一个标签实例化一个新对象，需要在类内部声明这个泛型工厂类 public new class UxmlFactory : UxmlFactory&lt;CustomElement&gt; &#123;&#125;&#125; 2. 为标签定义新的属性 假设我们要拓展Label标签，并且定义一个status属性，让Label显示的文本和status保持同步，如下文的UXML： 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;engine:UXML xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:engine=&quot;UnityEngine.UIElements&quot; xmlns:editor=&quot;UnityEditor.UIElements&quot; xsi:noNamespaceSchemaLocation=&quot;../../../../UIElementsSchema/UIElements.xsd&quot;&gt; &lt;CustomElement name=&quot;CustomArea&quot; status=&quot;扩展成功&quot;/&gt;&lt;/engine:UXML&gt; 这是C#拓展的脚本类： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System.Collections.Generic;using UnityEngine.UIElements;public class CustomElement : Label&#123; string m_status; public string Status &#123; get; set; &#125; //必须包含显示构造函数 public CustomElement() &#123; m_status = string.Empty; &#125; //为了读取UXML时，每一个标签实例化一个新对象，需要在类内部声明这个泛型工厂类 public new class UxmlFactory : UxmlFactory&lt;CustomElement, UxmlTraits&gt; &#123;&#125; //声明本标签使用的属性，声明在这里也是为了方便访问该标签类的私有成员 public new class UxmlTraits : VisualElement.UxmlTraits &#123; //声明属性在UXML文档中的名字 UxmlStringAttributeDescription m_Status = new UxmlStringAttributeDescription &#123; name = &quot;status&quot; &#125;; //返回一个空的IEnumerable，表示CustomElement这个标签的元素没有子元素 public override IEnumerable&lt;UxmlChildElementDescription&gt; uxmlChildElementsDescription &#123; get &#123; yield break; &#125; //如果要让该标签的元素接受任意类型的元素，可以这么写： // get // &#123; // yield return new UxmlChildElementDescription(typeof(VisualElement)); // &#125; &#125; //Init()从XML解析器读取属性包中状态属性的值 public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc) &#123; base.Init(ve, bag, cc); //使标签对象的值从UXML文件内容中读取 string value = m_Status.GetValueFromBag(bag, cc); var ce = (CustomElement) ve; ce.Status = value; ce.text = value; &#125; &#125;&#125; 3. 自定义标签名称 12345678public new class UxmlFactory : UxmlFactory&lt;CustomElement, UxmlTraits&gt;&#123; //通过覆写工厂类的该属性，可以使用自定义的标签名称 public override string uxmlQualifiedName &#123; get &#123; return &quot;ZPY.TAG&quot;; &#125; &#125;&#125; 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;engine:UXML xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:engine=&quot;UnityEngine.UIElements&quot; xmlns:editor=&quot;UnityEditor.UIElements&quot; xsi:noNamespaceSchemaLocation=&quot;../../../../UIElementsSchema/UIElements.xsd&quot;&gt; &lt;ZPY.TAG name=&quot;CustomArea&quot; status=&quot;扩展成功&quot;/&gt;&lt;/engine:UXML&gt;","tags":[{"name":"UIElements","slug":"UIElements","permalink":"https://peiyuzou.github.io/tags/UIElements/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"UI","slug":"05-游戏编程/Unity/UI","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/"},{"name":"UIElements","slug":"05-游戏编程/Unity/UI/UIElements","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/UIElements/"}]},{"title":"（三）技术拆解——布局引擎","date":"2023-02-04T18:21:02.000Z","path":"wiki/05-游戏编程/Unity/UI/UIElements/（三）技术拆解——布局引擎/","text":"Unity采用的布局引擎是开源引擎项目Yoga，它是一个高性能的实现flexbox布局的引擎 一、关于flexbox布局 全称Flexible Box布局模型，也叫弹性盒子布局模型。它是一种弹性一维布局。 为什么说是弹性？ 它能够使父元素在子元素的大小未知或动态变化情况下仍然能够分配好子元素之间的间隙。主要思想是使父元素能够调整子元素的宽度、高度、排列方式，从而更好的适应可用的布局空间。设定为flex布局的&gt; 元素能够放大或者收缩子元素使之尽可能填充可用空间。 为什么说是一维？ 因为一个flexbox一次只能处理一个维度上的元素布局，一行或者一列。 1. 基本概念 flexbox有三个基本的概念：容器、项目和轴 容器是指采用Flex布局的元素，项目则是容器的子元素。 对于容器来说，存在两个轴：水平轴（main axis，也叫主轴）和垂直轴（cross axis，也叫交叉轴），flexbox只能按照其中一个轴进行布局，所以说是一维布局。 这是关于基本概念的示意图： 2. 容器属性 一个元素要作为容器使用flex布局，首先需要css指定布局样式： 123.container &#123; display: flex | inline-flex;&#125; flex容器的属性有以下6个： - flex-direction - flex-wrap - flex-flow - justify-content - align-items - align-content 2.1 flex-direction 指定排列方式 123.container &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; （1）flex-direction: row：默认值，沿水平轴从左到右排列，起点在左沿 （2）flex-direction: row-reverse：沿水平轴从右到左排列，起点在右沿 （3）flex-direction: column：沿垂直轴从上到下排列，起点在上沿 （4）flex-direction: column-reverse：沿垂直轴从下到上排列，起点在下沿 2.2 flex-wrap 容器内元素是否可以换行 123.container &#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; （1）flex-wrap: nowrap：默认值，不换行。当主轴的长度是固定并且空间不足时，项目尺寸会随之进行调整，而不会换行。 （2）flex-wrap: wrap：换行，第一行在上面 （3）flex-wrap: wrap-reverse：换行，第一行在下面 2.3 flex-flow 是flex-direction和flex-wrap的简写，尽量不用 123.container &#123; flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;;&#125; 2.4 justify-content 元素在主轴的对齐方式，这里以水平轴为例（flex-direction: row） 123.container &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; （1）justify-content: flex-start：默认值，元素在主轴上左对齐（上对齐） （2）justify-content: flex-end：元素在主轴上右对齐（下对齐） （3）justify-content: center：元素在主轴上居中对齐 （4）justify-content: space-between：元素在主轴上两端对齐，元素之间间隔相等 （5）justify-content: space-around：每个项目两侧的间隔相等 2.5 align-items 元素在交叉轴上的对齐方式，这里以水平轴为例（flex-direction: row） 123.container &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; （1）align-item: flex-start：交叉轴的起点对齐（上面或左边）。设置容器高度为 100px，项目高度分别为 20px、40px、60px、80px、100px，效果如图所示： （2）align-item: flex-end：交叉轴的终点对齐（下面或右边）。设置容器高度为 100px，项目高度分别为 20px、40px、60px、80px、100px，效果如图所示： （3）align-item: center：交叉轴的中点对齐。设置容器高度为 100px，项目高度分别为 20px、40px、60px、80px、100px，效果如图所示： （4）align-item: stretch：默认值、如果元素未设置高度或设为auto，将占满整个容器的高度。假设容器高度设置为 100px，而项目没有设置高度，则项目的高度也为 100px： （5）align-item: baseline：以第一个元素的基线对齐 2.6 align-content 多根轴线对齐方式（多根轴线是指由于换行或者布局变化，出现了多个主轴），当只有一根主轴，该属性不生效。这里以水平轴且换行为例（flex-direction: row; flex-wrap: wrap;） 123.container &#123; align-content: stretch | flex-start | flex-end | center | space-between | space-around;&#125; （1）align-content: stretch：默认值，轴线占满整个交叉轴。这里我们先设置每个项目都是固定宽度，效果如下： 去掉每个项目的高度，它会占满整个交叉轴，效果如下： （2）align-content: flex-start：从交叉轴开始位置进行对齐 （3）align-content: flex-end：从交叉轴结尾位置进行对齐 （4）align-content: center：与交叉轴中点对齐 （5）align-content: space-between：与交叉轴两端对齐，轴线之前的间隔平均分布 （6）align-content: space-around：每根轴线两侧的间隔都相等 3. 项目属性 order flex-grow flex-shrink flex-basis flex align-self 3.1 order 定义项目的排列顺序。数值越小，排列越靠前，默认为0 123.item &#123; order: &lt;integer&gt;;&#125; 3.2 flex-grow 容器空间有剩余时，定义项目在剩余空间中的放大比例，默认为0，即如果存在剩余空间时也不放大；当多个项目都设置此值，那么它就代表占比权重 （1）如果所有项目的flex-grow属性都设置为1，那么它们会均分剩余的空间，如下图所示： （2）如果其中一个项目的flex-grow属性设置为2，其他均为1，那么它占据的剩余空间就是其他项目的两倍： 3.3 flex-shrink 容器空间不足时，定义项目在剩余空间中的缩小比例，默认为1，即如果空间不足，该项目将缩小。不能设置负值；当多个项目都设置此值，那么它就代表占比权重 （1）如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小，如下图所示： （2）如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小，如下图所示： 3.4 flex-basis 定义了在分配多余空间之前，项目占据的主轴空间，浏览器会根据这个属性来计算主轴是否有多余空间 123.item &#123; flex-basis: &lt;length&gt; | auto;&#125; （1）为auto时，根据项目的指定尺寸来设置大小 （2）指定为Length，这个值既可以是具体的长度或者像素，也可以是百分比 3.5 flex flex属性是flex-grow, flex-shrink和flex-basis的简写，后两个属性可选。容易写错，尽量不用 123.item&#123; flex: none | [ &lt;&#x27;flex-grow&#x27;&gt; &lt;&#x27;flex-shrink&#x27;&gt;? || &lt;&#x27;flex-basis&#x27;&gt; ]&#125; 3.6 align-self align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖父元素的align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 规则同父容器属性align-items，只是一个覆盖选项，下面是容器align-items属性为flex-start，容器中第三个项目的align-self属性为flex-end的效果： 二、Yoga Yoga引擎的flexbox布局规则绝大部分与CSS规则相同，不再赘述，下面是Yoga官方提供的一个布局预览系统： https://yogalayout.com/playground","tags":[{"name":"UIElements","slug":"UIElements","permalink":"https://peiyuzou.github.io/tags/UIElements/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"UI","slug":"05-游戏编程/Unity/UI","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/"},{"name":"UIElements","slug":"05-游戏编程/Unity/UI/UIElements","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/UIElements/"}]},{"title":"（二）技术拆解——VisualTree","date":"2023-02-04T01:10:57.000Z","path":"wiki/05-游戏编程/Unity/UI/UIElements/（二）技术拆解——VisualTree/","text":"一、VisualTree 仅仅只是一个概念，UIElements的显示单元是VisualElement，若干VisualElement组成整个UI窗口，由于是树状结构，所以称为视觉树 二、VisualElement 又称视觉元素，Unity提供了VisualElement类作为所有显示节点的基类，包含样式、布局数据、本地变换、事件处理程序等的属性，可以派生该类来定义一些控件，Unity内置了一些控件，比如Label等等。 1. 创建一个VisualElement VisualElement有两种创建方式： - 手动分配： 1VisualElement label = new Label(&quot;Create From C#&quot;); 从UXML模板文件加载： 12var visualTree = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(&quot;Assets/Editor/Tutorials/01VisualTree/VisualTreeWindow.uxml&quot;);VisualElement labelFromUXML = visualTree.CloneTree(); 2. VisualElement连接形成VisualTree 视觉树（一个视觉树也就是一个EditorWindow）都包含一个默认的根节点，称为panel（EditorWindow.rootVisualElement），根节点本身也是一个VisualElement。 通过调用VisualElement对象的Add函数，将一个VisualElement作为另一个VisualElement的子节点，由此形成树状结构。 例子： 1234567891011121314151617181920212223242526272829using UnityEditor;using UnityEngine;using UnityEngine.UIElements;using UnityEditor.UIElements;public class VisualTreeWindow : EditorWindow&#123; [MenuItem(&quot;Window/UIElements/VisualTreeWindow&quot;)] public static void ShowExample() &#123; VisualTreeWindow wnd = GetWindow&lt;VisualTreeWindow&gt;(); wnd.titleContent = new GUIContent(&quot;VisualTreeWindow&quot;); &#125; public void CreateGUI() &#123; // Each editor window contains a root VisualElement object VisualElement root = rootVisualElement; // Import UXML var visualTree = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(&quot;Assets/Editor/Tutorials/01VisualTree/VisualTreeWindow.uxml&quot;); visualTree.CloneTree(root); // Import USS var styleSheet = AssetDatabase.LoadAssetAtPath&lt;StyleSheet&gt;(&quot;Assets/Editor/Tutorials/01VisualTree/VisualTreeWindow.uss&quot;); root.styleSheets.Add(styleSheet); &#125;&#125; 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;engine:UXML xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:engine=&quot;UnityEngine.UIElements&quot; xmlns:editor=&quot;UnityEditor.UIElements&quot; xsi:noNamespaceSchemaLocation=&quot;../../../../UIElementsSchema/UIElements.xsd&quot;&gt; &lt;engine:VisualElement name=&quot;TopPanel&quot;&gt; &lt;/engine:VisualElement&gt; &lt;engine:VisualElement name=&quot;BottomPanel&quot;&gt; &lt;engine:VisualElement name=&quot;LeftPanel&quot;&gt; &lt;/engine:VisualElement&gt; &lt;engine:VisualElement name=&quot;RightPanel&quot;&gt; &lt;/engine:VisualElement&gt; &lt;/engine:VisualElement&gt;&lt;/engine:UXML&gt; 12345678910111213141516171819202122#TopPanel &#123; background-color: #F00; height: 50px;&#125;#BottomPanel &#123; background-color: #0F0; flex-grow: 1; flex-direction: row;&#125;#LeftPanel &#123; background-color: #00F; flex-grow: 1; margin: 10px;&#125;#RightPanel &#123; background-color: #FFFF00; flex-grow: 1; margin: 10px;&#125; 这段代码将形成下图所示的树状结构：","tags":[{"name":"UIElements","slug":"UIElements","permalink":"https://peiyuzou.github.io/tags/UIElements/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"UI","slug":"05-游戏编程/Unity/UI","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/"},{"name":"UIElements","slug":"05-游戏编程/Unity/UI/UIElements","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/UIElements/"}]},{"title":"（一）UIElements概述","date":"2023-02-03T22:21:38.000Z","path":"wiki/05-游戏编程/Unity/UI/UIElements/（一）UIElements概述/","text":"一、Unity的UI系统 目前官方提供了三套UI系统： - IMGUI - Unity UI（UGUI） - UIToolKit 1. IMGUI IMGUI通常称“即时模式GUI”，这是完全面向程序员使用的UI系统，显示界面的代码每帧执行一次来绘制显示元素（OnGUI函数），这种UI系统一般没有持久化的游戏对象，所以一般用于编辑器拓展和工具开发。 总结特征： - 每帧执行绘制 - 没有持久化数据 - 用于编辑器和工具层面 2. Unity UI UGUI是一组用于开发游戏和应用程序用户界面的工具。它是一个基于游戏对象的UI系统，使用组件和游戏视图来安排、定位和设置用户界面的样式。它不能用于编辑器层面的开发 总结特征： - 用于Runtime的游戏界面内容的开发 - 基于游戏对象和组件式开发，功能强大完善 3. UIToolKit UIToolKit的由来： - Unity 2018.3版本发布UIToolKit的前身UIElements，动机是解决IMGUI的性能问题和局限性 - 直到Unity2019.1版本实装并用于替代IMGUI作为编辑器开发的另一个手段 - 直到2020.x版本，官方将UIElements升级为UIToolKit，用于支持Runtime游戏内容的界面开发 - 未来发展方向上想同时取代IMGUI和UGUI，作为Unity未来版本唯一的UI系统，但是目前无法完全取代UGUI，仍然保留了UGUI和IMGUI 题外话（UIToolKit与IMGUI、UGUI的对比） https://docs.unity3d.com/2023.1/Documentation/Manual/UI-system-compare.html 二、UIElements整体使用概述 1. 创建流程 Project视图——右键create——UIElements——EditorWindow开始创建窗体： 需要注意的是，创建目录需要位于Editor文件夹下任意深度，创建完成后，生成三个同名文件：.cs、.uxml以及*.uss 123456789101112131415161718192021222324252627282930313233343536373839// FirstWindow.csusing UnityEditor;using UnityEngine;using UnityEngine.UIElements;using UnityEditor.UIElements;public class FirstWindow : EditorWindow&#123; [MenuItem(&quot;Window/UIElements/FirstWindow&quot;)] public static void ShowExample() &#123; FirstWindow wnd = GetWindow&lt;FirstWindow&gt;(); wnd.titleContent = new GUIContent(&quot;FirstWindow&quot;); &#125; public void CreateGUI() &#123; // Each editor window contains a root VisualElement object VisualElement root = rootVisualElement; // VisualElements objects can contain other VisualElement following a tree hierarchy. VisualElement label = new Label(&quot;Hello World! From C#&quot;); root.Add(label); // Import UXML var visualTree = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(&quot;Assets/Editor/FirstWindow/FirstWindow.uxml&quot;); VisualElement labelFromUXML = visualTree.CloneTree(); root.Add(labelFromUXML); // A stylesheet can be added to a VisualElement. // The style will be applied to the VisualElement and all of its children. var styleSheet = AssetDatabase.LoadAssetAtPath&lt;StyleSheet&gt;(&quot;Assets/Editor/FirstWindow/FirstWindow.uss&quot;); VisualElement labelWithStyle = new Label(&quot;Hello World! With Style&quot;); labelWithStyle.styleSheets.Add(styleSheet); root.Add(labelWithStyle); &#125;&#125; 1234567/* FirstWindow.uss */Label &#123; font-size: 20px; -unity-font-style: bold; color: rgb(68, 138, 255);&#125; 1234567891011&lt;!-- FirstWindow.uxml --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;engine:UXML xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:engine=&quot;UnityEngine.UIElements&quot; xmlns:editor=&quot;UnityEditor.UIElements&quot; xsi:noNamespaceSchemaLocation=&quot;../../../UIElementsSchema/UIElements.xsd&quot;&gt; &lt;engine:Label text=&quot;Hello World! From UXML&quot; /&gt;&lt;/engine:UXML&gt; 2.文件职责和使用建议 同web开发职责类似： - cs文件：类似于java文件，负责业务逻辑的处理并嵌入html以及css - uxml文件：类似于html和XAML、XML的结合版，负责整体视觉框架或者一些配置数据 - uss文件：类似于css样式表，负责显示元素的美化处理等 使用建议： - cs文件：仅仅用于连接uxml和uss，只在需要时动态创建视觉元素、编写业务逻辑 - uxml文件：编写整体视觉树的框架 - uss文件：编写全局&amp;部分元素样式 3. 更改以分配职责 123456789101112131415161718192021222324252627282930using UnityEditor;using UnityEngine;using UnityEngine.UIElements;using UnityEditor.UIElements;public class FirstWindow : EditorWindow&#123; [MenuItem(&quot;Window/UIElements/FirstWindow&quot;)] public static void ShowExample() &#123; FirstWindow wnd = GetWindow&lt;FirstWindow&gt;(); wnd.titleContent = new GUIContent(&quot;FirstWindow&quot;); &#125; public void CreateGUI() &#123; // Each editor window contains a root VisualElement object VisualElement root = rootVisualElement; // Import UXML var visualTree = AssetDatabase.LoadAssetAtPath&lt;VisualTreeAsset&gt;(&quot;Assets/Editor/FirstWindow/FirstWindow.uxml&quot;); VisualElement labelFromUXML = visualTree.CloneTree(); root.Add(labelFromUXML); // Import USS var styleSheet = AssetDatabase.LoadAssetAtPath&lt;StyleSheet&gt;(&quot;Assets/Editor/FirstWindow/FirstWindow.uss&quot;); root.styleSheets.Add(styleSheet); &#125;&#125;","tags":[{"name":"UIElements","slug":"UIElements","permalink":"https://peiyuzou.github.io/tags/UIElements/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"UI","slug":"05-游戏编程/Unity/UI","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/"},{"name":"UIElements","slug":"05-游戏编程/Unity/UI/UIElements","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/UIElements/"}]},{"title":"相机震屏反馈","date":"2022-11-23T05:23:14.000Z","path":"wiki/05-游戏编程/Unity/功能实例/相机震屏反馈/","text":"最近工作中遇到一个需求：攻击场景中的物体，需要让相机震动，以此来提升攻击的反馈感。 整体的功能逻辑比较简单，样例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475using UnityEngine;public class ShakeCamera : MonoBehaviour&#123; public float ShakeDuration = 0.3f;//持续时间 public float ShakeRange = 0.2f;//震动烈度 public float ShakeRate = 30f;//震动频率 private bool _isShaking; private float _shakeTime; private float _rateTime; private Vector3 _shakeOffset; private int _shakeCount; void Update() &#123; if(Input.GetKeyDown(KeyCode.F1)) &#123; ResetCameraArgs(); _shakeTime = ShakeDuration; _isShaking = true; &#125; if(!_isShaking) &#123; return; &#125; else &#123; if(_shakeTime &gt; 0) &#123; _shakeTime -= Time.deltaTime; _rateTime += Time.deltaTime; if (_rateTime &gt; 1.0 / ShakeRate) &#123; _rateTime = 0; //ShakeCount用于回正相机位置 if(_shakeCount++ % 2 == 0) &#123; _shakeOffset.x = Random.Range(-ShakeRange, ShakeRange); _shakeOffset.y = Random.Range(-ShakeRange, ShakeRange); _shakeOffset.z = Random.Range(-ShakeRange, ShakeRange); &#125; else &#123; //回正相机位置 _shakeOffset = -_shakeOffset; &#125; if(_shakeCount &gt; 1) &#123; //防止无限震屏导致数值越界 _shakeCount = 0; &#125; this.transform.position += _shakeOffset; &#125; &#125; else &#123; ResetCameraArgs(); _isShaking = false; &#125; &#125; &#125; private void ResetCameraArgs() &#123; if(_shakeCount % 2 != 0) &#123; //回正相机位置 this.transform.position -= _shakeOffset; &#125; _shakeCount = 0; _shakeOffset = Vector3.zero; &#125;&#125;","tags":[{"name":"Unity功能实例","slug":"Unity功能实例","permalink":"https://peiyuzou.github.io/tags/Unity%E5%8A%9F%E8%83%BD%E5%AE%9E%E4%BE%8B/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"功能实例","slug":"05-游戏编程/Unity/功能实例","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/%E5%8A%9F%E8%83%BD%E5%AE%9E%E4%BE%8B/"}]},{"title":"EditorWindow监听键盘事件","date":"2022-11-21T06:41:13.000Z","path":"wiki/05-游戏编程/Unity/EditorExtend/EditorWindow监听键盘事件/","text":"UnityEngine.Input在EditorWindow中是无法正常响应的，如果要在EditorWindow中监听键盘按下，可以在OnGUI中使用UnityEngine.Event.current 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253using UnityEngine;using UnityEditor;public class ZpyEditorWindow : EditorWindow&#123; [MenuItem(&quot;Tools/ZpyWindow&quot;)] private static void ShowWindow() &#123; var window = GetWindow&lt;ZpyEditorWindow&gt;(); window.titleContent = new GUIContent(&quot;ZpyWindow&quot;); window.Show(); &#125; private void OnGUI() &#123; var e = UnityEngine.Event.current; if (e.type != EventType.KeyDown) &#123; //事件类型 return; &#125; if (e.control) &#123; //组合Ctrl按键+某按键 switch (e.keyCode) &#123; case KeyCode.LeftArrow: // Ctrl + LeftArrow Debug.LogError(&quot;Ctrl + Left&quot;); break; default: return; &#125; &#125; else &#123; //单个按键 switch (e.keyCode) &#123; case KeyCode.RightArrow: // RightArrow Debug.LogError(&quot;right&quot;); break; default: return; &#125; &#125; // 使用按键后如果需要刷新窗口记得调用重绘 Repaint(); &#125;&#125;","tags":[{"name":"EditorExtend","slug":"EditorExtend","permalink":"https://peiyuzou.github.io/tags/EditorExtend/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"EditorExtend","slug":"05-游戏编程/Unity/EditorExtend","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/EditorExtend/"}]},{"title":"Unity中的GUID、FileID、InstanceID","date":"2022-11-19T14:52:15.000Z","path":"wiki/05-游戏编程/Unity/基础/03.Unity中的GUID、FileID、InstanceID/","text":"一、GUID GUID是存储在meta文件中的一个值，代表的是对应文件在工程中的唯一ID。 无论文件在工程中的何处，都可以通过AssetDatabase.GUIDToAssetPath和AssetDatabase.AssetPathToGUID在文件路径和GUID之间互相转换。 二、FileID 在Unity中，有的文件会产生若干子文件，比如图集、FBX等等，如下图： 有时候我们需要直接引用子文件的其中之一，这时候GUID无法满足需求，这时候就用到FileID。 对每一个子文件，Unity都生成了唯一的一个FileID，我们观察下图集的meta文件内容： 首先红框部分，标明了当前整个图集文件的GUID。其次蓝色部分存储了整个图片的导入设置，internalIDToNameTable指明了每张子图的名称和FileID的映射关系 需要注意的是，FileID前缀的213是UnityYAML中定义的类型ID，这里213指Sprite。具体参阅https://docs.unity3d.com/Manual/ClassIDReference.html FileID在Inspector面板中称Local Identfier In File，所以也叫LocalID 三、InstanceID InstanceID代表实例ID，在Unity中每有一个改文件的副本被创建时，都会自动分配一个值。InstanceID的值不像GUID和FileID，这俩的值在资源导入工程后就确认不变了，实例ID则是动态的值，每次运行游戏或者打开编辑器都可能不一样。","tags":[{"name":"Unity","slug":"Unity","permalink":"https://peiyuzou.github.io/tags/Unity/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"基础","slug":"05-游戏编程/Unity/基础","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/%E5%9F%BA%E7%A1%80/"}]},{"title":"UnityYAML","date":"2022-11-19T14:50:15.000Z","path":"wiki/05-游戏编程/Unity/基础/02.UnityYAML/","text":"在Unity中，序列化文件和meta文件本质上都是UnityYAML格式的文件，可以直接使用文本编辑器查看其内容。 一、Meta文件 meta文件第二行指明了该meta对应的原始文件在工程中的唯一ID：GUID 从第三行开始，根据不同的文件类型，有不同的内容： 对于Unity需要处理导入的文件，有对应的Importer信息。比如预制件对应了一个PrefabImporter，dll文件对应了一个PluginImporter等，文件夹等非文件或者无法识别的文件也对应了一个DefaultImporter 松散脚本文件本质上没有导入，而是编译，所以没有Importer 二、序列化文件 这里以一个prefab为例，它的Inspector面板长这样： 使用文本方式打开它，所有内容如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091%YAML 1.1%TAG !u! tag:unity3d.com,2011:--- !u!1 &amp;2548996960861856832GameObject: m_ObjectHideFlags: 0 m_CorrespondingSourceObject: &#123;fileID: 0&#125; m_PrefabInstance: &#123;fileID: 0&#125; m_PrefabAsset: &#123;fileID: 0&#125; serializedVersion: 6 m_Component: - component: &#123;fileID: 5130387460885348626&#125; - component: &#123;fileID: 7740301192594792805&#125; - component: &#123;fileID: 7973370026506665244&#125; - component: &#123;fileID: 5618074904614505148&#125; m_Layer: 5 m_Name: ZpyUi m_TagString: Untagged m_Icon: &#123;fileID: 0&#125; m_NavMeshLayer: 0 m_StaticEditorFlags: 0 m_IsActive: 1--- !u!224 &amp;5130387460885348626RectTransform: m_ObjectHideFlags: 0 m_CorrespondingSourceObject: &#123;fileID: 0&#125; m_PrefabInstance: &#123;fileID: 0&#125; m_PrefabAsset: &#123;fileID: 0&#125; m_GameObject: &#123;fileID: 2548996960861856832&#125; m_LocalRotation: &#123;x: 0, y: 0, z: 0, w: 1&#125; m_LocalPosition: &#123;x: 0, y: 0, z: 0&#125; m_LocalScale: &#123;x: 1, y: 1, z: 1&#125; m_Children: [] m_Father: &#123;fileID: 0&#125; m_RootOrder: 0 m_LocalEulerAnglesHint: &#123;x: 0, y: 0, z: 0&#125; m_AnchorMin: &#123;x: 0.5, y: 0.5&#125; m_AnchorMax: &#123;x: 0.5, y: 0.5&#125; m_AnchoredPosition: &#123;x: 0, y: 0&#125; m_SizeDelta: &#123;x: 1920, y: 1080&#125; m_Pivot: &#123;x: 0.5, y: 0.5&#125;--- !u!222 &amp;7740301192594792805CanvasRenderer: m_ObjectHideFlags: 0 m_CorrespondingSourceObject: &#123;fileID: 0&#125; m_PrefabInstance: &#123;fileID: 0&#125; m_PrefabAsset: &#123;fileID: 0&#125; m_GameObject: &#123;fileID: 2548996960861856832&#125; m_CullTransparentMesh: 0--- !u!114 &amp;7973370026506665244MonoBehaviour: m_ObjectHideFlags: 0 m_CorrespondingSourceObject: &#123;fileID: 0&#125; m_PrefabInstance: &#123;fileID: 0&#125; m_PrefabAsset: &#123;fileID: 0&#125; m_GameObject: &#123;fileID: 2548996960861856832&#125; m_Enabled: 1 m_EditorHideFlags: 0 m_Script: &#123;fileID: 388327683, guid: d05c7b2176348a9478b32514c46e03a0, type: 3&#125; m_Name: m_EditorClassIdentifier: m_Material: &#123;fileID: 2100000, guid: ba842e0c46768474d8443c764dea963d, type: 2&#125; m_Color: &#123;r: 1, g: 1, b: 1, a: 1&#125; m_RaycastTarget: 0 m_Maskable: 1 m_OnCullStateChanged: m_PersistentCalls: m_Calls: [] m_Sprite: &#123;fileID: 21300000, guid: fbe29152a48370345ac058d64760fc81, type: 3&#125; m_Type: 0 m_PreserveAspect: 0 m_FillCenter: 1 m_FillMethod: 4 m_FillAmount: 1 m_FillClockwise: 1 m_FillOrigin: 0 m_UseSpriteMesh: 0 m_PixelsPerUnitMultiplier: 1 mSpritePath:--- !u!114 &amp;5618074904614505148MonoBehaviour: m_ObjectHideFlags: 0 m_CorrespondingSourceObject: &#123;fileID: 0&#125; m_PrefabInstance: &#123;fileID: 0&#125; m_PrefabAsset: &#123;fileID: 0&#125; m_GameObject: &#123;fileID: 2548996960861856832&#125; m_Enabled: 1 m_EditorHideFlags: 0 m_Script: &#123;fileID: 11500000, guid: b9baae69706a4c9d9868410df9b79855, type: 3&#125; m_Name: m_EditorClassIdentifier: 整个Prefab的内容可以分为3部分： 1.头部 line 1 ~ 2，这两行是UnityYAML头部 2.GameObject信息 line 3 ~ 21，这一部分存储了预制体GameObject的信息 第3行 !u!1，这里的1是指YAML定义好的类型id，代表GameObject，可以参考官方文档：https://docs.unity3d.com/2019.4/Documentation/Manual/ClassIDReference.html !u!1后面紧跟的数字值便是该预制件的GameObject对应的FileID 剩下的部分是另外的存储字段，这里着重关照下line 10 ~ 14，这几行存储了预制件上的组件FileID 3.组件信息 line 22 ~ 90，这里存储了4个组件的信息，对应第二点GameObject中存储的4个FileID 这4个组件的格式和GameObject大同小异，但由于YAML类型id不同，它们的具体字段也不同。 通过查询官方文档，从上到下这四者依次为：RectTransform、CanvasRenderer、MonoBehaviour和MonoBehaviour，也就是Inspector面板中的4个组件 三、不同的FileID 这里有一个重要的细节需要注意，虽然Image和WorldTrackManager这两个组件都是自定义的脚本，但它们指向的FileID却不同。 Image组件：m_Script: &#123;fileID: 388327683, guid: d05c7b2176348a9478b32514c46e03a0, type: 3&#125;，FileID是388327683 WorldTrackManager组件：m_Script: &#123;fileID: 11500000, guid: b9baae69706a4c9d9868410df9b79855, type: 3&#125;，FileID是11500000 造成这个的原因是脚本本身的存储形式不同： Image组件封装在Dll库中，可以查看该Dll的meta文件： 然后是Inspector中Image组件的LocalID（也就是FileID）： 这俩图结合可以得到：Image组件指向的是GUID为d05c7b2176348a9478b32514c46e03a0的文件中FileID为388327683的子文件 而WorldTrackManager是一个松散脚本，在UnityYAML中，为松散脚本定义了类型MonoScript MonoScript的值为115，这里的FileID11500000是这个值乘以100000而来 查看该松散脚本的meta文件，其GUID也能对上：","tags":[{"name":"Unity","slug":"Unity","permalink":"https://peiyuzou.github.io/tags/Unity/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"基础","slug":"05-游戏编程/Unity/基础","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/%E5%9F%BA%E7%A1%80/"}]},{"title":"Unity中的文件","date":"2022-11-19T09:33:17.000Z","path":"wiki/05-游戏编程/Unity/基础/01.Unity中的文件/","text":"一、Unity文件的分类 序列化文件 资源文件 文本文件 代码文件 非序列化文件 meta文件 1.序列化文件（也叫Native Asset) 序列化文件指Unity能够序列化的文件，一般是Unity内部定义好的一些文件类型，比如.Prefab、.unity3d、.asset(ScriptableObject)、.mat等等。序列化文件能够在运行时直接反序列化为对应类（Unity内部定义的类或者说开发人员自己定义的类）的一个实例。 2.资源文件（也叫Imported Asset) 资源文件是指软件领域公认的一些后缀或者格式且Unity能够识别的文件。 公认：比如.png、.fbx等，就算不使用Unity，如果你从事软件领域的相关工作，也大概知道这是图片和模型格式的文件。这类文件大多是由美术设计师、音频设计师利用其他软件工具制造的。 Unity能够识别：能被Unity识别的这类文件，在Unity中有导入设置。不同的文件格式有不同的Importer，比如AudioImporter，TextureImporter，ModelImport等。 3.文本文件 文本文件比较特殊，它不是序列化文件，但是unity可以识别为TextAsset。很像资源文件，但是又不需要资源文件那样进行设置和转化。比如txt、xml文件等。 4.代码文件 包括Unity识别的代码文件、库文件、shader等，在导入时，Unity会自动进行一次编译。 5.非序列化文件 包括文件夹和Unity无法识别的文件 6.meta文件 meta文件不会再Unity中显示，但它是Unity最重要的一类文件。 每个显示在Project视图的文件或者文件夹，Unity会为其生成一个对应的*.meta文件，主要作用是： 为对应文件生成GUID（唯一Id）：在一个Unity工程中，通过一个有效的GUID，可以找到对应的唯一的文件。 存储资源文件的ImportSetting：所有资源文件的导入设置数据（其实出了资源文件以外的文件，其meta中都有对应的Importer，比如预制体的PrefabImporter、*.asset文件的NativeFormatImporter，文件夹的DefaultImporter等等） 存储AssetBundle相关的数据：打AB包时的分类等数据","tags":[{"name":"Unity","slug":"Unity","permalink":"https://peiyuzou.github.io/tags/Unity/"}],"categories":[{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"基础","slug":"05-游戏编程/Unity/基础","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/%E5%9F%BA%E7%A1%80/"}]},{"title":"Lua函数","date":"2021-11-20T05:30:17.000Z","path":"wiki/02-编程语言/Lua/Lua基础/03.Lua函数/","text":"一、可变长参数 用符号…表示 12345678910--表示用a和b存储...参数的前两个元素local a, b = ...--select函数--第一个参数为selector，表示返回参数列表第n个参数后的所有元素print(select(2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) --&gt; b c--selector为字符串&quot;#&quot;时，表示返回参数个数print(select(&quot;#&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) --&gt; 3--可用于取可变长参数个数select(&quot;#&quot;, ...) 二、正确的尾调用 形如下方： 1234function f(x) x = x + 1 return g(x)end 当函数最后一个动作是返回调用另外一个函数而没有再进行其他工作时，就形成了尾调用。在g返回时，程序的执行路径会直接返回到调用f的位置。所以在进行尾调用时，不使用任何额外的栈空间，所以一个程序中能嵌套的尾调用数量是无限的，这样调用永远不会发生栈溢出。 不是尾调用的情况： 123456789101112131415--相当于 return nil，并没有尾调用function f(x) g(x)end--[[相当于:local y = g(x)return y + 1]]return g(x) + 1 return x or g(x)return (g(x))","tags":[{"name":"Lua","slug":"Lua","permalink":"https://peiyuzou.github.io/tags/Lua/"}],"categories":[{"name":"02-编程语言","slug":"02-编程语言","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"02-编程语言/Lua","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"Lua基础","slug":"02-编程语言/Lua/Lua基础","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/Lua%E5%9F%BA%E7%A1%80/"}]},{"title":"Lua字符串","date":"2021-11-20T05:29:03.000Z","path":"wiki/02-编程语言/Lua/Lua基础/02.Lua字符串/","text":"一、字符 Lua中单个字符使用8个比特位（1个Byte）来存储，所以#号取的是字符串的个数，同时也是字符串占用的字节数 1print(#&quot;good bye&quot;) --&gt; 8 二、字符串转number 12--第二个参数标明按x进制来转换tonumber(&quot;fff&quot;, 16) --&gt; 4095 三、string.format 一个指示符的结构：%加上一个字母 %d：一个十进制整数 %x：一个十六进制整数 %f：一个浮点数 %s：一个字符串 四、其他字符串库函数 参阅：https://www.lua.org/manual/5.4/manual.html#6.4 注意：有的函数不适用于UTF-8编码的字符串，因为UTF-8编码的一个字符不是单个字节，而是多个字节，或者说字节序列。","tags":[{"name":"Lua","slug":"Lua","permalink":"https://peiyuzou.github.io/tags/Lua/"}],"categories":[{"name":"02-编程语言","slug":"02-编程语言","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"02-编程语言/Lua","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"Lua基础","slug":"02-编程语言/Lua/Lua基础","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/Lua%E5%9F%BA%E7%A1%80/"}]},{"title":"Lua数值","date":"2021-11-13T05:24:41.000Z","path":"wiki/02-编程语言/Lua/Lua基础/01.Lua数值/","text":"一、十六进制数的表示 12345678910111213--注意p代表2的幂，带p的这种格式的可读性很差，但是可以保留所有浮点数的精度，并且转换成十六进制比十进制更快--0x0.2 = 2 / 16 = 0.125print(0x0.2)--0x1p-1 = 1 x 2 ^ -1 = 0.5print(0x1p-1)--0xa.bp2 = (10 + 11 / 16) x 2 ^ 2 = 42.75print(0xa.bp2)--将十进制数按十六进制格式化输出print(string.format(&quot;%a&quot;, 419)) 二、Lua5.3引入了整数类型integer 1234567--type统一认为是number（数值类型）print(&quot;type:&quot;, type(3.0)) --numberprint(&quot;type:&quot;, type(3)) --number--math.type会区分integer和float（Lua5.3引入，注意对于Lua来说float表示的是双精度）print(&quot;math.type:&quot;, math.type(3.0)) --integerprint(&quot;math.type:&quot;, math.type(3)) --float 三、Lua5.3引入的新运算符：//（floor除法） 123456--结果是-5（-9 / 2 = -4.5，向下取整-5）print(-9 // 2)--这俩等效print(100 % 32)print(100 - (100 // 32) * 32) 四、两种取模运算的细节 12345678910--Lua中取模运算都是先计算商然后通过商得到余数，%和math.fmod这俩的区别在于对商的计算不同-- 商 = math.floor(-2 / 3) = -1，所以余数 = -2 - (-1 * 3) = 1print(-2 % 3)-- 商 = (-2 / 3)向0取整（注意不是向上也不是向下）= 0，所以余数 = -2print(math.fmod(-2, 3))--容易混淆的一个库函数math.modf，它的作用是将一个浮点数分为整数部分和小数部分--注意得到的值符号相同，一定是整数部分 + 小数部分 = 原来的数print(math.modf(-3.3)) --输出-3 -0.3 五、Lua数值类型的表示范围 12--Lua中不管是整型还是浮点数都用64个bit来存储（所以Lua的浮点数也是双精度，但是类型是float），需要注意的是整型有回环特征math.maxinteger + 1 == math.mininteger --&gt;true 六、一些常用的计算技巧 12345678910111213---保留到小数点后第几位function Percision() local x = math.pi print(x - x % 0.01) --3.14 print(x - x % 0.001) --3.141end---四舍五入function NearestInteger() --math.floor(x + 0.5) print(math.floor(0.4 + 0.5)) --0 print(math.floor(0.5 + 0.5)) --1end","tags":[{"name":"Lua","slug":"Lua","permalink":"https://peiyuzou.github.io/tags/Lua/"}],"categories":[{"name":"02-编程语言","slug":"02-编程语言","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"02-编程语言/Lua","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"Lua基础","slug":"02-编程语言/Lua/Lua基础","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/Lua%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"01-计算机科学","slug":"01-计算机科学","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"数据结构和算法","slug":"01-计算机科学/数据结构和算法","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"04-数组与链表","slug":"01-计算机科学/数据结构和算法/04-数组与链表","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"},{"name":"03-数据结构","slug":"01-计算机科学/数据结构和算法/03-数据结构","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"98-易混淆点","slug":"98-易混淆点","permalink":"https://peiyuzou.github.io/categories/98-%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9/"},{"name":"CrashCourse","slug":"01-计算机科学/CrashCourse","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/"},{"name":"02-复杂度分析","slug":"01-计算机科学/数据结构和算法/02-复杂度分析","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"},{"name":"01-概览","slug":"01-计算机科学/数据结构和算法/01-概览","permalink":"https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/01-%E6%A6%82%E8%A7%88/"},{"name":"05-游戏编程","slug":"05-游戏编程","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"},{"name":"压缩算法","slug":"05-游戏编程/压缩算法","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"},{"name":"Unity","slug":"05-游戏编程/Unity","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"},{"name":"Unity内存管理","slug":"05-游戏编程/Unity/Unity内存管理","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"name":"08-网络编程","slug":"08-网络编程","permalink":"https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"},{"name":"Socket","slug":"08-网络编程/Socket","permalink":"https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/"},{"name":"07-图形学","slug":"07-图形学","permalink":"https://peiyuzou.github.io/categories/07-%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"06-引擎开发","slug":"06-引擎开发","permalink":"https://peiyuzou.github.io/categories/06-%E5%BC%95%E6%93%8E%E5%BC%80%E5%8F%91/"},{"name":"04-程序数学","slug":"04-程序数学","permalink":"https://peiyuzou.github.io/categories/04-%E7%A8%8B%E5%BA%8F%E6%95%B0%E5%AD%A6/"},{"name":"02-编程语言","slug":"02-编程语言","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Lua","slug":"02-编程语言/Lua","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"},{"name":"源码阅读","slug":"02-编程语言/Lua/源码阅读","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"},{"name":"05-虚拟机","slug":"02-编程语言/Lua/源码阅读/05-虚拟机","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/"},{"name":"04-表","slug":"02-编程语言/Lua/源码阅读/04-表","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/"},{"name":"02-数据类型","slug":"02-编程语言/Lua/源码阅读/02-数据类型","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"03-字符串","slug":"02-编程语言/Lua/源码阅读/03-字符串","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/03-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"02-全局状态机及内存","slug":"02-编程语言/Lua/源码阅读/02-全局状态机及内存","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/02-%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E6%9C%BA%E5%8F%8A%E5%86%85%E5%AD%98/"},{"name":"01-概览","slug":"02-编程语言/Lua/源码阅读/01-概览","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/01-%E6%A6%82%E8%A7%88/"},{"name":"03-开发设计","slug":"03-开发设计","permalink":"https://peiyuzou.github.io/categories/03-%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/"},{"name":"游戏编程设计模式","slug":"03-开发设计/游戏编程设计模式","permalink":"https://peiyuzou.github.io/categories/03-%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"CSharp","slug":"02-编程语言/CSharp","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/"},{"name":"粒子系统","slug":"05-游戏编程/Unity/粒子系统","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/"},{"name":"99-问题记录","slug":"99-问题记录","permalink":"https://peiyuzou.github.io/categories/99-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"UI","slug":"05-游戏编程/Unity/UI","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/"},{"name":"UIElements","slug":"05-游戏编程/Unity/UI/UIElements","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/UI/UIElements/"},{"name":"功能实例","slug":"05-游戏编程/Unity/功能实例","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/%E5%8A%9F%E8%83%BD%E5%AE%9E%E4%BE%8B/"},{"name":"EditorExtend","slug":"05-游戏编程/Unity/EditorExtend","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/EditorExtend/"},{"name":"基础","slug":"05-游戏编程/Unity/基础","permalink":"https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/%E5%9F%BA%E7%A1%80/"},{"name":"Lua基础","slug":"02-编程语言/Lua/Lua基础","permalink":"https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/Lua%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"易混淆点","slug":"易混淆点","permalink":"https://peiyuzou.github.io/tags/%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9/"},{"name":"CS-101","slug":"CS-101","permalink":"https://peiyuzou.github.io/tags/CS-101/"},{"name":"Compression","slug":"Compression","permalink":"https://peiyuzou.github.io/tags/Compression/"},{"name":"Unity","slug":"Unity","permalink":"https://peiyuzou.github.io/tags/Unity/"},{"name":"Lua","slug":"Lua","permalink":"https://peiyuzou.github.io/tags/Lua/"},{"name":"游戏编程设计模式","slug":"游戏编程设计模式","permalink":"https://peiyuzou.github.io/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"C#","slug":"C","permalink":"https://peiyuzou.github.io/tags/C/"},{"name":"Issues","slug":"Issues","permalink":"https://peiyuzou.github.io/tags/Issues/"},{"name":"UIElements","slug":"UIElements","permalink":"https://peiyuzou.github.io/tags/UIElements/"},{"name":"Unity功能实例","slug":"Unity功能实例","permalink":"https://peiyuzou.github.io/tags/Unity%E5%8A%9F%E8%83%BD%E5%AE%9E%E4%BE%8B/"},{"name":"EditorExtend","slug":"EditorExtend","permalink":"https://peiyuzou.github.io/tags/EditorExtend/"}]}