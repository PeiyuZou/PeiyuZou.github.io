这是最近工作中遇到的一个问题，优化下来发现不如不优化，但还是有所发现，因此记录一下。

## 语言表过大

目前项目中的方案是从策划导出的 txt 文件解析为 lua.txt 文件，最后通过 luac 编译为二进制文件使用。

```txt title="Language.txt"
ID	zh-CN	zh-TW	en	th	vi	es
key1	哈哈哈	hahaha	hahaha	hahaha	hahaha	hahaha
key2	啊啊啊	aaa	aaa	aaa	aaa	aaa
...
```

项目中的语言表结构同上面（忽略上面的语言内容），因为有多语言，将非 `ID` 这一列每一列单独解析为了一个语种对应的文件。于是得到了 6 份文件，每个文件的内容相当于存了大量的 key-value ，key 是 Id ，value 是语言内容，但问题不在此，这只是前置说明。

核心问题在于，生成的 `.lua.txt` 每一行对应的 value 发生了大量重复，比如 key1001、key2001、key8993 三个 key 对应的语言包内容一模一样：

```
return {
    ...
    ["key1001"]="每天凌晨五点刷新",
    ...
    ["key2001"]="每天凌晨五点刷新",
    ...
    ["key8993"]="每天凌晨五点刷新",
    ...
}
```

整个语言包充斥着大量这样重复的情况，加上本身语言包的物理大小很大（超 6w 行，接近 20 M），所以萌生了想法去优化它的内容，减小文件的物理大小，认为这样编译出来的二进制文件会跟着变小。

## 方案

```
local t = {
    "等会撒u活动前期红啊科",
    "每天凌晨五点刷新",
    ...
}

return {
    ["key1000"]="但是噶寄快递哈卡",
    ["key1001"]=t[2],
    ...
    ["key2001"]=t[2],
    ...
    ["key8993"]=t[2],
    ...
}
```

解析生成的 `.lua.txt` 文件结构变成了这样，本以为这样 `.lua.txt` 和 二进制文件的物理大小都会变小，但结果出乎意料却又在意料之中：`.lua.txt` 文件的大小确实小了 30% 左右，但二进制文件反而变大了 10% 左右。这也反映了我所忽略的事实：** luac 对 lua 代码文件的编译本来就做了字符常量的去重**，刻意去做常量提取效果适得其反。

![右边是优化后的结果](language_opt_0.png)
/// caption
右边是优化后的结果
///

另外，新方案中在执行时，可能由于额外分配了一个表 t 的空间以及一些对上值的访问，内存占用上面反而上涨了 0.14 M：

![Lua Profiler 内存占用对比](language_opt_1.png)
/// caption
Lua Profiler 内存占用对比
///

## 结论

- 在优化文件大小时，编译带来的压缩效率需要考虑进去，而不是只考虑明文的文件内容（明文更小不代表二进制就更小）
- 敢于尝试 + 各方面严格测算，说不定会有更深一些的领悟