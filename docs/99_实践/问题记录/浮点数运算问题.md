## 一、问题

最近工作中遇到一个C#单精度浮点数丢精度的问题，直接上发生问题的代码：

![2023-03-11T202841](2023-03-11T202841.png)
/// caption
问题代码
///

第一种写法发生了严重的精度丢失，但其实不是全部的数都会发生这个问题，所以平时开发时并没有发现。要理解造成这个现象的原因，需要从浮点数的运算和存储的基础知识出发去追溯。

## 二、运算

首先，我们看下这段代码的 IL ，搞清楚CPU处理这段逻辑大概做了什么操作：

![2023-03-11T203934](2023-03-11T203934.png)
/// caption
对应的 IL
///

第一种写法， vectorX 和 scale 加载到寄存器后，执行的第一个操作是 conv.r4 ，也就是将 int32 类型的 scale 转换为了 float 。然后再执行乘法，紧接着将结果强转 int64 ，最后输出。从 IL 看没有什么问题，下面我们按照 IL 的步骤手动运算一下。

### 1、得到两个变量在机器中的真实值

整个问题运算的核心是 1.3f 和 10.0f 这两个单精度浮点数运算：

十进制数 1.3 转换为二进制数为 $1.01001100110011..._{(2)}$

由浮点数存储规则： $V = (-1)^S × M × 2^E$

1. 符号位 S ，因为是正数，所以为 0
2. 阶数 $E = log_{2}1 = 0$ ，float的偏置量 bias 是 $2^k - 1 = 2^8 - 1 = 127$ ，所以 $exponent = E + bias = 127$ ，得到 8 位阶码 01111111
3. fraction 直接等于二进制小数位，由于 float 的尾数位有 23 个，所以保留前 23 ，得到尾数二进制 01001100110011001100110

拼起来就是如下：


!!! note ""
    0<font color='red'>0111111 1</font><font color='blue'>0100110 01100110 01100110</font>


我们再从这个值推算阶数 E 和 fraction （这里需要注意：这个二进制值不是由 E 和 fraction 计算得到的吗，什么又要推算回去？答：因为在计算实际的存储中， fraction 由于只有 23 位，可能发生截断，如果截断后最低位是 1 ，那么还会发生进位舍入，导致机器存储的实际值和数学意义上的值不一致）

$E = 2^6 + 2^5 + 2^4 + 2^3 + 2^2 + 2^1 - 127 = 0$

$fraction = 0.01001100110011001100110$

$M = 1 + fraction = 1.01001100110011001100110 = 1.0100110011001100110011$（最低位的0对于数学计算来说没有用，可以忽略）

所以 1.3 可以表示为：$(-1)^S × M × 2^E = 2^0 × 1.0100110011001100110011_{(2)}$

同理， 10.0 表示为： $2^3 × 1.01_{(2)}$

### 2、二进制乘法

由上面得到的机器值结果：

$$
\begin{align}
1.3 × 10.0 &= 2^0 × 1.0100110011001100110011_{(2)} × 2^3 × 1.01_{(2)} \\
           &= 2^3 × 1.0100110011001100110011_{(2)} × 1.01_{(2)} \\
\end{align}
$$

$1.0100110011001100110011_{(2)} × 1.01_{(2)}$ 的二进制乘法结果如下：

![2023-03-11T214038](2023-03-11T214038.png)

取小数点后 23 位 10011111111111111111111

所以最终， ALU 计算得到的值是 $2^3 × 1.10011111111111111111111_{(2)}$

## 三、存储

ALU 已经得到了值 $2^3 × 1.10011111111111111111111_{(2)}$

E = 3，所以 exponent = 3 + 127 = 130 ，阶码为 1000001 0

整个结果表示为：

!!! note ""
    0<font color='red'>1000001 0</font><font color='blue'>1001111 11111111 11111111</font>

在现代CPU架构中，乘法和除法乘法和除法运算是使用两个累加器（主累加器 EAX 与从累加器 EDX）进行临时存储（例如，MUL ECX 将把两个 32 位寄存器 ECX 与 EAX 相乘，64 位结果放入 EAX 与 EDX）

所以，累加器中的二进制值如下：

!!! note ""
    EAX：
    01000001 01001111 11111111 11111111

    EDX：
    00000000 00000000 00000000 00000000

这里存储的实际值是 12.99999904632568359375

接下来的处理是关键的地方，这个值被不同类型的变量去存，会有不同的二进制表现：

### 1、存储在float中

EAX中的32位值会被加载给栈上float变量的32位，这里由于最低位是1，会发生进位舍入，所以float变量的存储是：

!!! note ""
    01000001 01010000 00000000 00000000

这个值是最终程序用到的值： $2^3 x (1 + 2^{-1} + 2^{-3}) = 8 * 1.625 = 13$

这也是为什么第二种写法得到正确结果的原因， 12.99999904632568359375 先存入float变量，发生了进位舍入变为了 13 ，再强转 long 时，小数截断完仍然是 13

### 2、存储在int或者long中

浮点数转整型，会直接发生小数截断，也就是直接舍弃所有小数点后的值， 12.99999904632568359375 直接截断为 12，这也是第一种写法发生精度丢失的原因

### 3、存储在double中

由于 double 和 float 的阶码位和尾数位不一样，所以 8 位的阶码会重新计算成 11 位阶码，然后 23 位 fraction 会存储在 52 位 fraction 中，不足的低位用 0 布满，所以 double 变量的存储是这样：

!!! note ""
    01000000 00101001 11111111 11111111

    11111100 00000000 00000000 00000000

这个值是： 12.99999988079071044921875

所以理论上，如果我们在强转 long 之前不是用 float 去存而是用 double 存，也会被截断为 12 ，我们验证下：

![2023-03-11T223026](2023-03-11T223026.png)

需要注意的是，第一种写法和第三种写法导致精度丢失的原因并不一样。第一种是因为累加器的值直接截断了；第三种是因为 double 存储，没有发生进位，同时也被截断了。

## 四、总结

个人认为，其实从浮点数的设计来看，精度丢失无法避免。如果程序对精度有要求，最好是通过整型存储一个放大的值来处理。如果精度要求高， float 无法完成任务，选择使用 double