## VM 内存池

Unity 编辑器进程自身使用 Mono VM，打包后的实际游戏进程根据脚本后端选择不同，使用 IL2Cpp Runtime 或者 Mono VM。注意这里说的 VM 是指实际游戏进程使用的 VM。

Mono VM 的内存池，内存以 Block 的形式管理，当一个 Block 连续 6 次 GC 没有被访问到，这块内存会被返回给系统，条件苛刻，比较难触发。

IL2CPP 更容易触发，因为它的内存管理更像一个传统 C++ 程序的内存管理模式。

!!! note "注意"
    GC 本身是不会把内存返还给操作系统的，它是回收给虚拟机。

## Unity 的 GC

### 1. GC 机制的考量

- Throughput（回收能力）：一次GC能收回多少内存
- Pause times（暂停时长）：GC时对主线程的影响会多大（卡顿）
- Fragmentation（碎片化）：对整体内存池的碎片化影响多少
- Mutator overhead（额外消耗）：GC时的消耗，GC时需要做很多的统计会产生消耗
- Scalability（可拓展性）：拓展到多核多线程会不会有什么bug
- Portability（可移植性）：在不同的平台上是否可以使用

### 2. Boehm GC 和 Incremental GC

Unity 用的 Boehm GC，简单粗暴，不分代。它有以下特点：

- Non-generational（非分代式），即全都堆在一起，因为这样会很快。分代的话就是例如大内存，小内存，超小内存分在不同的内存区域来进行管理（SGen GC的设计思想）。
- Non-Compacting（非压缩式），即当有内存被释放的时候，这块区域就空着。而压缩式的会重新排布，填充空白区域，使内存紧密排布。

但目前 Unity 在 Mono 上已经使用 SGen GC （Scalable Generational GC，分代垃圾回收器）了，而 IL2CPP 则是嵌入了一个定制化后的 Boehm

结论如下表：

| Unity后端 | 使用的GC | 是否 Boehm | 是否支持分代 |
|---|---|---|---|
| Mono（编辑器）| Mono SGen GC | 非 Boehm | 是 |
| IL2CPP | Boehm GC（定制版） | 是 | 否 |
| DOTS/Burst | 无托管堆 | 无GC | N/A |

Unity 另外实装了 Incremental GC，主要解决主线程卡顿的问题，现在进行一次GC主线程被迫要停下来，遍历所有的 Memory Island，决定哪些要被 GC 掉，会造成一定时间的主线程卡顿。Incremental GC 把前面暂停主线程的事分帧做了，这样主线程不会出现峰值。

### 3. 内存碎片化

非压缩式的内存虽然快（避免了内存重新排布的时间消耗），但是容易造成内存碎片化。内存的碎片化容易间接内存异常上涨，比如内存总用量下降了，但是还在继续分配新的空间。例如，内存中有一些空白的内存区域时，分配了一块较大内存时，却没有任何的一个空间放得下（即使整体的空间足够），导致内存扩充很多。

因此建议在需要连续分配内存的情况下，先操作大内存，然后操作小内存，可以一定程度上减轻碎片化。

### 4. 僵尸内存

这个和内存泄漏常被人搞混在一起。僵尸内存是指碎片化内存之间空出的内存，这部分内存可能成为僵尸内存。这种情况实际上并不是内存泄露，因为这些内存并没有被泄露，泄露指这块内存没有任何人可以访问和管理，但实际上这块内存一直在内存池里。


## Managed Memory 最佳实践

### 1. Don't Null it, Destroy it

用 Destroy，别用 null，显示的调用 Destroy 才能真正的销毁掉。

### 2. Class 和 Struct 不要混用

这个不赘述

### 3. Pool In Pool

高频使用的部分自己建一个内存池去重用

### 4. Closures and anonymous methods（闭包和匿名函数）

所有的匿名函数和闭包在 C# 编 IL 代码时都会被 new 成一个 Class（匿名class），所以在里面所有变量以及new的东西，都是要占内存的。

### 5. Coroutines（协程）

协程属于闭包和匿名函数的特例，游戏开始启动一个协程直到游戏结束才释放，是错误的做法。因为协程只要没被释放，里面的所有变量，即使是局部变量（包括值类型），也都会在内存里。建议用的时候才生产一个协程，不用的时候就丢掉。

### 6. Configurations（配置表）

全部配置表一下全部进内存也是不明智的，可以考虑分关加载等策略。

### 7. Singleton（单例）

慎用单例，不要什么都往里放，因为里面的变量会一直占用内存。