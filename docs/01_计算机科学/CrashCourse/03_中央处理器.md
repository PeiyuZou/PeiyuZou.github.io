中央处理器，常称 CPU（Central Processing Unit），我们本篇从一个高层次视角去了解 CPU 的组成，每一个根线不是指代真正的数据线，而是一组完善电路的抽象，代表这里有某种连接，这种高层次视角称 “微体系架构” （MicroArchitecture）

## CPU 组成

首先，我们要准备一个 RAM ，但注意**内存不是 CPU 的组成部分**，这里是为了演示 CPU 如何和内存打交道，进而解释它每个组成部分在其中发挥的作用。

为了简单，我们假设有一个只有 16 个地址的 RAM（如下图所示），因此它的地址可以用 4 位值表示（0 ~ 15），这 16 个地址中存储了若干的指令或者数据。对于数据来说，其中的 8 位都是值。对于指令来说，高 4 位代表操作码，低 4 位代表目标数据在内存或者寄存器中的地址。（这里只是举例，在实际的内存中可能和这个设计不一样，也可能更复杂）

![内存](cpu_0.png)
/// caption
内存
///

### 设立寄存器

为了操作数据和存储临时数据，我们需要给 CPU 安排 4 个寄存器：

![临时存储和操作数据的寄存器](cpu_1.png)
/// caption
临时存储和操作数据的寄存器
///

我们给 CPU 支持的所有指令分配一个操作码，对应上面指令中的高 4 位，比如下图：

![指令表](cpu_2.png)
/// caption
指令表
///

我们还需要另外两个寄存器：

- 指令地址寄存器：用于追踪当前程序运行到哪里，存储的是指令在内存中的地址
- 指令寄存器：用于存储当前指令，方便 CPU 解码这个指令

![指令地址寄存器 和 指令寄存器](cpu_3.png)
/// caption
指令地址寄存器 和 指令寄存器
///

计算机开始运行，所有寄存器被初始化为 0 ：

![初始化寄存器](cpu_4.png)
/// caption
初始化寄存器
///

### 取指令

计算机从内存中取指令，然后一条一条执行，首先指令地址寄存器访问内存的第一个地址，并且将第一个地址的内容（一条指令）放入指令寄存器中：

![取指令阶段](cpu_5.png)
/// caption
取指令阶段
///

### 解释并执行指令

得到了一条指令后，计算机需要将这条指令解释。它的高 4 位的值对应指令表中的第一条，即将指定内存地址的值放入寄存器 A 中：

![解释并执行](cpu_6.png)
/// caption
解释并执行
///

### 继续取指令、解释、执行

执行完一条指令后，指令地址寄存器指向的内存地址 + 1 ，继续读取下一条指令，然后解释执行。

## 控制单元

由指令地址寄存器、指令寄存器、解码电路等部分组成了一个控制单元（Control Unit），我们可以将它抽象出来：

![控制单元](cpu_7.png)
/// caption
控制单元
///


## 继续执行

### 第二条指令

CPU 继续取下一条指令并执行，第二条指令将内存地址 15 的值放在了寄存器 B 中：

![第二条指令的执行结果](cpu_8.png)
/// caption
第二条指令的执行结果
///

### 第三条指令

第三条指令比较特殊，它代表将两个寄存器的值相加，并将结果放在指定的第二个寄存器中，这里寄存器 A 的地址为 00 ，寄存器 B 的地址为 01 ，因此是要将 B 中的值与 A 中的值相加，结果放入 A 中：

![第三条指令的解释阶段](cpu_9.png)
/// caption
第三条指令的解释阶段
///

为了对两个值做算数运算，我们需要继续设立一个 ALU 进来，控制单元会将两个寄存器的值作为 ALU 的两个输入，然后传递 ALU 当前的操作码，计算得到的值并不会马上写入寄存器，而是放在一个临时的寄存器中（图中没有），当关闭 ALU 之后再写入寄存器 A ，防止 ALU 的值错误：

![第三条指令的执行阶段](cpu_10.png)
/// caption
第三条指令的执行阶段
///

### 最后一条指令

最后一条指令，将寄存器 A 中的值写入内存中：

![第四条指令的执行结果](cpu_11.png)
/// caption
第四条指令的执行结果
///

## 时钟

时钟（Clock）用来管理 CPU 的执行节奏。

![时钟](cpu_12.png)
/// caption
时钟
///

它以精确的间隔来触发电信号，控制单元根据这个电信号去推动 CPU 的内部操作。这频率不能太快，因为电的传输也需要时间（很少很少）。

CPU 执行一次 “取指令-解码-执行” 的速度叫做 “时钟速度” ，它的单位是赫兹（Hz），现代 CPU 的主频已经达到了 GHz 级别，我们常说的超频就是允许 CPU 以更快的速度执行，但会增大用电量，并且可能损坏 CPU ，同样，许多 CPU 也有降频功能，在闲置的时间段内降频可以降低耗电量，这些都是通过改变时钟速度实现的。

## 对 CPU 做一次抽象

现在我们得到了一个简单的 CPU ，可以对它进行一次抽象：

![CPU](cpu_13.png)
/// caption
CPU
///

从这里也可以看出来，RAM 不是 CPU 的组成部分，但它们息息相关

## 指令集

上面提到的操作码，在实际计算机中远不止 4 个，也不止 4 位，比如常见的让程序停止运行的 HALT 指令等。为了让指令能更多，有两个策略：

- 直接用更多位来表示指令，比如 32 位甚至 64 位
- 采用可变指令长度，比如 JUMP 指令占 8 位，但它后面需要跟一个立即值，代表要跳转的内存地址，这样设计的话，指令长度可以是任意的，但是 CPU 在读取阶段会更加复杂一些

CPU 可以识别的这样一批指令叫做指令集，现代的 CPU 拥有上千条的指令，光 ADD 指令都有很多变种，比我们例子中的要复杂很多，但是核心原理没有变。