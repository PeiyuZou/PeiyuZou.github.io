## 什么是虚拟内存？

假设我们有一个设备，还编写了两个程序，每个程序都需要用到 1000 个内存地址。

如果两个程序用到的地址都从 0 开始，那么这两个程序是无法同时运行在这台机器上的，因为一个程序写入在某个地址上的数据会因为另一个程序写入新的数据而擦除。所以，为了让两个程序能同时运行在这台机器上，我们只能规定：第一个程序使用地址 0 ~ 999 ，第二个程序使用地址 1000 ~ 1999 。那么，当我们需要运行第三个程序时，地址又只能规定它使用 2000 ~ 2999 ，全世界那么多的程序，不可能一一规定它们使用的地址范围。

操作系统为了解决这个问题，引入了**虚拟地址**。当一个进程在操作系统中运行起来时，操作系统会为它分配一套独立的虚拟地址，但实际存储的位置则是被映射到不同的物理地址上。比如有两个进程正在同时运行，它们看到自己的内存地址都是从 0x2519FF 开始的，但实际的物理地址却不一样。这样，相当于所有的进程都被操作系统动态地“隔离开”，程序在编写的时候也不用关心物理地址了。

进程持有的虚拟地址通过 CPU 中的内存管理单元（MMU）的映射关系转换为物理地址，然后再通过物理地址访问内存，如下图所示：

![虚拟地址转换为物理地址](virtual_memory_01.png)
/// caption
虚拟地址转换为物理地址
///


## 虚拟地址和物理地址的映射管理

虚拟地址和物理地址的映射主要有两种方式：内存分段和内存分页

### 内存分段

一个程序可能被操作系统划分为多个段：比如分为代码段、数据段、栈段、堆段，这几个段在物理地址上不一定是连续的，比如下图：

![程序被分段](virtual_memory_02.png)
/// caption
程序被分段
///

再来看虚拟地址具体是如何映射到物理地址上的：

![内存分段的映射](virtual_memory_03.png)
/// caption
内存分段的映射
///

虚拟地址被拆分，得到段号和偏移量（当然还有一些其他部分）。段号用于在段表中查找段的基地址和界限；偏移量则是具体地址基于基地址的相对位置。这样一组合就可以得到物理地址。

分段虽然解决了映射问题，让程序不需要关心物理内存地址，但是它也存在着**外部内存碎片**和**内存交换效率低**两个问题。

![外部内存碎片](virtual_memory_04.png)
/// caption
外部内存碎片
///

外部内存碎片的问题如上图所示，虽然浏览器的内存被释放，剩余总空间的大小虽然高于 200MB 但是仍然无法容纳一整块的 200MB 内存分配。为了解决外部内存碎片问题，操作系统会执行**内存交换**，比如将图中音乐占用的 256MB 内存写到硬盘上，然后再读回内存中，这样音乐程序的内存区域会紧跟着游戏的部分，从而让剩余空间变为一整块 256MB 的区域，就可以让新的 200MB 内存进来了。

用于做内存交换的空间就是我们常说的 **Swap空间**，它是从硬盘划分出来的，硬盘的访问速度是非常低下的。为了解决内存分段的这两个问题，诞生了内存分页的管理方式。

### 内存分页

内存分页的思路是将整个虚拟内存空间和物理内存空间都按照固定大小切分成一个个的**页（Page）**。在 Windows 和 Linux 中，单个页的大小是 4KB ，iOS 老设备（ARM32）是 4KB 而新设备（ARM64）是 16KB 。安卓大部分是 4KB ，也存在少数是 16KB 。

这种方式的映射不再依赖段表，而是依赖页表：

![页表的职责](virtual_memory_05.png)
/// caption
页表的职责
///

映射的转换如下图所示：

![内存分页的映射](virtual_memory_06.png)
/// caption
内存分页的映射
///

#### 分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？

分页让程序在加载的时候，不用一次性把整个程序全部加载到物理内存中。只有在程序运行中，需要用到对应虚拟内存页中的指令和数据时，才加载到物理内存中去。

由于提前划分好了一个个的页，这些页是整齐排列的，所以不会有外部碎片。但是相反的，会出现**内部碎片**：分页机制加载程序时分配内存的最小单位是一页，即使程序不足一页大小。

另外，内存交换效率低的问题也被解决，分页机制下同样会发生内存交换，但是交换的对象由一整个程序段变为了 “最近没被使用” 的内存页面，大大降低了交换时间。内存页面写入磁盘和写回内存中的行为分别称**换出（Swap Out）**和**换入（Swap In）**。

#### 多级页表

简单的分页存在着一个问题：页表的大小相对于可用内存来说将会非常大，比如 32位环境 4GB 的虚拟内存下，单个进程就需要使用 4MB 的页表。

!!! note "简单分页页表大小的计算"
    假设 32位环境 4GB 的虚拟内存，一个页的大小为 4KB （2^12），那么总的内存会被分为大约 100 万（2^20）个页。每个页的映射关系需要 4 个字节来存储，一共就需要 4MB 的内存空间。每个进程都有自己的虚拟地址空间，所以 100 个进程就需要 400MB 的内存来存储页表，这已经非常庞大了，在 64 位的环境下会更严重。

多级页表的思路是将单级页表作为二级页，再额外加入一级页和二级页的映射关系，如下图：

![多级页表的设计](virtual_memory_07.png)
/// caption
多级页表的设计
///

那么你可能注意到了，这样不是在原有的基础上占用空间更多了吗？比如上图的例子，在原有的 4MB 的基础上，还多出了 4KB 的一级页表。

实际的情况是，一级页表会全部分配在内存中，但是二级页表只有在一级页表的对应页号被使用时才会分配创建，一般的程序对于一级页表的使用率是很低的，而且存在内存交换，长时间未使用的页表甚至会被交换到硬盘中，不会占用物理内存。我们假设只有 20% 的一级页表被使用，那么页表占用的空间只有 4KB（一级页表）+ 20% * 4MB（二级页表）= 0.804 MB，这相对于单级页表的 4MB 已经是一个很大的提升了。

单级页表为什么不能在需要时才创建呢？其实多级页表的二级页表也单级页表是相同的，也需要覆盖全部虚拟地址空间，但是临时创建发生在一级页表，这是多级页表的额外特性，所以对于单级页表来说，需要一次性创建能覆盖全部虚拟地址空间的页表，这 4MB 无法优化。

对于 64 位的系统，两级的分页也不够用，实际上有四级分页：

- 全局页目录项 PGD（Page Global Directory）
- 上层页目录项 PUD（Page Upper Directory）
- 中间页目录项 PMD（Page Middle Directory）
- 页表项 PTE（Page Table Entry）

![64位系统的多级分页](virtual_memory_08.png)
/// caption
64位系统的多级分页
///

#### TLB（Translation Lookaside Buffer）

虽然多级页表解决了空间上的问题，但是由于多了几次转换，所以时间上的开销变重了，由于程序存在局部性的原理，大多数情况下 CPU 访问的存储空间都是一段相邻的地址，所以有一个思路是把最常访问的几个页表项放在一个访问速度更快的硬件里面，封装在 CPU 中。这就诞生了 TLB ，就是我们熟知的快表，也叫页表缓存、转址旁路缓存。

MMU 负责地址的转换和 TLB 的访问交互。CPU 在寻址时，会先查 TLB ，如果没有找到，再继续查常规的页表。

![TLB](virtual_memory_09.png)
/// caption
TLB
///


### 段页式内存管理

内存分段和内存分页也可以结合起来，形成段页式的内存管理，地址的结构变为由**段号、段内页号、页内位移组成**：

![段页式内存管理](virtual_memory_10.png)
/// caption
段页式内存管理
///


## Linux 内存布局

Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制。因为 Intel X86 CPU 一律对程序中使用的地址先进行段式映射，然后才能进行页式映射。但是 Linux 内核所采取的办法是使段式映射的过程不起作用。因此说它是页式内存管理，但是又涉及了段机制。

Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。

在 Linux 操作系统中，虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，如下所示：

![Linux虚拟地址空间](virtual_memory_11.png)
/// caption
Linux虚拟地址空间
///

虽然每个进程都各自有独立的虚拟内存，但是**每个虚拟内存中的内核地址，其实关联的都是相同的物理内存**。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。

![内核空间物理地址是同一个](virtual_memory_12.png)
/// caption
内核空间物理地址是同一个
///

### Linux 虚拟空间的划分情况

![Linux虚拟空间的划分情况](virtual_memory_13.png)
/// caption
Linux虚拟空间的划分情况
///

以 32 位系统为例，通过这张图你可以看到，用户空间内存，从低到高分别是 6 种不同的内存段：

- 代码段，包括二进制可执行代码
- 数据段，包括已初始化的静态常量和全局变量
- BSS 段，包括未初始化的静态变量和全局变量
- 堆段，包括动态分配的内存，从低地址开始向上增长
- 文件映射段，包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）
- 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8MB 。当然系统也提供了参数，以便我们自定义大小

在这 7 个内存段中，堆和文件映射段的内存是动态分配的。

!!! note "保留区"
    上图中的内存布局可以看到，代码段下面还有一段内存空间的（灰色部分），这一块区域是「保留区」，之所以要有保留区这是因为在大多数的系统里，我们认为比较小数值的地址不是一个合法地址。例如，我们通常在 C 的代码里会将无效的指针赋值为 NULL。因此，这里会出现一段不可访问的内存保留区，防止程序因为出现 bug ，导致读或写了一些小内存地址的数据，而使得程序跑飞。