## 什么是虚拟内存？

假设我们有一个设备，还编写了两个程序，每个程序都需要用到 1000 个内存地址。

如果两个程序用到的地址都从 0 开始，那么这两个程序是无法同时运行在这台机器上的，因为一个程序写入在某个地址上的数据会因为另一个程序写入新的数据而擦除。所以，为了让两个程序能同时运行在这台机器上，我们只能规定：第一个程序使用地址 0 ~ 999 ，第二个程序使用地址 1000 ~ 1999 。那么，当我们需要运行第三个程序时，地址又只能规定它使用 2000 ~ 2999 ，全世界那么多的程序，不可能一一规定它们使用的地址范围。

操作系统为了解决这个问题，引入了**虚拟地址**。当一个进程在操作系统中运行起来时，操作系统会为它分配一套独立的虚拟地址，但实际存储的位置则是被映射到不同的物理地址上。比如有两个进程正在同时运行，它们看到自己的内存地址都是从 0x2519FF 开始的，但实际的物理地址却不一样。这样，相当于所有的进程都被操作系统动态地“隔离开”，程序在编写的时候也不用关心物理地址了。

进程持有的虚拟地址通过 CPU 中的内存管理单元（MMU）的映射关系转换为物理地址，然后再通过物理地址访问内存，如下图所示：

![虚拟地址转换为物理地址](virtual_memory_01.png)
/// caption
虚拟地址转换为物理地址
///


## 虚拟地址和物理地址的映射管理

虚拟地址和物理地址的映射主要有两种方式：内存分段和内存分页

### 内存分段

一个程序可能被操作系统划分为多个段：比如分为代码段、数据段、栈段、堆段，这几个段在物理地址上不一定是连续的，比如下图：

![程序被分段](virtual_memory_02.png)
/// caption
程序被分段
///

再来看虚拟地址具体是如何映射到物理地址上的：

![虚拟地址映射为物理地址](virtual_memory_03.png)
/// caption
虚拟地址映射为物理地址
///

虚拟地址被拆分，得到段号和偏移量（当然还有一些其他部分）。段号用于在段表中查找段的基地址和界限；偏移量则是具体地址基于基地址的相对位置。这样一组合就可以得到物理地址。

分段虽然解决了映射问题，让程序不需要关心物理内存地址，但是它也存在着**外部内存碎片**和**内存交换效率低**两个问题。

![外部内存碎片](virtual_memory_04.png)
/// caption
外部内存碎片
///

外部内存碎片的问题如上图所示，虽然浏览器的内存被释放，剩余总空间的大小虽然高于 200MB 但是仍然无法容纳一整块的 200MB 内存分配。为了解决外部内存碎片问题，操作系统会执行**内存交换**，比如将图中音乐占用的 256MB 内存写到硬盘上，然后再读回内存中，这样音乐程序的内存区域会紧跟着游戏的部分，从而让剩余空间变为一整块 256MB 的区域，就可以让新的 200MB 内存进来了。

用于做内存交换的空间就是我们常说的 **Swap空间**，它是从硬盘划分出来的，硬盘的访问速度是非常低下的。为了解决内存分段的这两个问题，诞生了内存分页的管理方式。

### 内存分页

内存分页的思路是将整个虚拟内存空间和物理内存空间都按照固定大小切分成一个个的**页（Page）**。在 Windows 和 Linux 中，单个页的大小是 4KB ，iOS 老设备（ARM32）是 4KB 而新设备（ARM64）是 16KB 。安卓大部分是 4KB ，也存在少数是 16KB 。

这种方式的映射不再依赖段表，而是依赖页表：

![页表的职责](virtual_memory_05.png)
/// caption
页表的职责
///

#### 分页是怎么解决分段的「外部内存碎片和内存交换效率低」的问题？

TODO