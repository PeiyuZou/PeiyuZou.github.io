冯诺依曼模型在 1945 年被提出，它由 5 个部分组成：**运算器、控制器、存储器、输入设备、输出设备**

![冯诺依曼模型](Von_Neumann_1.png)
/// caption
冯诺依曼模型
///

运算器和控制器是属于 CPU 的部分（中央处理器，当然 CPU 还有其他组成部分，比如寄存器），存储器、输入、输出设备通过总线和 CPU 传递数据，它们的关系如下图：

![总线的职责](Von_Neumann_2.png)
/// caption
总线的职责
///

接下来，分别认识下这几个部分。

## 内存

内存是独立于 CPU 的一个部分。它负责在计算机运行时存储程序和数据，注意它和硬盘等其他存储设备的区别。

关于内存有一个极其容易混淆的概念：**计算机存储数据的最小单位是 bit （位）而不是 byte （字节，1 byte = 8 bit），但最小的寻址单位是 byte 。**

很多人会说存储数据的最小单位是 byte ，为什么会有这样的说法？因为计算机内存的地址按照一个字节来编址，很多语言为了遵循内存对齐（主要是为了提升访问内存数据的速度，单独的篇章介绍），没有设计小于一个字节的数据类型，比如 C# 的布尔类型，本质上一个 bit 就可以存，但还是设计成了一个 byte 。那么有没有小于一个字节的数据类型呢？或者说有没有什么可以按位存储数据的方式呢？其实也有，比如 C/C++ 支持在结构体中定义位域，可以指定字段占用的位数：

``` c title="" linenums="1" hl_lines="0"
struct Flags {
    unsigned int flag1 : 1;  // 这样写代表这个域只占用 1 位
    unsigned int flag2 : 1;  // 1 位
    unsigned int flag3 : 1;  // 1 位
    // 这3个字段可以共享1个字节
};
```

再者还有常用的数值类型的压缩算法，比如 C# 把多个不太大的数分别存储在一个 long 的不同 bit 上。

编址和语言的设计，很容易让人误以为数据存储至少需要一个内存地址，所以存储的最小单位是一个字节。这样的说法其实是错误的，最小存储单位是一个位。

在抽象层面，内存比较类似一个数组，所有的内存空间被编排为连续的内存地址。但在具体的硬件层面，内存其实是由多路复用器控制访问的行列形式，一个内存地址可以拆分为行地址和列地址，行列结合就可以快速定位要访问的物理内存，因此可以说访问任何地址的内存数据的速度都是一样的。

## 中央处理器

中央处理器的主要职责是解释计算机指令以及处理计算机软件中的数据。

### 64位 vs 32位

我们常说的 64 位 CPU 和 32 位 CPU 到底是什么意思？很多人其实对这个东西没有正确的理解。

首先，这个**位指的是 CPU 的通用寄存器的位宽，不一定代表 CPU 的寻址能力或者总线的宽度**。

可以这么理解

{==

32位CPU = 具有32位通用寄存器的CPU

64位CPU = 具有64位通用寄存器的CPU

==}

但是需要注意，不能说 32 位 CPU 是代表它的寄存器的位宽是 32 位的。因为除了通用寄存器还存在一些其他的寄存器，比如我们来看下 x86-64 CPU 的寄存器全景：

```
通用寄存器（64位）:
RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, R8-R15

指令指针（64位）:
RIP

段寄存器（16位！）:
CS, DS, ES, SS, FS, GS

标志寄存器（64位，但只用32位）:
RFLAGS

浮点寄存器（80位！）:
ST0-ST7

SIMD寄存器（128/256/512位！）:
XMM0-XMM15 (128位)
YMM0-YMM15 (256位)
ZMM0-ZMM31 (512位)

控制寄存器（64位）:
CR0, CR2, CR3, CR4, CR8

调试寄存器（64位）:
DR0-DR7
```

结论：64 位 CPU 有 64 位通用寄存器，但也有 16 位、80 位、128 位、256 位、512 位的寄存器！

那怎么理解寻址能力呢？CPU 要寻址就必须能告诉其它元件这个地址的值是多少，CPU 和其它部件之间靠总线传输数据，因此总线的位宽代表了 CPU 的寻址能力。

但是总线的位宽不能和 CPU 的位宽划等号，举几个例子：

- Intel 8086（16 位 CPU）：它的地址总线并不是 16 位，而是 20 位，寻址空间是 $2^{20}$ = 1MB
- 80386（32位CPU）早期型号：它的总线有 24 位和 26 位版本的，并非完整的 32 位，寻址空间分别为 16MB 和 64 MB
- 现代的 x86-64（64位CPU）：它的地址总线一般为 48位（某些是52位，如Intel的5级页表），寻址空间为 $2^{48}$ = 256TB（而非 $2^{64}$ = 16EB）

那么针对最后一个例子中的 x86-64 提出问题，为什么不用全部64位？

1. 实际需求：256TB 已经远超当前硬件需求
2. 硬件成本：64 根地址线太贵，信号完整性难保证
3. 功耗和面积：减少晶体管数量
4. 地址空洞设计：预留地址空间用于特殊用途

其它常见的误解：

!!! danger "误解1："64 位 CPU 运行速度是 32 位的 2 倍""
    实际：对于 32 位以内的运算，速度差异不大；对于 64位 数据或大内存场景才有明显优势（32位 CPU 需要更多指令和步骤处理 64 位数据）

!!! danger "误解2："64 位程序一定比 32 位快""
    实际：如果内存需求小于 4GB，且没有大量 64 位运算，32 位程序可能更省内存（指针更小）

### 寄存器

从结构图中，我们发现除了运算单元和控制单元外，还有寄存器部分。CPU 中的寄存器有很多种，比如通用寄存器，它主要负责存放计算时的数据。再比如程序计数器，它用于存储 CPU 要执行的下一条指令的内存地址。指令寄存器用于存放正在执行的指令本身，等等。还有一些其他的寄存器，各自功能不同。


## 总线

总线用于 CPU 和其他设备进行通信，它分为 3 种：

- 地址总线，用于指定 CPU 将要操作的内存地址
- 数据总线，用于读写内存的数据
- 控制总线，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线

当 CPU 要读写内存数据的时候，一般需要通过下面这三个总线：

- 首先要通过「地址总线」来指定内存的地址
- 然后通过「控制总线」控制是读或写命令
- 最后通过「数据总线」来传输数据

## 输入输出设备

输入设备向计算机输入数据，计算机经过计算后，把数据输出给输出设备。常见的输入设备比如鼠标、键盘等。输出设备比如显示器、音响等。