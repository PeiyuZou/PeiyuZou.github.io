## 概览

哈希表是通过建立**键值对映射关系**来实现高效查询的数据结构。

哈希表的核心是建立和维护键值的映射关系，那么它是如何做到的呢？我们知道数组通过下标访问元素的效率是极快的，数组其实也可以把下标看作 key 同时把元素值看作 value 。试想一下，假如我们有两个键值对 (key:1 value:2) 和 (key:100000000 value:3) ，那么要通过数组来存储这个映射关系需要一个长度为 100000000 的数组，却仅仅只存了两个键值对。

所以键值对的映射关系可以转化为另外一个问题：**如何将一个较大的输入空间如何映射到一个较小的输出空间？**

这个问题的解决思路是：

- 把数组的大小和输出空间对齐，确保数组能够容纳输出空间的全部值。但也不能太大，造成空间浪费。
- 把键转换为另外一个数字值，确保这个值在数组的长度内。

以上就是解决键值对映射关系的思路，哈希表的设计大致如此。

![哈希表的抽象表示](hash_table_0.png)
/// caption
哈希表的抽象表示
///

在哈希表中进行增删查改的时间复杂度都是 $O(1)$ ，非常高效。


## 哈希表简单实现

我们考虑最简单的情况，仅用一个数组来实现哈希表。在哈希表中，我们将数组中的每个空位称为桶（bucket），每个桶可存储一个键值对。因此，查询操作就是找到 key 对应的桶，并在桶中获取 value 。

和上面提到的思路一样，只不过我们换成了更具体的方案：

- 输入一个 key 值
- 通过某种哈希算法 hash() 计算得到哈希值
- 将哈希值对桶数量（数组长度）capacity 取模，从而获取该 key 对应的数组索引 index 。

```C#
var index = hash(key) % capacity
```

下图中哈希函数是 `key % 100` ，即取最后两位数：

![哈希函数工作原理](hash_table_1.png)
/// caption
哈希函数工作原理
///

## 哈希冲突与扩容

当我们把较大的输入空间约束映射为较小的输出空间时，理论上一定存在 “多个输入对应相同输出” 的情况。这种情况我们称为**哈希冲突**

![哈希冲突示例](hash_table_2.png)
/// caption
哈希冲突示例
///

容易想到，哈希表容量越大，多个 key 被分配到同一个桶中的概率就越低，冲突就越少。因此，我们可以通过扩容哈希表来减少哈希冲突。

![哈希表扩容](hash_table_3.png)
/// caption
哈希表扩容
///

类似于数组扩容，哈希表扩容需将所有键值对从原哈希表迁移至新哈希表，非常耗时；并且由于哈希表容量 capacity 改变，我们需要通过哈希函数来重新计算所有键值对的存储位置，这进一步增加了扩容过程的计算开销。为此，编程语言通常会预留足够大的哈希表容量，防止频繁扩容。

负载因子（load factor）是哈希表的一个重要概念，其定义为哈希表的元素数量除以桶数量，用于衡量哈希冲突的严重程度，**也常作为哈希表扩容的触发条件**。例如在 Java 中，当负载因子超过 0.75 时，系统会将哈希表扩容至原先的 2 倍。