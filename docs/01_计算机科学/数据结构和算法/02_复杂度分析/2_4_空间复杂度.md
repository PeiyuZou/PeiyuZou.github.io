空间复杂度（space complexity）用于衡量算法占用内存空间随着数据量变大时的增长趋势。

## 算法相关空间

算法在运行过程中使用的内存空间主要包括以下几种。

- 输入空间：用于存储算法的输入数据
- 暂存空间：用于存储算法在运行过程中的变量、对象、函数上下文等数据
    - 暂存数据：用于保存算法运行过程中的各种常量、变量、对象等
    - 栈帧空间：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放
    - 指令空间：用于保存编译后的程序指令，在实际统计中通常忽略不计
- 输出空间：用于存储算法的输出数据

一般情况下，空间复杂度的统计范围是 “暂存空间” 加上 “输出空间” ：

![算法使用的相关空间](space_complex_0.png)
/// caption
算法使用的相关空间
///

代码举例：

```C++
/* 结构体 */
struct Node {
    int val;
    Node *next;
    Node(int x) : val(x), next(nullptr) {}
};

/* 函数 */
int func() {
    // 执行某些操作...
    return 0;
}

int algorithm(int n) {        // 输入数据
    const int a = 0;          // 暂存数据（常量）
    int b = 0;                // 暂存数据（变量）
    Node* node = new Node(0); // 暂存数据（对象）
    int c = func();           // 栈帧空间（调用函数）
    return a + b + c;         // 输出数据
}
```


## 推算方法

**我们通常只关注最差空间复杂度**。因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留：

- 以最差输入数据为准
- 以算法运行中的峰值内存为准

```C#
void Algorithm(int n) {
    int a = 0;                   // O(1)
    int[] b = new int[10000];    // O(1)
    if (n > 10) {
        int[] nums = new int[n]; // O(n)
    }
}
```

上面这个例子，最差空间复杂度为 $O(n)$

在递归函数中，需要注意统计栈帧空间：

```C#
int Function() {
    // 执行某些操作
    return 0;
}
/* 循环的空间复杂度为 O(1) */
void Loop(int n) {
    for (int i = 0; i < n; i++) {
        Function();
    }
}
/* 递归的空间复杂度为 O(n) */
int Recur(int n) {
    if (n == 1) return 1;
    return Recur(n - 1);
}
```


## 常见类型

![常见的空间复杂度类型](space_complex_1.png)
/// caption
常见的空间复杂度类型
///

### 常数阶 $O(1)$

```C++
/* 函数 */
int Function() {
    // 执行某些操作
    return 0;
}

/* 常数阶 */
void Constant(int n) {
    // 常量、变量、对象占用 O(1) 空间
    int a = 0;
    int b = 0;
    int[] nums = new int[10000];
    ListNode node = new(0);
    // 循环中的变量占用 O(1) 空间
    for (int i = 0; i < n; i++) {
        int c = 0;
    }
    // 循环中的函数占用 O(1) 空间
    for (int i = 0; i < n; i++) {
        Function();
    }
}
```

### 线性阶 $O(n)$

```C++
/* 线性阶 */
void Linear(int n) {
    // 长度为 n 的数组占用 O(n) 空间
    int[] nums = new int[n];
    // 长度为 n 的列表占用 O(n) 空间
    List<ListNode> nodes = [];
    for (int i = 0; i < n; i++) {
        nodes.Add(new ListNode(i));
    }
    // 长度为 n 的哈希表占用 O(n) 空间
    Dictionary<int, string> map = [];
    for (int i = 0; i < n; i++) {
        map.Add(i, i.ToString());
    }
}
```

### 平方阶 $O(n^2)$

```C++
/* 平方阶 */
void Quadratic(int n) {
    // 矩阵占用 O(n^2) 空间
    int[,] numMatrix = new int[n, n];
    // 二维列表占用 O(n^2) 空间
    List<List<int>> numList = [];
    for (int i = 0; i < n; i++) {
        List<int> tmp = [];
        for (int j = 0; j < n; j++) {
            tmp.Add(0);
        }
        numList.Add(tmp);
    }
}
```

### 指数阶 $O(2^n)$

指数阶常见于二叉树

```C++
/* 指数阶（建立满二叉树） */
TreeNode? BuildTree(int n) {
    if (n == 0) return null;
    TreeNode root = new(0) {
        left = BuildTree(n - 1),
        right = BuildTree(n - 1)
    };
    return root;
}
```

### 对数阶 $O(log n)$

对数阶常见于分治算法。例如归并排序，输入长度为 n 的数组，每轮递归将数组从中点处划分为两半，形成高度为 $log_{2}n$ 的递归树，使用 $O(log_{2}n)$ 栈帧空间。


## 权衡时间与空间

**降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然**。我们将牺牲内存空间来提升算法运行速度的思路称为 “以空间换时间” ；反之，则称为 “以时间换空间” 。