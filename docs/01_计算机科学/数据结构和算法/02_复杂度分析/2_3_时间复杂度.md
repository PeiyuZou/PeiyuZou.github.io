时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势

## 统计时间增长趋势

```C++
// 算法 A 的时间复杂度：常数阶
void algorithm_A(int n) {
    cout << 0 << endl;
}
// 算法 B 的时间复杂度：线性阶
void algorithm_B(int n) {
    for (int i = 0; i < n; i++) {
        cout << 0 << endl;
    }
}
// 算法 C 的时间复杂度：常数阶
void algorithm_C(int n) {
    for (int i = 0; i < 1000000; i++) {
        cout << 0 << endl;
    }
}
```

分析这个例子：

- 算法 A 运行时间不随 n 的增大而增长，它的时间复杂度为 “常数阶”
- 算法 B 运行时间随着 n 增大呈线性增长。此算法的时间复杂度被称为 “线性阶”
- 算法 C 虽然运行时间很长，但它与输入数据大小与 n 无关，因此也是 “常数阶”


## 时间复杂度推算方法

### 第一步：统计操作数量

```C++
void algorithm(int n) {
    int a = 1;
    a = a + n;
    for (int i = 0; i < 5 * n + 1; i++) {
        cout << 0 << endl;
    }
    for (int i = 0; i < 2 * n; i++) {
        for (int j = 0; j < n + 1; j++) {
            cout << 0 << endl;
        }
    }
}
```

以上代码如果精确地统计它的操作数量，应该是这样：

$$ T(n) = 2n(n + 1) + 5(n + 1) + 2 = 2n^2 + 7n + 3 $$

它的时间复杂度为 $O(n^2)$ （时间复杂度由 $T(n)$ 中最高阶的项来决定），但我们可以通过技巧来快速推断：

- 舍掉常数和系数，因为它们不会影响最终的计算
- 循环嵌套时使用乘法

所以上述代码，我们可以直接得到操作数量：

$$ T(n) = n^2 + n $$

转为时间复杂度为 $O(n^2)$

## 常见类型

![常见的时间复杂度类型](time_complex_0.png)\
/// caption
常见的时间复杂度类型
///

以下分别用 C++ 代码举例：

### 常数阶 $O(1)$

```C++
/* 常数阶 */
int constant(int n) {
    int count = 0;
    int size = 100000;
    for (int i = 0; i < size; i++)
        count++;
    return count;
}
```

### 线性阶 $O(n)$

```C++
/* 线性阶 */
int linear(int n) {
    int count = 0;
    for (int i = 0; i < n; i++)
        count++;
    return count;
}
```

### 平方阶 $O(n^2)$

```C++
/* 平方阶 */
int quadratic(int n) {
    int count = 0;
    // 循环次数与数据大小 n 成平方关系
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            count++;
        }
    }
    return count;
}
```

### 指数阶 $O(2^n)$

以 “细胞分裂” 为例，每轮是上一次的两倍

```C++
/* 指数阶（循环实现） */
int exponential(int n) {
    int count = 0, base = 1;
    // 细胞每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1)
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < base; j++) {
            count++;
        }
        base *= 2;
    }
    // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1
    return count;
}
```

### 对数阶 $O(log n)$

与指数阶相反，对数阶反映了“每轮缩减到一半”的情况

```C++
/* 对数阶（循环实现） */
int logarithmic(int n) {
    int count = 0;
    while (n > 1) {
        n = n / 2;
        count++;
    }
    return count;
}
```

### 线性对数阶 $O(n log n)$

线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 $O(n)$ 和 $O(log n)$

```C++
/* 线性对数阶 */
int linearLogRecur(int n) {
    if (n <= 1)
        return 1;
    int count = linearLogRecur(n / 2) + linearLogRecur(n / 2);
    for (int i = 0; i < n; i++) {
        count++;
    }
    return count;
}
```

### 阶乘阶 $O(n!)$

阶乘阶对应数学上的 “全排列” 问题

```C++
/* 阶乘阶（递归实现） */
int factorialRecur(int n) {
    if (n == 0)
        return 1;
    int count = 0;
    // 从 1 个分裂出 n 个
    for (int i = 0; i < n; i++) {
        count += factorialRecur(n - 1);
    }
    return count;
}
```


## 最差、最佳、平均时间复杂度

算法的时间效率往往不是固定的，而是与输入数据的分布有关。因此我们的算法的时间复杂度可能会变化。

我们在实际中很少使用最佳时间复杂度，因为通常只有在很小概率下才能达到，可能会带来一定的误导性。而最差时间复杂度更为实用，因为它给出了一个效率安全值，让我们可以放心地使用算法。

平均时间复杂度则是体现算法在随机输入数据下的运行效率。