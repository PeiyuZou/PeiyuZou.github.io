队列是一种先进先出的线性数据结构

![队列的先入先出规则](queue_0.png)
/// caption
队列的先入先出规则
///

## 常用操作

| 方法 | 描述 | 时间复杂度 |
|---|---|---|
| push() | 元素入队，即将元素添加至队尾 | $O(1)$ |
| pop() | 队首元素出队 | $O(1)$ |
| peek() | 访问队首元素 | $O(1)$ |

```C#
/* 初始化队列 */
Queue<int> queue = new();

/* 元素入队 */
queue.Enqueue(1);
queue.Enqueue(3);
queue.Enqueue(2);
queue.Enqueue(5);
queue.Enqueue(4);

/* 访问队首元素 */
int peek = queue.Peek();

/* 元素出队 */
int pop = queue.Dequeue();

/* 获取队列的长度 */
int size = queue.Count;

/* 判断队列是否为空 */
bool isEmpty = queue.Count == 0;
```


## 队列实现

### 基于链表的实现

可以将链表的“头节点”和“尾节点”分别视为“队首”和“队尾”，规定队尾仅可添加节点，队首仅可删除节点。

=== "step 1"
    ![step 1](queue_1.png)
=== "step 2"
    ![step 2](queue_2.png)
=== "step 3"
    ![step 3](queue_3.png)

```C#
/* 基于链表实现的队列 */
class LinkedListQueue {
    ListNode? front, rear;  // 头节点 front ，尾节点 rear
    int queSize = 0;

    public LinkedListQueue() {
        front = null;
        rear = null;
    }

    /* 获取队列的长度 */
    public int Size() {
        return queSize;
    }

    /* 判断队列是否为空 */
    public bool IsEmpty() {
        return Size() == 0;
    }

    /* 入队 */
    public void Push(int num) {
        // 在尾节点后添加 num
        ListNode node = new(num);
        // 如果队列为空，则令头、尾节点都指向该节点
        if (front == null) {
            front = node;
            rear = node;
            // 如果队列不为空，则将该节点添加到尾节点后
        } else if (rear != null) {
            rear.next = node;
            rear = node;
        }
        queSize++;
    }

    /* 出队 */
    public int Pop() {
        int num = Peek();
        // 删除头节点
        front = front?.next;
        queSize--;
        return num;
    }

    /* 访问队首元素 */
    public int Peek() {
        if (IsEmpty())
            throw new Exception();
        return front!.val;
    }

    /* 将链表转化为 Array 并返回 */
    public int[] ToArray() {
        if (front == null)
            return [];

        ListNode? node = front;
        int[] res = new int[Size()];
        for (int i = 0; i < res.Length; i++) {
            res[i] = node!.val;
            node = node.next;
        }
        return res;
    }
}
```

### 基于数组的实现

用数组实现有一个核心问题，删除队首元素的时间复杂度为 $O(n)$ ，效率比较低，但我们可以通过下面的方法巧妙地规避：

使用一个变量 front 指向队首元素的索引，并维护一个变量 size 用于记录队列长度。定义 rear = front + size ，这个公式计算出的 rear 指向队尾元素之后的下一个位置。

基于此设计，数组中包含元素的有效区间为 [front, rear - 1] ：

- 入队操作：将输入元素赋值给 rear 索引处，并将 size 增加 1 。
- 出队操作：只需将 front 增加 1 ，并将 size 减少 1 。

可以看到，入队和出队操作都只需进行一次操作，时间复杂度均为 $O(1)$ 。

=== "step 1"
    ![step 1](queue_4.png)
=== "step 2"
    ![step 2](queue_5.png)
=== "step 3"
    ![step 3](queue_6.png)

你可能会发现一个问题：在不断进行入队和出队的过程中，front 和 rear 都在向右移动，**当它们到达数组尾部时就无法继续移动了**。为了解决此问题，我们可以将数组视为首尾相接的“环形数组”。

对于环形数组，我们需要让 front 或 rear 在越过数组尾部时，直接回到数组头部继续遍历。这种周期性规律可以通过“取余操作”来实现，代码如下所示：

```C#
/* 基于环形数组实现的队列 */
class ArrayQueue {
    int[] nums;  // 用于存储队列元素的数组
    int front;   // 队首指针，指向队首元素
    int queSize; // 队列长度

    public ArrayQueue(int capacity) {
        nums = new int[capacity];
        front = queSize = 0;
    }

    /* 获取队列的容量 */
    int Capacity() {
        return nums.Length;
    }

    /* 获取队列的长度 */
    public int Size() {
        return queSize;
    }

    /* 判断队列是否为空 */
    public bool IsEmpty() {
        return queSize == 0;
    }

    /* 入队 */
    public void Push(int num) {
        if (queSize == Capacity()) {
            Console.WriteLine("队列已满");
            return;
        }
        // 计算队尾指针，指向队尾索引 + 1
        // 通过取余操作实现 rear 越过数组尾部后回到头部
        int rear = (front + queSize) % Capacity();
        // 将 num 添加至队尾
        nums[rear] = num;
        queSize++;
    }

    /* 出队 */
    public int Pop() {
        int num = Peek();
        // 队首指针向后移动一位，若越过尾部，则返回到数组头部
        front = (front + 1) % Capacity();
        queSize--;
        return num;
    }

    /* 访问队首元素 */
    public int Peek() {
        if (IsEmpty())
            throw new Exception();
        return nums[front];
    }

    /* 返回数组 */
    public int[] ToArray() {
        // 仅转换有效长度范围内的列表元素
        int[] res = new int[queSize];
        for (int i = 0, j = front; i < queSize; i++, j++) {
            res[i] = nums[j % this.Capacity()];
        }
        return res;
    }
}
```

以上实现的队列仍然具有局限性：其长度不可变。然而，这个问题不难解决，我们可以将数组替换为动态数组，从而引入扩容机制。


## 典型应用

- 淘宝订单。购物者下单后，订单将加入队列中，系统随后会根据顺序处理队列中的订单。在双十一期间，短时间内会产生海量订单，高并发成为工程师们需要重点攻克的问题。
- 各类待办事项。任何需要实现 “先来后到” 功能的场景，例如打印机的任务队列、餐厅的出餐队列等，队列在这些场景中可以有效地维护处理顺序。