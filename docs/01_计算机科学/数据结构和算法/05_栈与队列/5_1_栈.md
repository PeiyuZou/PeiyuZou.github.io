栈是一种先进后出的线性数据结构

![栈的先入后出规则](stack_0.png)
/// caption
栈的先入后出规则
///

## 常用操作

| 方法 | 描述 | 时间复杂度 |
|---|---|---|
| push() | 元素入栈（添加至栈顶） | $O(1)$ |
| pop() | 栈顶元素出栈 | $O(1)$ |
| peek() | 访问栈顶元素 | $O(1)$ |

```C#
/* 初始化栈 */
Stack<int> stack = new();

/* 元素入栈 */
stack.Push(1);
stack.Push(3);
stack.Push(2);
stack.Push(5);
stack.Push(4);

/* 访问栈顶元素 */
int peek = stack.Peek();

/* 元素出栈 */
int pop = stack.Pop();

/* 获取栈的长度 */
int size = stack.Count;

/* 判断是否为空 */
bool isEmpty = stack.Count == 0;
```

## 栈的实现

栈可以视为一种受限制的数组或链表

### 基于链表的实现

将链表的头节点视为栈顶，尾节点视为栈底。对于入栈操作，我们只需将元素插入链表头部，这种节点插入方法被称为“头插法”。而对于出栈操作，只需将头节点从链表中删除即可。

=== "step 1"
    ![step 1](stack_1.png)
=== "step 2"
    ![step 2](stack_2.png)
=== "step 3"
    ![step 3](stack_3.png)

```C#
/* 基于链表实现的栈 */
class LinkedListStack {
    ListNode? stackPeek;  // 将头节点作为栈顶
    int stkSize = 0;   // 栈的长度

    public LinkedListStack() {
        stackPeek = null;
    }

    /* 获取栈的长度 */
    public int Size() {
        return stkSize;
    }

    /* 判断栈是否为空 */
    public bool IsEmpty() {
        return Size() == 0;
    }

    /* 入栈 */
    public void Push(int num) {
        ListNode node = new(num) {
            next = stackPeek
        };
        stackPeek = node;
        stkSize++;
    }

    /* 出栈 */
    public int Pop() {
        int num = Peek();
        stackPeek = stackPeek!.next;
        stkSize--;
        return num;
    }

    /* 访问栈顶元素 */
    public int Peek() {
        if (IsEmpty())
            throw new Exception();
        return stackPeek!.val;
    }

    /* 将 List 转化为 Array 并返回 */
    public int[] ToArray() {
        if (stackPeek == null)
            return [];

        ListNode? node = stackPeek;
        int[] res = new int[Size()];
        for (int i = res.Length - 1; i >= 0; i--) {
            res[i] = node!.val;
            node = node.next;
        }
        return res;
    }
}
```

### 基于数组的实现

使用数组实现栈时，我们可以将数组的尾部作为栈顶。入栈与出栈操作分别对应在数组尾部添加元素与删除元素，时间复杂度都为 $O(1)$ 。

=== "step 1"
    ![step 1](stack_4.png)
=== "step 2"
    ![step 2](stack_5.png)
=== "step 3"
    ![step 3](stack_6.png)

由于入栈的元素可能会源源不断地增加，因此我们可以使用动态数组，这样就无须自行处理数组扩容问题。

```C#
/* 基于数组实现的栈 */
class ArrayStack {
    List<int> stack;
    public ArrayStack() {
        // 初始化列表（动态数组）
        stack = [];
    }

    /* 获取栈的长度 */
    public int Size() {
        return stack.Count;
    }

    /* 判断栈是否为空 */
    public bool IsEmpty() {
        return Size() == 0;
    }

    /* 入栈 */
    public void Push(int num) {
        stack.Add(num);
    }

    /* 出栈 */
    public int Pop() {
        if (IsEmpty())
            throw new Exception();
        var val = Peek();
        stack.RemoveAt(Size() - 1);
        return val;
    }

    /* 访问栈顶元素 */
    public int Peek() {
        if (IsEmpty())
            throw new Exception();
        return stack[Size() - 1];
    }

    /* 将 List 转化为 Array 并返回 */
    public int[] ToArray() {
        return [.. stack];
    }
}
```

## 两种实现的对比

### 时间效率

- 基于数组实现的栈，由于连续内存所以具有很好的缓存本地性，效率较高。但在触发扩容时效率会降低，但由于扩容是低频操作，因此平均效率更高。
- 基于链表实现的栈，不存在扩容的情况，可以提供更加稳定的效率表现。

### 空间效率

- 基于数组实现的栈，可能会造成扩容，因此可能造成一定程度的空间浪费
- 基于链表实现的栈，需要额外存储指针，所以单个节点占用的空间更大些

### 总结

两种实现皆有利有弊，具体情况需要具体分析。


## 典型应用

- **浏览器中的后退与前进、软件中的撤销与反撤销**。每当我们打开新的网页，浏览器就会对上一个网页执行入栈，这样我们就可以通过后退操作回到上一个网页。后退操作实际上是在执行出栈。如果要同时支持后退和前进，那么需要两个栈来配合实现。
- **程序内存管理**。每次调用函数时，系统都会在栈顶添加一个栈帧，用于记录函数的上下文信息。在递归函数中，向下递推阶段会不断执行入栈操作，而向上回溯阶段则会不断执行出栈操作。