双向队列在队列的基础上，允许在头部和尾部执行元素的添加或删除操作。

![双向队列的操作](double_ended_queue_0.png)
/// caption
双向队列的操作
///

## 常用操作

| 方法 | 描述 | 时间复杂度 |
|---|---|---|
| push_first() | 将元素添加至队首 | $O(1)$ |
| push_last() | 将元素添加至队尾 | $O(1)$ |
| pop_first() | 删除队首元素 | $O(1)$ |
| pop_last() | 删除队尾元素 | $O(1)$ |
| peek_first() | 访问队首元素 | $O(1)$ |
| peek_last() | 访问队尾元素 | $O(1)$ |

```C#
/* 初始化双向队列 */
// 在 C# 中，将链表 LinkedList 看作双向队列来使用
LinkedList<int> deque = new();

/* 元素入队 */
deque.AddLast(2);   // 添加至队尾
deque.AddLast(5);
deque.AddLast(4);
deque.AddFirst(3);  // 添加至队首
deque.AddFirst(1);

/* 访问元素 */
int peekFirst = deque.First.Value;  // 队首元素
int peekLast = deque.Last.Value;    // 队尾元素

/* 元素出队 */
deque.RemoveFirst();  // 队首元素出队
deque.RemoveLast();   // 队尾元素出队

/* 获取双向队列的长度 */
int size = deque.Count;

/* 判断双向队列是否为空 */
bool isEmpty = deque.Count == 0;
```


## 双向队列的实现

### 基于双向链表的实现

=== "LinkedListDeque"
    ![LinkedListDeque](double_ended_queue_1.png)
=== "push_last"
    ![push_last](double_ended_queue_2.png)
=== "push_first"
    ![push_first](double_ended_queue_3.png)
=== "pop_last"
    ![pop_last](double_ended_queue_4.png)
=== "pop_first"
    ![pop_first](double_ended_queue_5.png)

```C#
/* 双向链表节点 */
class ListNode(int val) {
    public int val = val;       // 节点值
    public ListNode? next = null; // 后继节点引用
    public ListNode? prev = null; // 前驱节点引用
}

/* 基于双向链表实现的双向队列 */
class LinkedListDeque {
    ListNode? front, rear; // 头节点 front, 尾节点 rear
    int queSize = 0;      // 双向队列的长度

    public LinkedListDeque() {
        front = null;
        rear = null;
    }

    /* 获取双向队列的长度 */
    public int Size() {
        return queSize;
    }

    /* 判断双向队列是否为空 */
    public bool IsEmpty() {
        return Size() == 0;
    }

    /* 入队操作 */
    void Push(int num, bool isFront) {
        ListNode node = new(num);
        // 若链表为空，则令 front 和 rear 都指向 node
        if (IsEmpty()) {
            front = node;
            rear = node;
        }
        // 队首入队操作
        else if (isFront) {
            // 将 node 添加至链表头部
            front!.prev = node;
            node.next = front;
            front = node; // 更新头节点
        }
        // 队尾入队操作
        else {
            // 将 node 添加至链表尾部
            rear!.next = node;
            node.prev = rear;
            rear = node;  // 更新尾节点
        }

        queSize++; // 更新队列长度
    }

    /* 队首入队 */
    public void PushFirst(int num) {
        Push(num, true);
    }

    /* 队尾入队 */
    public void PushLast(int num) {
        Push(num, false);
    }

    /* 出队操作 */
    int? Pop(bool isFront) {
        if (IsEmpty())
            throw new Exception();
        int? val;
        // 队首出队操作
        if (isFront) {
            val = front?.val; // 暂存头节点值
            // 删除头节点
            ListNode? fNext = front?.next;
            if (fNext != null) {
                fNext.prev = null;
                front!.next = null;
            }
            front = fNext;   // 更新头节点
        }
        // 队尾出队操作
        else {
            val = rear?.val;  // 暂存尾节点值
            // 删除尾节点
            ListNode? rPrev = rear?.prev;
            if (rPrev != null) {
                rPrev.next = null;
                rear!.prev = null;
            }
            rear = rPrev;    // 更新尾节点
        }

        queSize--; // 更新队列长度
        return val;
    }

    /* 队首出队 */
    public int? PopFirst() {
        return Pop(true);
    }

    /* 队尾出队 */
    public int? PopLast() {
        return Pop(false);
    }

    /* 访问队首元素 */
    public int? PeekFirst() {
        if (IsEmpty())
            throw new Exception();
        return front?.val;
    }

    /* 访问队尾元素 */
    public int? PeekLast() {
        if (IsEmpty())
            throw new Exception();
        return rear?.val;
    }

    /* 返回数组用于打印 */
    public int?[] ToArray() {
        ListNode? node = front;
        int?[] res = new int?[Size()];
        for (int i = 0; i < res.Length; i++) {
            res[i] = node?.val;
            node = node?.next;
        }

        return res;
    }
}
```

### 基于数组的实现

与基于数组实现队列类似，我们也可以使用环形数组来实现双向队列。

=== "ArrayDeque"
    ![ArrayDeque](double_ended_queue_6.png)
=== "push_last"
    ![push_last](double_ended_queue_7.png)
=== "push_first"
    ![push_first](double_ended_queue_8.png)
=== "pop_last"
    ![pop_last](double_ended_queue_9.png)
=== "pop_first"
    ![pop_first](double_ended_queue_10.png)

在队列的实现基础上，仅需增加“队首入队”和“队尾出队”的方法：

```C#
/* 基于环形数组实现的双向队列 */
class ArrayDeque {
    int[] nums;  // 用于存储双向队列元素的数组
    int front;   // 队首指针，指向队首元素
    int queSize; // 双向队列长度

    /* 构造方法 */
    public ArrayDeque(int capacity) {
        nums = new int[capacity];
        front = queSize = 0;
    }

    /* 获取双向队列的容量 */
    int Capacity() {
        return nums.Length;
    }

    /* 获取双向队列的长度 */
    public int Size() {
        return queSize;
    }

    /* 判断双向队列是否为空 */
    public bool IsEmpty() {
        return queSize == 0;
    }

    /* 计算环形数组索引 */
    int Index(int i) {
        // 通过取余操作实现数组首尾相连
        // 当 i 越过数组尾部后，回到头部
        // 当 i 越过数组头部后，回到尾部
        return (i + Capacity()) % Capacity();
    }

    /* 队首入队 */
    public void PushFirst(int num) {
        if (queSize == Capacity()) {
            Console.WriteLine("双向队列已满");
            return;
        }
        // 队首指针向左移动一位
        // 通过取余操作实现 front 越过数组头部后回到尾部
        front = Index(front - 1);
        // 将 num 添加至队首
        nums[front] = num;
        queSize++;
    }

    /* 队尾入队 */
    public void PushLast(int num) {
        if (queSize == Capacity()) {
            Console.WriteLine("双向队列已满");
            return;
        }
        // 计算队尾指针，指向队尾索引 + 1
        int rear = Index(front + queSize);
        // 将 num 添加至队尾
        nums[rear] = num;
        queSize++;
    }

    /* 队首出队 */
    public int PopFirst() {
        int num = PeekFirst();
        // 队首指针向后移动一位
        front = Index(front + 1);
        queSize--;
        return num;
    }

    /* 队尾出队 */
    public int PopLast() {
        int num = PeekLast();
        queSize--;
        return num;
    }

    /* 访问队首元素 */
    public int PeekFirst() {
        if (IsEmpty()) {
            throw new InvalidOperationException();
        }
        return nums[front];
    }

    /* 访问队尾元素 */
    public int PeekLast() {
        if (IsEmpty()) {
            throw new InvalidOperationException();
        }
        // 计算尾元素索引
        int last = Index(front + queSize - 1);
        return nums[last];
    }

    /* 返回数组用于打印 */
    public int[] ToArray() {
        // 仅转换有效长度范围内的列表元素
        int[] res = new int[queSize];
        for (int i = 0, j = front; i < queSize; i++, j++) {
            res[i] = nums[Index(j)];
        }
        return res;
    }
}
```


## 典型应用

双向队列兼具栈与队列的逻辑，**因此它可以实现这两者的所有应用场景，同时提供更高的自由度**。

我们知道，软件的“撤销”功能通常使用栈来实现：系统将每次更改操作 push 到栈中，然后通过 pop 实现撤销。然而，考虑到系统资源的限制，软件通常会限制撤销的步数（例如仅允许保存 $50$ 步）。当栈的长度超过 $50$ 时，软件需要在栈底（队首）执行删除操作。但栈无法实现该功能，此时就需要使用双向队列来替代栈。请注意， “撤销” 的核心逻辑仍然遵循栈的先入后出原则，只是双向队列能够更加灵活地实现一些额外逻辑。