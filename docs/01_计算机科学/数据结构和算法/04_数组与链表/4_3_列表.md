列表（list）是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。

- 链表天然可以看作一个列表，其支持元素增删查改操作，并且可以灵活动态扩容。
- 数组也支持元素增删查改，但由于其长度不可变，因此只能看作一个具有长度限制的列表。

当使用数组实现列表时，**长度不可变的性质会导致列表的实用性降低**。这是因为我们通常无法事先确定需要存储多少数据，从而难以选择合适的列表长度。若长度过小，则很可能无法满足使用需求；若长度过大，则会造成内存空间浪费。

为解决此问题，我们可以使用**动态数组（dynamic array）**来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。

实际上，许多编程语言中的标准库提供的列表是基于动态数组实现的，比如 C# 的 List 和 C++ 的 vector 等。我们下面讨论的 “列表” 请视为 “动态数组” 。

## 常用操作

### 1. 初始化

```C#
/* 初始化列表 */
// 无初始值
List<int> nums1 = [];
// 有初始值
int[] numbers = [1, 3, 2, 5, 4];
List<int> nums = [.. numbers];
```

### 2. 访问元素

列表本质上是数组，因此可以在 $O(1)$ 时间内访问和更新元素，效率很高。

```C#
/* 访问元素 */
int num = nums[1];  // 访问索引 1 处的元素

/* 更新元素 */
nums[1] = 0;  // 将索引 1 处的元素更新为 0
```

### 3. 插入与删除元素

本质上和数组相同，只是封装了接口：

```C#
/* 清空列表 */
nums.Clear();

/* 在尾部添加元素 */
nums.Add(1);
nums.Add(3);
nums.Add(2);
nums.Add(5);
nums.Add(4);

/* 在中间插入元素 */
nums.Insert(3, 6);  // 在索引 3 处插入数字 6

/* 删除元素 */
nums.RemoveAt(3);  // 删除索引 3 处的元素
```

### 4. 遍历列表

```C#
/* 通过索引遍历列表 */
int count = 0;
for (int i = 0; i < nums.Count; i++) {
    count += nums[i];
}

/* 直接遍历列表元素 */
count = 0;
foreach (int num in nums) {
    count += num;
}
```

### 5. 拼接列表

```C#
/* 拼接两个列表 */
List<int> nums1 = [6, 8, 7, 10, 9];
nums.AddRange(nums1);  // 将列表 nums1 拼接到 nums 之后
```

### 6. 排序列表

完成列表排序后，我们便可以使用在数组类算法题中经常考查的 “二分查找” 和 “双指针” 算法。

```C#
/* 排序列表 */
nums.Sort(); // 排序后，列表元素从小到大排列
```

## 列表的实现

我们来用 C# 实现一个建议列表，有三个重点设计：

- **初始容量**：选取一个合理的数组初始容量。在本示例中，我们选择 10 作为初始容量。
- **数量记录**：声明一个变量 size ，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。
- **扩容机制**：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。在本示例中，我们规定每次将数组扩容至之前的 2 倍。

```C#
/* 列表类 */
class MyList {
    private int[] arr;           // 数组（存储列表元素）
    private int arrCapacity = 10;    // 列表容量
    private int arrSize = 0;         // 列表长度（当前元素数量）
    private readonly int extendRatio = 2;  // 每次列表扩容的倍数

    /* 构造方法 */
    public MyList() {
        arr = new int[arrCapacity];
    }

    /* 获取列表长度（当前元素数量）*/
    public int Size() {
        return arrSize;
    }

    /* 获取列表容量 */
    public int Capacity() {
        return arrCapacity;
    }

    /* 访问元素 */
    public int Get(int index) {
        // 索引如果越界，则抛出异常，下同
        if (index < 0 || index >= arrSize)
            throw new IndexOutOfRangeException("索引越界");
        return arr[index];
    }

    /* 更新元素 */
    public void Set(int index, int num) {
        if (index < 0 || index >= arrSize)
            throw new IndexOutOfRangeException("索引越界");
        arr[index] = num;
    }

    /* 在尾部添加元素 */
    public void Add(int num) {
        // 元素数量超出容量时，触发扩容机制
        if (arrSize == arrCapacity)
            ExtendCapacity();
        arr[arrSize] = num;
        // 更新元素数量
        arrSize++;
    }

    /* 在中间插入元素 */
    public void Insert(int index, int num) {
        if (index < 0 || index >= arrSize)
            throw new IndexOutOfRangeException("索引越界");
        // 元素数量超出容量时，触发扩容机制
        if (arrSize == arrCapacity)
            ExtendCapacity();
        // 将索引 index 以及之后的元素都向后移动一位
        for (int j = arrSize - 1; j >= index; j--) {
            arr[j + 1] = arr[j];
        }
        arr[index] = num;
        // 更新元素数量
        arrSize++;
    }

    /* 删除元素 */
    public int Remove(int index) {
        if (index < 0 || index >= arrSize)
            throw new IndexOutOfRangeException("索引越界");
        int num = arr[index];
        // 将将索引 index 之后的元素都向前移动一位
        for (int j = index; j < arrSize - 1; j++) {
            arr[j] = arr[j + 1];
        }
        // 更新元素数量
        arrSize--;
        // 返回被删除的元素
        return num;
    }

    /* 列表扩容 */
    public void ExtendCapacity() {
        // 新建一个长度为 arrCapacity * extendRatio 的数组，并将原数组复制到新数组
        Array.Resize(ref arr, arrCapacity * extendRatio);
        // 更新列表容量
        arrCapacity = arr.Length;
    }

    /* 将列表转换为数组 */
    public int[] ToArray() {
        // 仅转换有效长度范围内的列表元素
        int[] arr = new int[arrSize];
        for (int i = 0; i < arrSize; i++) {
            arr[i] = Get(i);
        }
        return arr;
    }
}
```