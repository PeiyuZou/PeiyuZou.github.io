## 数组分配在栈 or 堆？

这个问题不同语言有不同的结果。

对于 C++ 来说，静态数组（编译时确定大小）和 std:array 分配在栈上，动态数组（new[]）和 std::vector 分配在堆上。

对于 C# 来说，都是分配在堆上，但是提供了关键字 stackalloc 在栈上分配：

```C#
Span<int> stackSpan = stackalloc int[100];
```

## 数组存储在栈上和存储在堆上，对时间效率和空间效率是否有影响？

存储在栈上和堆上的数组都被存储在连续内存空间内，数据操作效率基本一致。然而，栈和堆具有各自的特点，从而导致以下不同点。

- 分配和释放效率：栈是一块较小的内存，分配由编译器自动完成；而堆内存相对更大，可以在代码中动态分配，更容易碎片化。因此，堆上的分配和释放操作通常比栈上的慢。
- 大小限制：栈内存相对较小，堆的大小一般受限于可用内存。因此堆更加适合存储大型数组。
- 灵活性：栈上的数组的大小需要在编译时确定，而堆上的数组的大小可以在运行时动态确定。

## 为什么数组要求相同类型的元素，而在链表中却没有强调相同类型呢？

链表由节点组成，通过指针连接，所以各个节点可以存储不同类型的数据。

而数组必须是相同类型，这样才能通过计算偏移量来获取对应元素位置。例如，数组同时包含 int 和 long 两种类型，单个元素分别占用 4 字节和 8 字节 ，此时就不能用公式计算偏移量了，因为数组中包含了两种 “元素长度” 。

## 在列表末尾添加元素是否时时刻刻都为 $O(1)$ ？

如果添加元素时超出列表长度，则需要先扩容列表再添加。系统会申请一块新的内存，并将原列表的所有元素搬运过去，这时候时间复杂度就会是 $O(n)$ 。

## 列表的内存浪费如何避免？

我们可以通过预先确定列表的最大长度来在初始化时给列表分配一个固定长度的空间并且确保在生命周期内不会扩容，这样可以尽量减少内存空间的浪费，同时也避免了扩容带来的时间和空间的开销。