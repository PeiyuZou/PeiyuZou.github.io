变量和函数的作用域，和其他高级语言不太一样，在 C 中有特殊的规则

## 变量的作用域

变量分两种：

- 局部变量
- 外部变量

界定是局部还是外部，单纯看变量是定义在函数的内部还是外部：

=== "局部变量"

    ``` c
    #include <stdio.h>

    int main() {
      void localparams(int x);
      localparams();
      return 0;
    }

    void localparams(int x) // 形参也是局部变量
    {
      int a = 999; // 定义在函数内部的，就是局部变量
    }
    ```

=== "外部变量"

    ``` c
    #include <stdio.h>

    int a = 999; // 定义在函数外部的，就是外部变量

    int main() {
      return 0;
    }
    ```

### 局部变量

**局部变量的作用域均限于函数内！**局部变量可以分为 3 类

#### 1. 自动变量

大多数局部变量其实都是自动变量，只是书写时auto关键字是缺省的。

`auto int a = 3;` 等价于 `int a = 3;`

#### 2. 静态局部变量

静态局部变量通过 `static` 关键字修饰，它们存储在**静态存储区**，在程序运行期间都不会释放，即便它是**局部的**。因此它们的值会保持上一次修改的状态。C 语言的 static 和 C# 等语言的很不一样，需要注意。

在函数调用完成后，静态局部变量并没有释放，但它的作用域仍然在声明它的函数内部，也就是函数内才可以访问它，和它有没有释放无关。

``` c title="static local variables"
int counter()
{
    static int a = 0;
    ++a;
    return a;
}
```

这个函数访问 10 次，其最后一次的结果将是 10

#### 3. 寄存器变量

寄存器变量通过 `register` 关键字修饰，它告知编译器该变量使用频率较高，应该放在机器的寄存器中。但编译器会根据实际情况选择忽略它，比如过量的或者不支持的寄存器变量声明。所以过量声明并没有什么坏处，最终生成的代码是否会将其放入寄存器，全由编译器决定。现在这种声明的必要性也不大，很多编译系统甚至能够识别使用频繁的变量，自动将这些变量放入寄存器中，而不需要我们手动指定。

``` c title="register variables"
void fun()
{
    register int a;
}
```

### 外部变量

外部变量的作用域默认从声明它的文件位置开始，直到文件末尾结束，但可以通过 `extern` 关键字改变作用域：

=== "默认作用域"

    ``` c
    #include <stdio.h>

    int main()
    {
        int counter();
        for(int i = 0; i < 10; i++)
            printf("%d\n", counter());
        printf("Hello, World\n");
    }

    int b = 1;              // 作用域开始

    int counter()
    {
        static int a = 0;
        ++a;
        return a + b;
    }                       // 作用域结束
    ```

=== "作用域提前（一）"

    ``` c
    #include <stdio.h>

    int main()
    {
        int counter();
        int counter2();
        int counter3();
        for(int i = 0; i < 10; i++)
            printf("%d\n", counter());
        for(int i = 0; i < 10; i++)
            printf("%d\n", counter2());
        for(int i = 0; i < 10; i++)
            printf("%d\n", counter3());
        printf("Hello, World\n");
    }
    extern int b;          // 作用域开始

    int counter2()
    {
        ++b;
        return b;
    }

    int counter3()
    {
        ++b;
        return b;
    }

    int b = 1;

    int counter()
    {
        static int a = 0;
        ++a;
        return a + b;
    }                      // 作用域结束
    ```

=== "作用域提前（二）"

    ``` c
    #include <stdio.h>

    int main()
    {
        int counter();
        int counter2();
        int counter3();
        for(int i = 0; i < 10; i++)
            printf("%d\n", counter());
        for(int i = 0; i < 10; i++)
            printf("%d\n", counter2());
        for(int i = 0; i < 10; i++)
            printf("%d\n", counter3());
        printf("Hello, World\n");
    }

    int counter2()
    {
        extern int b;          // 作用域开始
        return b;              // 作用域结束
    }

    int counter3()
    {
        ++b;                   // 编译不通过
        return b;
    }

    int b = 1;

    int counter()              // 作用域开始
    {
        static int a = 0;
        ++a;
        return a + b;
    }                          // 作用域结束
    ```
=== "其他文件中使用"

    ``` c
    // file2.c
    extern b;                  // 作用域开始
    int fun()
    {
        int c = 0;
        return c + b;
    }                          // 作用域结束
    ```

#### 静态外部变量

用 `static` 修饰的外部变量称静态外部变量，但需要注意：

- 所有外部变量，都是存储在静态存储区中的，和是否是 `static` 修饰无关
- 静态外部变量的真正作用是对其他文件隐藏该外部变量（不希望被其他文件引用）
- 不同文件中的静态外部变量可以重名，互不干扰

!!! warning "注意static修饰下的变量"
    在 C 中，static 修饰的静态局部变量和静态外部变量，两者的特性完全不同，需要甄别！

## 函数的作用域

函数的作用域特性比较像外部变量，也是默认从声明处开始，文件末尾结束。

### 外部函数

一个函数默认就是外部函数，`extern` 关键字是缺省的。`extern int fun(int a, int b)` 等价于 `int fun(int a, int b)`

如果需要在默认作用域外访问（其他文件中也适用），在使用的地方要要加上 `extern` 关键字进行声明。

### 内部函数

和静态外部变量一样，加上 `static` 关键字修饰，其他文件便不能访问。因此内部函数又叫静态函数：`static int fun(int a, int b)`

在 C 语言中，“静态”一词的特性和其他语言完全不一样，所以单独开篇记一下。