## 闭包问题

```C#
class A
{
    public B b;
}

class B
{
    public string Name;

    public override string ToString()
    {
        return Name.ToString();
    }
}

class Program1
{
    static void Main()
    {
        var a = new A();
        var b1 = new B() { Name = "B1" };
        var b2 = new B() { Name = "B2" };
        var b3 = new B() { Name = "B3" };
        a.b = b1;
        var c = a.b;
        Action closure = () =>
        {
            Console.WriteLine(c.ToString());
            Console.WriteLine(a.b.ToString());
            Console.WriteLine();
        };
        closure();
        a.b = b2;
        closure();
        a.b = b3;
        closure();
    }
}
```

这是一段包含闭包的测试代码，它的打印结果是：

```
B1
B1

B1
B2

B1
B3
```

我们来看它生成的 IL 代码，以此来了解闭包对作用域外的局部变量，是如何处理的：

```IL
A..ctor:
IL_0000:  ldarg.0     // 将第一个参数（this引用）压入栈
IL_0001:  call        System.Object..ctor  // 调用Object的构造函数
IL_0006:  nop         // 空操作（可能是调试信息）
IL_0007:  ret         // 返回

B.ToString:
IL_0000:  nop         // 空操作
IL_0001:  ldarg.0     // 将this引用压入栈
IL_0002:  ldfld       UserQuery+B.Name  // 加载B类的Name字段到栈
IL_0007:  callvirt    System.Object.ToString  // 虚调用ToString方法
IL_000C:  stloc.0     // 将结果存储到本地变量0
IL_000D:  br.s        IL_000F  // 短跳转到IL_000F
IL_000F:  ldloc.0     // 从本地变量0加载值到栈
IL_0010:  ret         // 返回栈顶值

B..ctor:
IL_0000:  ldarg.0     // 将this引用压入栈
IL_0001:  call        System.Object..ctor  // 调用Object构造函数
IL_0006:  nop         // 空操作
IL_0007:  ret         // 返回

Program1.Main:
IL_0000:  newobj      UserQuery+Program1+<>c__DisplayClass0_0..ctor  // 创建闭包类实例
IL_0005:  stloc.0     // 存储到本地变量0 (CS$<>8__locals0)
IL_0006:  nop         // 空操作
IL_0007:  ldloc.0     // 加载闭包类实例
IL_0008:  newobj      UserQuery+A..ctor  // 创建A类实例
IL_000D:  stfld       UserQuery+Program1+<>c__DisplayClass0_0.a  // 将A实例存储到闭包的a字段
IL_0012:  newobj      UserQuery+B..ctor  // 创建B类实例
IL_0017:  dup         // 复制栈顶值
IL_0018:  ldstr       "B1"  // 加载字符串"B1"
IL_001D:  stfld       UserQuery+B.Name  // 设置B.Name字段为"B1"
IL_0022:  stloc.1     // 存储到本地变量1 (b1)
IL_0023:  newobj      UserQuery+B..ctor  // 创建另一个B类实例
IL_0028:  dup         // 复制栈顶值
IL_0029:  ldstr       "B2"  // 加载字符串"B2"
IL_002E:  stfld       UserQuery+B.Name  // 设置B.Name字段为"B2"
IL_0033:  stloc.2     // 存储到本地变量2 (b2)
IL_0034:  newobj      UserQuery+B..ctor  // 创建第三个B类实例
IL_0039:  dup         // 复制栈顶值
IL_003A:  ldstr       "B3"  // 加载字符串"B3"
IL_003F:  stfld       UserQuery+B.Name  // 设置B.Name字段为"B3"
IL_0044:  stloc.3     // 存储到本地变量3 (b3)
IL_0045:  ldloc.0     // 加载闭包类实例
IL_0046:  ldfld       UserQuery+Program1+<>c__DisplayClass0_0.a  // 获取闭包的a字段
IL_004B:  ldloc.1     // 加载变量b1
IL_004C:  stfld       UserQuery+A.b  // 设置a.b = b1
IL_0051:  ldloc.0     // 加载闭包类实例
IL_0052:  ldloc.0     // 再次加载闭包类实例
IL_0053:  ldfld       UserQuery+Program1+<>c__DisplayClass0_0.a  // 获取闭包的a字段
IL_0058:  ldfld       UserQuery+A.b  // 获取a.b字段
IL_005D:  stfld       UserQuery+Program1+<>c__DisplayClass0_0.c  // 设置闭包的c字段 = a.b
IL_0062:  ldloc.0     // 加载闭包类实例
IL_0063:  ldftn       UserQuery+Program1+<>c__DisplayClass0_0.<Main>b__0  // 加载方法指针
IL_0069:  newobj      System.Action..ctor  // 创建Action委托
IL_006E:  stloc.s     04  // 存储到本地变量4 (closure)
IL_0070:  ldloc.s     04  // 加载closure
IL_0072:  callvirt    System.Action.Invoke  // 调用Action（第一次执行）
IL_0077:  nop         // 空操作
IL_0078:  ldloc.0     // 加载闭包类实例
IL_0079:  ldfld       UserQuery+Program1+<>c__DisplayClass0_0.a  // 获取闭包的a字段
IL_007E:  ldloc.2     // 加载变量b2
IL_007F:  stfld       UserQuery+A.b  // 设置a.b = b2
IL_0084:  ldloc.s     04  // 加载closure
IL_0086:  callvirt    System.Action.Invoke  // 调用Action（第二次执行）
IL_008B:  nop         // 空操作
IL_008C:  ldloc.0     // 加载闭包类实例
IL_008D:  ldfld       UserQuery+Program1+<>c__DisplayClass0_0.a  // 获取闭包的a字段
IL_0092:  ldloc.3     // 加载变量b3
IL_0093:  stfld       UserQuery+A.b  // 设置a.b = b3
IL_0098:  ldloc.s     04  // 加载closure
IL_009A:  callvirt    System.Action.Invoke  // 调用Action（第三次执行）
IL_009F:  nop         // 空操作
IL_00A0:  ret         // 返回

Program1..ctor:
IL_0000:  ldarg.0     // 将this引用压入栈
IL_0001:  call        System.Object..ctor  // 调用Object构造函数
IL_0006:  nop         // 空操作
IL_0007:  ret         // 返回

<>c__DisplayClass0_0.<Main>b__0:
IL_0000:  nop         // 空操作
IL_0001:  ldarg.0     // 将this引用压入栈
IL_0002:  ldfld       UserQuery+Program1+<>c__DisplayClass0_0.c  // 获取闭包的c字段
IL_0007:  callvirt    System.Object.ToString  // 调用ToString方法
IL_000C:  call        System.Console.WriteLine  // 调用Console.WriteLine输出c字段
IL_0011:  nop         // 空操作
IL_0012:  ldarg.0     // 将this引用压入栈
IL_0013:  ldfld       UserQuery+Program1+<>c__DisplayClass0_0.a  // 获取闭包的a字段
IL_0018:  ldfld       UserQuery+A.b  // 获取a.b字段
IL_001D:  callvirt    System.Object.ToString  // 调用ToString方法
IL_0022:  call        System.Console.WriteLine  // 调用Console.WriteLine输出a.b字段
IL_0027:  nop         // 空操作
IL_0028:  call        System.Console.WriteLine  // 调用Console.WriteLine输出空行
IL_002D:  nop         // 空操作
IL_002E:  ret         // 返回

<>c__DisplayClass0_0..ctor:
IL_0000:  ldarg.0     // 将this引用压入栈
IL_0001:  call        System.Object..ctor  // 调用Object构造函数
IL_0006:  nop         // 空操作
IL_0007:  ret         // 返回
```

最后两个 IL 代码块 `<>c__DisplayClass0_0.<Main>b__0` 和 `<>c__DisplayClass0_0..ctor` 表明，C# 在编译 IL 时，为闭包生成了一个匿名的 Class ，同时闭包被构建为该类的一个实例，捕获了变量 c 当时指向的内存地址，也就是 b1 的内存地址。在后续改变 a.b 指向的内存地址时，并不会影响闭包中的变量，关键代码是如下：

```
Program1.Main:
...
IL_005D:  stfld       UserQuery+Program1+<>c__DisplayClass0_0.c  // 设置闭包的c字段 = a.b
...

<>c__DisplayClass0_0.<Main>b__0:
...
IL_0002:  ldfld       UserQuery+Program1+<>c__DisplayClass0_0.c  // 获取闭包的c字段
...
```

## 闭包和匿名函数

### 匿名函数（Anonymous Function）

**定义：** 匿名函数是没有名字的函数，在定义的地方直接使用。

**特点：**
- 没有函数名
- 通常用于一次性使用
- 语法简洁
- 可以作为参数传递

**C# 中的匿名函数形式：**
```csharp
// 匿名方法（C# 2.0）
delegate(int x) { return x * 2; }

// Lambda表达式（C# 3.0+）也是一种匿名函数
x => x * 2
(x, y) => x + y
() => Console.WriteLine("Hello")
```

### 闭包（Closure）

**定义：** 闭包是函数与其周围状态（词法环境）的引用捆绑在一起的组合。换句话说，闭包让你可以在函数内部访问外部函数的作用域。

**特点：**
- 可以访问外部作用域的变量
- 这些变量在外部函数执行完后仍然存在
- 形成了一个封闭的环境
- 变量的生命周期被延长

### 核心区别

| 方面 | 匿名函数 | 闭包 |
|------|----------|------|
| **本质** | 语法特性（没有名字的函数） | 行为特性（捕获外部变量） |
| **关注点** | 函数的定义方式 | 变量的作用域和生命周期 |
| **实现** | 编译器生成普通方法 | 编译器生成额外的类来保存变量 |
| **性能** | 轻量级 | 可能有额外的内存开销 |

### 实际例子对比

#### 1. 纯匿名函数（无闭包）

```csharp
Func<int, int> multiply = x => x * 2;  // 匿名函数，但没有闭包
```

编译后的IL相对简单，不需要额外的类。

#### 2. 匿名函数 + 闭包

```csharp
int factor = 10;
Func<int, int> multiply = x => x * factor;  // 匿名函数 + 闭包
```

这里既有匿名函数（Lambda表达式），又有闭包（捕获了外部变量`factor`）。

#### 3. 从刚才的IL代码分析

```csharp
var a = new A();
// ... 创建b1, b2, b3 ...

Action closure = () => {
    Console.WriteLine(c);        // 闭包：捕获了变量c
    Console.WriteLine(a.b);      // 闭包：捕获了变量a
    Console.WriteLine();
};
```

**这里发生了什么：**

- `() => { ... }` 是匿名函数（Lambda表达式）
- 但它捕获了外部变量`c`和`a`，所以形成了闭包
- 编译器生成了`<>c__DisplayClass0_0`类来保存这些捕获的变量

### 编译器实现机制

#### 匿名函数（无闭包）

```csharp
// 原始代码
Action simple = () => Console.WriteLine("Hello");

// 编译器生成类似这样的代码
private static void <Main>b__0() {
    Console.WriteLine("Hello");
}
```

#### 闭包
```csharp
// 原始代码
string message = "Hello";
Action closure = () => Console.WriteLine(message);

// 编译器生成类似这样的代码
private class <>c__DisplayClass0_0 {
    public string message;
    public void <Main>b__0() {
        Console.WriteLine(message);
    }
}
```

### 实际应用场景

#### 匿名函数适用场景：

```csharp
// 事件处理
button.Click += (sender, e) => MessageBox.Show("Clicked!");

// LINQ
var result = numbers.Where(x => x > 5).Select(x => x * 2);

// 回调函数
Task.Run(() => DoSomething());
```

#### 闭包适用场景：

```csharp
// 工厂函数
Func<int, int> CreateMultiplier(int factor) {
    return x => x * factor;  // 闭包捕获factor
}

// 状态保持
int counter = 0;
Action increment = () => counter++;  // 闭包捕获counter

// 配置保存
string connectionString = GetConnectionString();
Action<string> saveData = data => {
    // 闭包捕获connectionString
    SaveToDatabase(connectionString, data);
};
```

### 总结

- **匿名函数** 是语法糖，让代码更简洁
- **闭包** 是功能特性，让函数能够访问外部变量
- 它们经常同时出现，但是独立的概念
- 你可以有：
  - 匿名函数但无闭包
  - 有名函数但有闭包
  - 匿名函数 + 闭包（最常见）

在刚才的IL代码中，我们看到的是匿名函数和闭包的组合：编译器为闭包生成了专门的类来保存捕获的变量，这就是为什么会有`<>c__DisplayClass0_0`这样的类存在。