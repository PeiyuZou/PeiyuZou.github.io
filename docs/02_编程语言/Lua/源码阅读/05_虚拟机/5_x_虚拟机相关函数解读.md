## luaL_loadfilex

```C

/*
** 用于加载 Lua 脚本文件或从标准输入读取脚本内容，并将其编译为 Lua 的字节码
** 输入：
**     L - 当前状态机
**     filename - 脚本文件名称
**     mode - 指定加载模式（t - 文本，b - 二进制，bt or NULL - 根据首字符自动检查）
** 输出：
**     编译结果的状态（LUA_OK等）
*/
LUALIB_API int luaL_loadfilex (lua_State *L, const char *filename,
                                             const char *mode) {
  LoadF lf;
  int status, readstatus;
  int c;

  // 得到文件名在栈上的位置
  int fnameindex = lua_gettop(L) + 1;  /* index of filename on the stack */

  // 处理filename参数
  // - 如果 filename 为 NULL，则从标准输入加载脚本并在栈顶压入 =stdin（标识输入来源）
  // - 如果提供了 filename，尝试以只读模式打开文件。如果失败，则调用 errfile 报错
  if (filename == NULL) {
    lua_pushliteral(L, "=stdin");
    lf.f = stdin;
  }
  else {
    lua_pushfstring(L, "@%s", filename);
    lf.f = fopen(filename, "r");
    if (lf.f == NULL) return errfile(L, "open", fnameindex);
  }

  // 跳过文件中的注释
  // - 调用 skipcomment 跳过文件中的注释部分。c 保存第一个非注释字符
  // - 如果跳过注释后需要调整行号（如文件首行为注释），将换行符 \n 添加到缓冲区
  if (skipcomment(&lf, &c))  /* read initial portion */
    lf.buff[lf.n++] = '\n';  /* add line to correct line numbers */

  // 如果是二进制文件，重新以二进制模式打开
  // 如果文件的第一个字符与 LUA_SIGNATURE 匹配，表明可能是 Lua 的预编译二进制文件
  if (c == LUA_SIGNATURE[0] && filename) {  /* binary file? */
    lf.f = freopen(filename, "rb", lf.f);  /* reopen in binary mode */
    if (lf.f == NULL) return errfile(L, "reopen", fnameindex);
    skipcomment(&lf, &c);  /* re-read initial portion */
  }

  // 如果第一个字符是非空字符，将其存入缓冲区，作为流的第一个有效字符
  if (c != EOF)
    lf.buff[lf.n++] = c;  /* 'c' is the first character of the stream */

  // 调用 lua_load 编译文件内容为 Lua 字节码
  // - 参数 getF 是一个回调函数，从 lf 中读取内容并提供给 lua_load
  status = lua_load(L, getF, &lf, lua_tostring(L, -1), mode);

  // 使用 ferror 检查文件是否读取错误
  // - 如果有错误，将 Lua 栈恢复到调用此函数之前的状态，并返回错误码
  readstatus = ferror(lf.f);
  if (filename) fclose(lf.f);  /* close file (even in case of errors) */
  if (readstatus) {
    lua_settop(L, fnameindex);  /* ignore results from 'lua_load' */
    return errfile(L, "read", fnameindex);
  }

  // 清理和返回
  // - 在成功加载文件后，移除栈上的文件名信息，保持栈的整洁
  lua_remove(L, fnameindex);
  return status;
}
```

## lua_load

```C
/*
** 在编译解释阶段，负责两个事：
**     1.在执行编译前加锁确保线程安全，并初始化一个文件读取流
**     2.在编译完成后，给编译结果设置全局表作为第一个上值
** 输入：
**     L - 当前状态机
**     reader - 回调函数，用于逐步读取代码块的内容
**     data - 传递给 reader 的用户数据，通常是文件流或内存中的字符串，在 luaL_loadfilex 传过来的是指定文件的文件流
**     chunkname - 代码块的名字，用于错误提示
**     mode - 编译模式，文本还是二进制
** 输出：
**     成功时返回 LUA_OK，并将编译后的 Lua 函数（LClosure）压入栈顶
**     失败时返回错误代码，并将错误信息压入栈顶
*/
LUA_API int lua_load (lua_State *L, lua_Reader reader, void *data,
                      const char *chunkname, const char *mode) {
  ZIO z;
  int status;

  // 加锁，确保线程安全
  lua_lock(L);

  // 缺省 chunkname
  if (!chunkname) chunkname = "?";

  // 初始化 ZIO 流
  // - z 是一个 ZIO 结构，它封装了读取代码块内容的逻辑
  // - 将 reader 和 data 指定给这个 ZIO，确保用 reader 指定的方式读取 data 的文件内容
  luaZ_init(L, &z, reader, data);

  // 调用解析器
  // - 此函数负责对代码块的解析和编译，它运行在一个受保护的环境中，可以捕获并处理运行时错误
  // - 解析完成后，将生成的 Lua 函数（LClosure）压入栈顶
  status = luaD_protectedparser(L, &z, chunkname, mode);

  // 设置全局环境
  // - L->top - 1 指向的是上一步生成的放在栈顶的 Lua 函数对象
  // - s2v 理解为 StackValue to TValue，它将一个栈元素转化为通用的 TValue 结构体
  // - clLvalue 进一步将 TValue 转化为 LClosure (Lua闭包)
  // - 如果有上值，获取全局表并将全局表设置为该函数的第一个上值
  // - luaC_barrier 确保垃圾回收的正确性，维护引用关系
  if (status == LUA_OK) {  /* no errors? */
    LClosure *f = clLvalue(s2v(L->top - 1));  /* get newly created function */
    if (f->nupvalues >= 1) {  /* does it have an upvalue? */
      /* get global table from registry */
      const TValue *gt = getGtable(L);
      /* set global table as 1st upvalue of 'f' (may be LUA_ENV) */
      setobj(L, f->upvals[0]->v, gt);
      luaC_barrier(L, f->upvals[0], gt);
    }
  }

  // 释放锁并返回结果
  lua_unlock(L);
  return status;
}
```

## f_parser

```C
/*
** lua_load 函数工作流程的一部分
** 输入：
**     L - 当前状态机
**     ud - 一个通用的用户数据指针，在这里是一个指向 SParser 结构体的指针，包含了解析需要的信息
** 输出：
**     没有返回，自动检查文件流是二进制还是文本，转发调用 luaU_undump 和 luaY_parser
*/
static void f_parser (lua_State *L, void *ud) {
  LClosure *cl;

  // 将 ud 强制转换为 SParser 指针
  // - SParser 包含解析时所需的输入流（z）、缓冲区（buff）、动态数据结构（dyd）以及源文件的名字（name）
  struct SParser *p = cast(struct SParser *, ud);

  // 检查文件流类型，转发调用解析函数
  // - 二进制调用 luaU_undump
  // - 文本源码调用 luaY_parser
  int c = zgetc(p->z);  /* read first character */
  if (c == LUA_SIGNATURE[0]) {
    checkmode(L, p->mode, "binary");
    cl = luaU_undump(L, p->z, p->name);
  }
  else {
    checkmode(L, p->mode, "text");
    cl = luaY_parser(L, p->z, &p->buff, &p->dyd, p->name, c);
  }

  // 一致性校验，校验生成的闭包的实际 upvalues 数量是否等于函数原型中定义的数量
  // - nupvalues: 闭包中实际的 upvalues 数量
  // - sizeupvalues: 函数原型中声明的 upvalues 数量
  lua_assert(cl->nupvalues == cl->p->sizeupvalues);

  // 初始化闭包的 Upvalues（外部变量的引用）
  // - Upvalues 是闭包执行环境的重要组成部分，确保函数可以正确访问外部变量
  luaF_initupvals(L, cl);
}
```

## luaY_parser

```C
/*
** lua_load 函数工作流程的核心部分，将文本流源码解析生成可执行的函数闭包
** 输入：
**     L - 当前状态机
**     z - 输入流对象，封装了输入数据（源码的文本流）
**     buff - 动态缓冲区，用于存储解析过程中的临时数据
**     dyd - 动态数据结构，包含作用域变量、标签、跳转等动态信息
**     name - 源文件的名称，用于生成调试信息
**     firstchar - 输入流的第一个字符，通常在调用时已经读取
** 输出：
**     返回生成的函数闭包（注意词法分析器的表出栈了，函数闭包仍然在栈上）
*/
LClosure *luaY_parser (lua_State *L, ZIO *z, Mbuffer *buff,
                       Dyndata *dyd, const char *name, int firstchar) {
  LexState lexstate;
  FuncState funcstate;

  // 创建主函数闭包
  // - 使用 luaF_newLclosure 创建一个 LClosure 对象。主闭包对应整个 Lua 源码文件的顶层函数
  // - 使用 setclLvalue2s 将闭包对象放置在 Lua 堆栈顶端，确保不会被垃圾回收器错误清理
  // - 增加堆栈顶指针，以存放闭包
  LClosure *cl = luaF_newLclosure(L, 1);  /* create main closure */
  setclLvalue2s(L, L->top, cl);  /* anchor it (to avoid being collected) */
  luaD_inctop(L);

  // 创建词法分析器的哈希表
  // - 为词法分析器创建一张哈希表，存储标识符等信息
  // - 将该表放置在 Lua 堆栈顶端，防止其被垃圾回收器清理
  lexstate.h = luaH_new(L);  /* create table for scanner */
  sethvalue2s(L, L->top, lexstate.h);  /* anchor it */
  luaD_inctop(L);

  // 初始化函数原型
  // - 创建函数原型: 调用 luaF_newproto 创建函数原型对象（Proto），并将其关联到闭包的 p 字段
  // - 对象屏障: 使用 luaC_objbarrier 确保垃圾回收器正确处理新创建对象之间的引用
  // - 设置调试信息: 将 source 字段设置为源码的名称
  funcstate.f = cl->p = luaF_newproto(L);
  luaC_objbarrier(L, cl, cl->p);
  funcstate.f->source = luaS_new(L, name);  /* create and anchor TString */
  luaC_objbarrier(L, funcstate.f, funcstate.f->source);

  // 初始化词法和语法分析器
  // - 关联动态数据: 将动态缓冲区和动态数据与词法分析器状态关联
  // - 清空动态数据: 重置动态作用域变量、跳转目标和标签的计数
  // - 设置输入流: 调用 luaX_setinput 初始化词法分析器，设置输入流 z、调试信息 source 和首字符 firstchar
  lexstate.buff = buff;
  lexstate.dyd = dyd;
  dyd->actvar.n = dyd->gt.n = dyd->label.n = 0;
  luaX_setinput(L, &lexstate, z, funcstate.f->source, firstchar);

  // 解析主函数
  // - 调用核心函数 mainfunc，解析整个 Lua 源码文件，构建语法树和函数原型
  mainfunc(&lexstate, &funcstate);

  // 检查解析一致性
  // - 检查语法解析是否正确结束：
  //     - 没有多余的嵌套函数
  //     - FuncState 中的 nups（upvalue 数量）为 1
  //     - LexState 中 fs（当前的函数状态）为 NULL
  // - 检查动态数据是否清空
  lua_assert(!funcstate.prev && funcstate.nups == 1 && !lexstate.fs);
  /* all scopes should be correctly finished */
  lua_assert(dyd->actvar.n == 0 && dyd->gt.n == 0 && dyd->label.n == 0);

  // 清理堆栈并返回
  L->top--;  /* remove scanner's table */
  return cl;  /* closure is on the stack, too */
}
```