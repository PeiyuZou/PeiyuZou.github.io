## luaL_newstate

从创建Lua虚拟机的函数 `luaL_newstate` 入手，这个函数可能是外部最常见的函数之一，它无需参数，返回一个指向 lua_State 类型内存地址的指针，在xLua中，它对应如下接口声明：

``` CSharp
// LuaDLL.cs

[DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)]
public static extern IntPtr luaL_newstate();
```

`luaL_newstate` 的源码片段如下，注意它的函数签名，和C#中声明动态链接库时的签名是一致的：

``` C
/* lauxlib.c */

LUALIB_API lua_State *luaL_newstate (void) {
  lua_State *L = lua_newstate(l_alloc, NULL);
  if (l_likely(L)) {
    lua_atpanic(L, &panic);
    lua_setwarnf(L, warnfoff, L);  /* default is warnings off */
  }
  return L;
}
```

分析这段源码：

### 1、LUALIB_API是什么？

跳转到定义，可以发现Lua对API的封装分为了以下三个等级：

- LUA_API：核心API
- LUALIB_API：辅助库函数
- LUAMOD_API：标准库开放函数

但实际的定义，后两者都同LUA_API（More often than not the libs go together with the core. 很多时候，库与核心结合在一起。）

在编译为动态链接库（DLL）时，可以通过宏定义决定该标记的函数是从DLL中导出还是从其他DLL中导入，非DLL的情况下，表示该符号标记的函数是外部的（`extern`）

``` C
/* luaconf.h */

/*
@@ LUA_API is a mark for all core API functions.
@@ LUALIB_API is a mark for all auxiliary library functions.
@@ LUAMOD_API is a mark for all standard library opening functions.
** CHANGE them if you need to define those functions in some special way.
** For instance, if you want to create one Windows DLL with the core and
** the libraries, you may want to use the following definition (define
** LUA_BUILD_AS_DLL to get it).
*/
#if defined(LUA_BUILD_AS_DLL)	/* { */    // 编译为动态链接库

#if defined(LUA_CORE) || defined(LUA_LIB)	/* { */
#define LUA_API __declspec(dllexport)      // 从DLL中导出
#else						/* }{ */
#define LUA_API __declspec(dllimport)      // 从其他DLL中导入
#endif						/* } */

#else				/* }{ */

#define LUA_API		extern                 // 非DLL的情况，等效于extern

#endif				/* } */


/*
** More often than not the libs go together with the core.
*/
#define LUALIB_API	LUA_API
#define LUAMOD_API	LUA_API
```

### 2、从 `lua_State *L = lua_newstate(l_alloc, NULL);` 得到的信息？

lua_newstate是核心库提供的函数，提供给外部创建一个虚拟机的接口，也就是说 `luaL_newstate` 本质上就是对 `lua_newstate` 做了一次封装，提供了一个更加方便和常用的版本。lua_newstate在本文后面会单独作一次分析，这里不赘述。

此外，`lua_newstate` 要求传入一个内存管理函数，这里使用的内部定义好的 `l_alloc` 函数，同样下文具体分析，先跳过。

### 3、`l_likely` 是何含义？

跳到定义：

``` C
/* luaconf.h */

/*
** macros to improve jump prediction, used mostly for error handling
** and debug facilities. (Some macros in the Lua API use these macros.
** Define LUA_NOBUILTIN if you do not want '__builtin_expect' in your
** code.)
*/
#if !defined(luai_likely)

#if defined(__GNUC__) && !defined(LUA_NOBUILTIN)
#define luai_likely(x)		(__builtin_expect(((x) != 0), 1))
#define luai_unlikely(x)	(__builtin_expect(((x) != 0), 0))
#else
#define luai_likely(x)		(x)
#define luai_unlikely(x)	(x)
#endif

#endif


#if defined(LUA_CORE) || defined(LUA_LIB)
/* shorter names for Lua's own use */
#define l_likely(x)	luai_likely(x)
#define l_unlikely(x)	luai_unlikely(x)
#endif
```

在编译时，`l_likely` 代表该条件分支的结果大概率为真，`l_unlikely` 代表大概率为假，类似于断言，但又不一样，这俩的本质是 `__builtin_expect`, 代表了一种逻辑期望。

使用它们的目的是帮助编译器进行分支预测优化，从而提高程序的执行效率。通过告知编译器哪些分支更可能被执行，或者哪些分支较少被执行，编译器可以更有效地安排指令的执行，减少因错误预测而导致的性能损失。

### 4、`lua_atpanic` 和 `lua_setwarnf`

`lua_atpanic` 对新的虚拟机注册一个函数，在 Lua 遇到致命错误时（如内存分配失败或其他无法恢复的错误）调用这个函数

`lua_setwarnf` 对新的虚拟机注册一个警告函数，当 Lua 执行时产生警告时，这个回调函数就会被调用。


## 内置的内存管理函数（l_alloc）

先来看函数签名：

``` C
// lua.h

typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
```

- ud：指 userdata，代表一些lua无法定义的外部结构或者类型
- ptr：指向当前要更改的内存起始地址的指针
- osize：指 old size，当前指针指向的内存块的原始大小
- nsize：指 new size，当前指针指向的内存块的新大小

相比C标准库中的内存分配函数，Lua的内存管理函数会额外给出osize（内存块的原始大小），这对定制一个高效的自定义内存管理函数来说非常重要，可以帮助我们更加精准地设计和节省内存。（C标准库的内存分配函数仅包含一个内存地址指针和需要分配的大小，要做到精准定制，一般需要在内存块的前面加了一个cookie ，把内存块尺寸存放在里面）

ud是一个额外的指针，允许我们带入额外的处理逻辑。比如让内存管理模块工作在不同的堆上。恰当的定制内存管理器，就可以回避线程安全问题。不考虑线程安全的因素，我们可以让内存管理工作更为高效。

从Lua5.2开始，当 ptr 传入 NULL 时，osize的含义是对象的类型，这样做让我们知道当前是在分配一个什么类型的对象，便于统计和优化

然后我们再来看看内置的内存管理函数：

``` C
// lauxlib.c

static void *l_alloc (void *ud, void *ptr, size_t osize, size_t nsize) {
  (void)ud; (void)osize;  /* not used */
  if (nsize == 0) {
    free(ptr); // C标准库的内存释放函数
    return NULL;
  }
  else
    return realloc(ptr, nsize); // C标准库的内存分配函数
}
```

这个函数的逻辑比较简单，当nsize指定为0时，释放当前指针指向的内存。否则，分配一个nsize大小的内存块


## Lua内存管理

Lua使用了一组宏来管理不同类别的内存：单个对象、数组、可变长数组等。这组宏定义在 lmem.h 中。

这组宏的核心是一个内部API：`luaM_realloc_`

它的实现本质是调用 `global_State` 中注册的内存分配器（也就是我们之前了解的l_alloc或者我们自己定义的内存管理函数），我们在创建一个新的虚拟机时，传入的内存管理函数其实就是注册给了全局状态机

!!! note
    原文对这里的说明：这些工作不仅仅是分配新的内存，释放不用的内存，扩展不够用的内存。Lua也会通过 `realloc` 试图释放掉预申请过大的内存的后半部分，当然，这取决于用户提供的内存管理器能不能缩小内存块了

还有一个需要注意的细节， `luaM_realloc_` 并不能直接调用，Lua在这里围绕它定义了很多宏，应对不同类型和调用场景。这其实是一种优化思路，因为很多调用的传入参数都是常数，直接用宏定义，可以让常量计算在编译时就完成，节省运行时的计算和开销。（Lua有很多这样精致的设计思路，这也是它的源码被盛赞的原因之一）


以下是它的具体代码：

``` C
/*
** Generic allocation routine.
*/
void *luaM_realloc_ (lua_State *L, void *block, size_t osize, size_t nsize) {
  void *newblock;
  global_State *g = G(L);
  lua_assert((osize == 0) == (block == NULL));
  newblock = firsttry(g, block, osize, nsize);
  if (l_unlikely(newblock == NULL && nsize > 0)) {
    newblock = tryagain(L, block, osize, nsize);
    if (newblock == NULL)  /* still no memory? */
      return NULL;  /* do not update 'GCdebt' */
  }
  lua_assert((nsize == 0) == (newblock == NULL));
  g->GCdebt = (g->GCdebt + nsize) - osize;
  return newblock;
}
```

整个代码逻辑可以分为三个部分：

第一部分是利用全局状态机分配一块新的内存 `newblock`，这里要细看firsttry的定义：

``` C
// lmem.c

#define firsttry(g,block,os,ns)    ((*g->frealloc)(g->ud, block, os, ns))
```

firsttry其实就是调用全局状态机frealloc指针指向的方法，这个就是创建虚拟机时传入的内存管理函数

第二部分是出现可能性很小的分配失败的情况，这里执行了 `tryagain`，实现如下：

``` C
// lmem.c

/*
** In case of allocation fail, this function will do an emergency
** collection to free some memory and then try the allocation again.
** The GC should not be called while state is not fully built, as the
** collector is not yet fully initialized. Also, it should not be called
** when 'gcstopem' is true, because then the interpreter is in the
** middle of a collection step.
*/
static void *tryagain (lua_State *L, void *block, size_t osize, size_t nsize) {
  global_State *g = G(L);
  if (completestate(g) && !g->gcstopem) {
    luaC_fullgc(L, 1);  /* try to free some memory... */
    return (*g->frealloc)(g->ud, block, osize, nsize);  /* try again */
  }
  else return NULL;  /* cannot free any memory without a full state */
}
```

注释的解释：

- 如果分配失败，此函数将执行紧急收集以释放一些内存，然后再次尝试分配。
- 在虚拟机未完全构建时不应调用 GC，因为收集器尚未完全初始化。此外，当“gcstopem”为真时不应调用它，因为解释器正处于收集步骤的中间。

总结就是在GC收集器完成时，会进行一次 Full GC，尝试释放掉一些内存，并再次分配

第三部分是将新分配的大小更新到 `GCdebt`，这用于内部感知内存大小，在内存不够时会主动尝试GC操作

!!! note
    原书中还提到了 `luaM_growaux_`，这个API用于管理可变长数组，其策略是当数组空间不够时，扩大为原来的2倍。

``` C
// lmem.c

/*
** Minimum size for arrays during parsing, to avoid overhead of
** reallocating to size 1, then 2, and then 4. All these arrays
** will be reallocated to exact sizes or erased when parsing ends.
*/
#define MINSIZEARRAY	4

void *luaM_growaux_ (lua_State *L, void *block, int nelems, int *psize,
                     int size_elems, int limit, const char *what) {
  void *newblock;
  int size = *psize;
  if (nelems + 1 <= size)  /* does one extra element still fit? */
    return block;  /* nothing to be done */
  if (size >= limit / 2) {  /* cannot double it? */
    if (l_unlikely(size >= limit))  /* cannot grow even a little? */
      luaG_runerror(L, "too many %s (limit is %d)", what, limit);
    size = limit;  /* still have at least one free place */
  }
  else {
    size *= 2;
    if (size < MINSIZEARRAY)
      size = MINSIZEARRAY;  /* minimum size */
  }
  lua_assert(nelems + 1 <= size && size <= limit);
  /* 'limit' ensures that multiplication will not overflow */
  newblock = luaM_saferealloc_(L, block, cast_sizet(*psize) * size_elems,
                                         cast_sizet(size) * size_elems);
  *psize = size;  /* update only when everything else is OK */
  return newblock;
}
```

## 全局状态机

### 1、全局状态机作用？创建虚拟机时如何被引用？

对于Lua使用者而言，`global_State` 即全局状态机，是不可见的，我们也不需要引用它，但是仍然需要了解它。

全局状态机的作用：

- 有对主线程（创建新的虚拟机时分配的 `lua_State`）的引用
- 有注册表管理所有全局数据，有全局字符串表
- 内存管理函数
- GC需要的信息
- 一切工作内存

通过 `lua_newstate` 创建一个新的Lua虚拟机时，会申请一块内存存放一个LG类型的结构，其中保存了主线程和全局状态机，代码和示意图如下：

``` C
// lstate.c

/*
** thread state + extra space
*/
typedef struct LX {
  lu_byte extra_[LUA_EXTRASPACE];
  lua_State l;
} LX;


/*
** Main thread combines a thread state and the global state
*/
typedef struct LG {
  LX l;
  global_State g;
} LG;
```

![LG的结构](202412071401.png)
/// caption
LG的结构
///

释义：

- LG：包含主线程 `lua_State` 和全局状态机 `global_State` 的结构体，取首字母组成了“LG”
- LX：对主线程的一次封装，只是额外多了一块预定义大小的内存块。
    - extra_：据源码注释解释，这个称为主线程的原始内存大小，访问速度非常快，如果需要不同大小，可以自行更改，但没有给出明确的使用，估计是可以根据用户需要去自定义用途。
    - lua_State：主线程
- global_State：全局状态机

### 2、原文中提到的内存布局的细节

!!! note
    这里，主线程必须定义在结构的前面，否则关闭虚拟机的时候（如下代码）就无法正确的释放内存。

``` C
(*g->frealloc)(g->ud, fromstate(L), sizeof(LG), 0);  /* free main block */
```

这里其实就是搞懂fromstate到底做了啥

``` C
// lstate.c

#define fromstate(L)	(cast(LX *, cast(lu_byte *, (L)) - offsetof(LX, l)))
```

释义：

- `cast(lu_byte *, (L))`：将 `L` 从 `lua_State *` 类型转换为 `lu_byte *` 类型的指针。也就是转为字节级指针，方便进行字节偏移
- `offsetof(LX, l)`：这部分的意思是取 `l` 这个字段在 `LX` 这个结构体中的偏移量
- 第一步中的主线程的字节指针减去自身在 `LX` 结构体中的偏移量，实际就是取存储自身的 `LX` 的内存地址
- 最后将类型转换为 `LX *`，得到一个指向 `LX` 结构体的指针，即得到主线程外包装的 `LX`

回过头，原文所描述的内存布局顺序，确实会影响内存的释放。因为要从LG的内存起始位置释放，也就是LX定义在前才不会出错


### 3、初步阅读 Lua_newstate 的内容

``` C
// lstate.c

LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
  int i;
  lua_State *L;
  global_State *g;
  LG *l = cast(LG *, (*f)(ud, NULL, LUA_TTHREAD, sizeof(LG)));
  if (l == NULL) return NULL;
  L = &l->l.l;
  g = &l->g;
  L->tt = LUA_VTHREAD;
  g->currentwhite = bitmask(WHITE0BIT);
  L->marked = luaC_white(g);
  preinit_thread(L, g);
  g->allgc = obj2gco(L);  /* by now, only object is the main thread */
  L->next = NULL;
  incnny(L);  /* main thread is always non yieldable */
  g->frealloc = f;
  g->ud = ud;
  g->warnf = NULL;
  g->ud_warn = NULL;
  g->mainthread = L;
  g->seed = luai_makeseed(L);
  g->gcstp = GCSTPGC;  /* no GC while building state */
  g->strt.size = g->strt.nuse = 0;
  g->strt.hash = NULL;
  setnilvalue(&g->l_registry);
  g->panic = NULL;
  g->gcstate = GCSpause;
  g->gckind = KGC_INC;
  g->gcstopem = 0;
  g->gcemergency = 0;
  g->finobj = g->tobefnz = g->fixedgc = NULL;
  g->firstold1 = g->survival = g->old1 = g->reallyold = NULL;
  g->finobjsur = g->finobjold1 = g->finobjrold = NULL;
  g->sweepgc = NULL;
  g->gray = g->grayagain = NULL;
  g->weak = g->ephemeron = g->allweak = NULL;
  g->twups = NULL;
  g->totalbytes = sizeof(LG);
  g->GCdebt = 0;
  g->lastatomic = 0;
  setivalue(&g->nilvalue, 0);  /* to signal that state is not yet built */
  setgcparam(g->gcpause, LUAI_GCPAUSE);
  setgcparam(g->gcstepmul, LUAI_GCMUL);
  g->gcstepsize = LUAI_GCSTEPSIZE;
  setgcparam(g->genmajormul, LUAI_GENMAJORMUL);
  g->genminormul = LUAI_GENMINORMUL;
  for (i=0; i < LUA_NUMTAGS; i++) g->mt[i] = NULL;
  if (luaD_rawrunprotected(L, f_luaopen, NULL) != LUA_OK) {
    /* memory allocation error: free partial state */
    close_state(L);
    L = NULL;
  }
  return L;
}


/*
** open parts of the state that may cause memory-allocation errors.
*/
static void f_luaopen (lua_State *L, void *ud) {
  global_State *g = G(L);
  UNUSED(ud);
  stack_init(L, L);  /* init stack */  //初始化主线程的数据栈
  init_registry(L, g); //初始化注册表
  luaS_init(L); //初始化字符串池
  luaT_init(L); //初始化元表用的字符串
  luaX_init(L); //初始化词法分析用的token串
  g->gcstp = 0;  /* allow gc */
  setnilvalue(&g->nilvalue);  /* now state is complete */
  luai_userstateopen(L);
}
```

这里我使用的Lua5.4.4版本作为参考，和原文中的有些不一致，但总体实现大差不差

函数实现中包含了诸如GC、字符串、内存管理等等相关的逻辑，在之后的章节会仔细分析。

这里我们着重看下最后一个条件分支的逻辑：如果Lua调用 `f_luaopen` 检查我们虚拟机的主线程，如果未通过检查，则会释放掉它。另外一个点是，虚拟机初始化的过程分两步：第一步是 `f_luaopen` 之前的逻辑，这一堆逻辑没有额外分配内存。真正会引起内存分配的初始化逻辑其实在 `f_luaopen` 中。第二步则是执行 `f_luaopen` 来初始化虚拟机

结合以上两点，其实可以看出Lua对创建虚拟机的处理非常小心。内存管理函数可能是外部传入的，也就有可能引起错误的内存分配。这里的思路是先初始化不需要额外内存分配的部分，把异常处理机制先建立起来。然后去调用可能引起内存分配失败的初始化代码，这里的容错机制设计是很精妙的。