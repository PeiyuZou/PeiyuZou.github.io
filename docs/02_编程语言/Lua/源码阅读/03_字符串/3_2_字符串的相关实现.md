## 字符串比较

短字符串的比较很简单，由于被内部化，只需要比较内存地址即可：

```C
// lstring.h

/*
** equality for short strings, which are always internalized
*/
#define eqshrstr(a,b)	check_exp((a)->tt == LUA_VSHRSTR, (a) == (b))
```

对于长字符串，首先比较长度，长度相同的情况下需要逐字节比较：

```C
/*
** equality for long strings
*/
int luaS_eqlngstr (TString *a, TString *b) {
  size_t len = a->u.lnglen;
  lua_assert(a->tt == LUA_VLNGSTR && b->tt == LUA_VLNGSTR);
  return (a == b) ||  /* same instance or... */
    ((len == b->u.lnglen) &&  /* equal length and ... */
     (memcmp(getstr(a), getstr(b), len) == 0));  /* equal contents */
}
```

## 短字符串的内部化

直接上内部化的代码：

```C
// lstring.c

/*
** Checks whether short string exists and reuses it or creates a new one.
*/
static TString *internshrstr (lua_State *L, const char *str, size_t l) {
  TString *ts;
  global_State *g = G(L);
  stringtable *tb = &g->strt;
  unsigned int h = luaS_hash(str, l, g->seed);
  TString **list = &tb->hash[lmod(h, tb->size)];
  lua_assert(str != NULL);  /* otherwise 'memcmp'/'memcpy' are undefined */
  for (ts = *list; ts != NULL; ts = ts->u.hnext) {
    if (l == ts->shrlen && (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) {
      /* found! */
      if (isdead(g, ts))  /* dead (but not collected yet)? */
        changewhite(ts);  /* resurrect it */
      return ts;
    }
  }
  /* else must create a new string */
  if (tb->nuse >= tb->size) {  /* need to grow string table? */
    growstrtab(L, tb);
    list = &tb->hash[lmod(h, tb->size)];  /* rehash with new size */
  }
  ts = createstrobj(L, l, LUA_VSHRSTR, h);
  memcpy(getstr(ts), str, l * sizeof(char));
  ts->shrlen = cast_byte(l);
  ts->u.hnext = *list;
  *list = ts;
  tb->nuse++;
  return ts;
}
```

我们详细分析下：

```C
global_State *g = G(L);
stringtable *tb = &g->strt;
```

这里认证了短字符串存放在全局字符串表这个说法，`strt` 就是 `string table` 的简写

```C
unsigned int h = luaS_hash(str, l, g->seed);
TString **list = &tb->hash[lmod(h, tb->size)];
```

`luaS_hash` 在上节的Lua为应对DoS攻击做出的修改中有提到，这个函数用于计算字符串的哈希值。然后和经典的链式寻址哈希表的实现一致，lua也用形如 `index = hash(key) % capacity` 的逻辑计算得到哈希桶的下标。所以这里得到的 `list` 就是当前字符串存储的桶（链表）

```C
for (ts = *list; ts != NULL; ts = ts->u.hnext) {
  if (l == ts->shrlen && (memcmp(str, getstr(ts), l * sizeof(char)) == 0)) {
    /* found! */
    if (isdead(g, ts))  /* dead (but not collected yet)? */
      changewhite(ts);  /* resurrect it */
    return ts;
  }
}
```

上面这部分就是在桶中查是否有已经存过的相同字符串，（这也是内部化的核心，合并相同内容的字符串）如果有，那么就直接返回它，不用再创建。值得注意的是这里的 `isdead` 和 `changewhite` 的处理，原文对这里有清楚地解释：

!!! note
    这里需要检查表中的字符串是否是死掉的字符串。这是因为Lua的垃圾收集过程是分步完成的。而向字符串池添加新字符串在任何步骤之间都可能发生。有可能在标记完字符串后发现有些字符串没有任何引用，但在下个步骤中又产生了相同的字符串导致这个字符串复活

```C
if (tb->nuse >= tb->size) {  /* need to grow string table? */
  growstrtab(L, tb);
  list = &tb->hash[lmod(h, tb->size)];  /* rehash with new size */
}

// lstring.c
static void growstrtab (lua_State *L, stringtable *tb) {
  if (l_unlikely(tb->nuse == MAX_INT)) {  /* too many strings? */
    luaC_fullgc(L, 1);  /* try to free some... */
    if (tb->nuse == MAX_INT)  /* still too many? */
      luaM_error(L);  /* cannot even create a message... */
  }
  if (tb->size <= MAXSTRTB / 2)  /* can grow string table? */
    luaS_resize(L, tb->size * 2);
}

/*
** Resize the string table. If allocation fails, keep the current size.
** (This can degrade performance, but any non-zero size should work
** correctly.)
*/
void luaS_resize (lua_State *L, int nsize) {
  stringtable *tb = &G(L)->strt;
  int osize = tb->size;
  TString **newvect;
  if (nsize < osize)  /* shrinking table? */
    tablerehash(tb->hash, osize, nsize);  /* depopulate shrinking part */
  newvect = luaM_reallocvector(L, tb->hash, osize, nsize, TString*);
  if (l_unlikely(newvect == NULL)) {  /* reallocation failed? */
    if (nsize < osize)  /* was it shrinking table? */
      tablerehash(tb->hash, nsize, osize);  /* restore to original size */
    /* leave table as it was */
  }
  else {  /* allocation succeeded */
    tb->hash = newvect;
    tb->size = nsize;
    if (nsize > osize)
      tablerehash(newvect, osize, nsize);  /* rehash for new size */
  }
}
```

既然是哈希表，自然离不开负载因子过大（哈希冲突严重）导致扩容这个话题，上面的代码也给出了Lua的方案，可以看出Lua的负载因子默认是1，即 `size / capacity = 1` 时会触发扩容

```C
ts = createstrobj(L, l, LUA_VSHRSTR, h);
memcpy(getstr(ts), str, l * sizeof(char));
ts->shrlen = cast_byte(l);
ts->u.hnext = *list;
*list = ts;
tb->nuse++;
return ts;

/*
** creates a new string object
*/
static TString *createstrobj (lua_State *L, size_t l, int tag, unsigned int h) {
  TString *ts;
  GCObject *o;
  size_t totalsize;  /* total size of TString object */
  totalsize = sizelstring(l);
  o = luaC_newobj(L, tag, totalsize);
  ts = gco2ts(o);
  ts->hash = h;
  ts->extra = 0;
  getstr(ts)[l] = '\0';  /* ending 0 */
  return ts;
}
```

剩下的这部分则是创建一个新的短字符串的逻辑，其核心是 `createstrobj` 函数，需要注意的是，为了兼容C接口，Lua会在字符串末尾加上一个 `\0`，但这个结尾符并不计算在字符串长度内