## 基本设计

- 由任意的8位字符组合形成字符串
- 存储形式是带长度的内存块，也就是存内容的同时，也有额外空间保存长度
- 为了兼容C库函数，Lua的字符串也在其内容的末尾添加 `\0`，标记字符串结束

## 两种内部形式：长字符串和短字符串

对于外部来说，字符串只有一种类型，归属于Lua的9种基本类型之一，源码定义如下：

``` C
// lua.h

/*
** basic types
*/
#define LUA_TNONE		(-1)

#define LUA_TNIL		0
#define LUA_TBOOLEAN		1
#define LUA_TLIGHTUSERDATA	2
#define LUA_TNUMBER		3
#define LUA_TSTRING		4
#define LUA_TTABLE		5
#define LUA_TFUNCTION		6
#define LUA_TUSERDATA		7
#define LUA_TTHREAD		8

#define LUA_NUMTYPES		9
```

其中-1代表无效类型，0~8是9种基本类型的标识（其中字符串是4），`LUA_NUMTYPES` 是指基本类型的数量有9个

在字符串核心源码脚本 `lstring.c` 中，并没有用到 `LUA_TSTRING`，而是使用 `LUA_VSHRSTR` 和 `LUA_VLNGSTR` 两个变种类型，以此来对长短字符串作区分以实现不同的内部处理，长短字符串的类型定义如下：

``` C
// lobject.h

/* add variant bits to a type */
#define makevariant(t,v)	((t) | ((v) << 4))

/* Variant tags for strings */
#define LUA_VSHRSTR	makevariant(LUA_TSTRING, 0)  /* short strings */
#define LUA_VLNGSTR	makevariant(LUA_TSTRING, 1)  /* long strings */
```

`makevariant` 仅对类型作左移4位的操作，由此让Lua内部支持对类型进行细分，比如 `nil` 内部可以分为 `nil`、`empty`、`abstkey`，`number` 内部被分为浮点数和整型等。

### 1.长短字符如何界定？存储方式有何差异？

```
// llimits.h

// 注释翻译：短字符串（即内部化的字符串）的最大长度。
//（不能小于元方法的保留字或标记，因为这些字符串必须内部化）
/*
** Maximum length for short strings, that is, strings that are
** internalized. (Cannot be smaller than reserved words or tags for
** metamethods, as these strings must be internalized;
** #("function") = 8, #("__newindex") = 10.)
*/
#if !defined(LUAI_MAXSHORTLEN)
#define LUAI_MAXSHORTLEN	40
#endif
```

!!! note
    这里需要注意 `内部化` 的含义，内部化的意思是指，在同一个 `Lua State` 中，相同的字符串只会存在一份，合并相同的字符串可以大量减少内存占用，并且可以缩短比较时间，因为只需要比较内存地址是否相同即可，而不需要逐字节比较。Lua内部的保留字和标记也理所应当需要被内部化，其中最长的保留字是 `__newindex` 长度是10个字符，因此 `LUAI_MAXSHORTLEN` 不可以被设置小于10

这个值可以由用户自行决定，但Lua给出的默认界定值是40，超过40的字符串被认为是长字符串。

存储方式的差异：

- 短字符串存储在 `全局字符串哈希表` 中，即 `global_State` 中的 `strt` 字段，这个哈希表内部采用链地址法的方式，实现方式比较简单
- 长字符串则直接存储在字符串内部的字段中，在原文的Lua版本中，长字符串甚至不存储在 `TString` 的内存块内，而是紧跟着存储在 `TString` 的内存块后面

### 2.字符串类型的实现结构

``` C
// lobject.h

/*
** Header for a string value.
*/
typedef struct TString {
  CommonHeader;
  lu_byte extra;  /* reserved words for short strings; "has hash" for longs */
  lu_byte shrlen;  /* length for short strings */
  unsigned int hash;
  union {
    size_t lnglen;  /* length for long strings */
    struct TString *hnext;  /* linked list for hash table */
  } u;
  char contents[1];
} TString;
```

#### 2.1 CommonHeader

我们先看第一个宏 `CommonHeader`，它的定义如下：

``` C
/*
** Common Header for all collectable objects (in macro form, to be
** included in other objects)
*/
#define CommonHeader	struct GCObject *next; lu_byte tt; lu_byte marked
```

`CommonHeader` 并不是字符串专属，Lua对一切需要被垃圾收集器管理的对象，均会插入这个宏。它会在垃圾回收的章节中细讲，这里不赘述。我们这里关注一个域：`tt`

让我们回想上面的内容，字符串在基本类型中的定义是 `LUA_TSTRING`，并且在内部还细分为了 `LUA_VSHRSTR` 和 `LUA_VLNGSTR`，这里怎么又有一个 `TString` 类型，到底哪个才是字符串类型？

要回答这个问题，就需要了解 `tt` 的设计，Lua为了清楚地知道每一个对象的实际类型，需要对每一个参与垃圾收集的对象做类型标记（type tag，简写为tt），也就是花了一个域的空间来存储这个对象的类型，因此 `tt` 也可以理解为 `类型的类型` 或者 `类型的值`。

所以 `LUA_TSTRING` 、`LUA_VSHRSTR` 和 `LUA_VLNGSTR` 并不是字符串的类型定义，它们仅仅标记当前这个字符串的内部类型，真正定义一个字符串结构的是 `TString`

#### 2.2 extra

这个域的作用和注释解释的一样：

- 对短字符串来说，它用来标记当前字符串是否是保留字，这会用于词法分析
- 对长字符串来说，它表示是否计算了hash，这用于惰性求哈希值
    - 惰性：在取Hash值时才判断是否已经计算，已经计算则返回计算好的结果，否则当场计算
    - 从外部压入一个长字符串时，没有立刻计算其hash值，只是简单地复制一遍字符串内容，然后标记一下extra域，标记为没有hash。直到需要对字符串做键匹配时，才惰性计算hash值，加快之后的键比较过程

#### 2.3 shrlen

如果当前字符串是短字符串，存储短字符串的长度

#### 2.4 hash

当前字符串的哈希值，由于短字符串存储在

#### 2.5 lnglen、hnext以及u的设计

首先我们看 `lnglen` 和 `hnext` 的含义，再来看为何要结合两者形成 `u`

`lnglen` 存储长字符串的长度，区别于 `shrlen` 只有一个 `lu_byte (unsigned char))` 的大小，它给了一个 `size_t (unsigned int64)` 的大小给的很充足

`hnext` 则与长字符串无关，由于采用链表寻址，短字符串存储在全局字符哈希表中的单个哈希桶中，该指针指向哈希桶的下一个链表节点，也就是哈希冲突的下一个元素。这个指针的作用是在删除当前短字符串，或者全局哈希表触发了 `rehash` 操作的时候，亦或是新建字符串触发 `内部化` 查询的时候，帮助Lua内部更高效地处理哈希表

`Union` 是一种共用体，允许多个成员共用同一段内存，而不是分别占用内存。像 `lnglen` 和 `hnext` 特别使用 `Union`，因为它们的应用场景是互斥的，只可能有两者之一被使用，这样一来节省了字符串字段的内存占用。其实这里 `lnglen` 和 `shrlen` 也是互斥的，但是这里明显使用 `hnext` 更优，毕竟指针最少占用4字节（64位操作系统就是64÷8=8个字节），将两个占用大的声明在一起更节省，这种细节设计也是比较精彩的

#### 2.6 contents

长字符串存储实际字符串内容的数组，从一个 `TString` 类型的对象中取实际字符串内容的API：

``` C
/*
** Get the actual string (array of bytes) from a 'TString'.
*/
#define getstr(ts)  ((ts)->contents)
```

## Hash DoS

在Lua5.2.0及之前，字符串不管长短一律内部化后存放在字符串表中，当时字符串哈希值的计算代码如下：

``` C
unsigned int luaS_hash (const char *str, size_t l) {
  unsigned int h = cast(unsigned int, l);
  size_t step = (1>>5)+1;
  size_t l1;
  for (l1=l; l1>=step; l1-=step)
    h = h ^ ((h<<5)+(h>>2)+cast(unsigned char, str[l1-l]));
  return h;
}
```

!!! note
    原文：Lua5.2.0发布不久，有人在邮件列表中提出，Lua的这个设计有可能对其给于 Hash Dos 攻击的机会。攻击者可以轻易构造出上千万拥有相同哈希值的不同字符串，以此数十倍的降低Lua从外部压入字符串进入内部字符串表的效率。当Lua用于大量依赖字符串处理的诸如HTTP服务的处理时，输入的字符串不可控制，很容易被人恶意利用

从Lua5.2.1开始，为了解决这个问题做了如下改动：

- 长字符串独立出来，不再通过内部化进入全局字符串表
- 使用一个随机种子用于哈希值的计算，使攻击者无法轻易构造出拥有相同哈希值的不同字符串

这里我们看下5.4.4版本的实现：

``` C
// lstring.c

unsigned int luaS_hash (const char *str, size_t l, unsigned int seed) {
  unsigned int h = seed ^ cast_uint(l);
  for (; l > 0; l--)
    h ^= ((h<<5) + (h>>2) + cast_byte(str[l - 1]));
  return h;
}
```

这个随机种子 `seed` 在默认情况下是在 `Lua State` 创建时放在全局表中的，它利用了构造状态机的内存地址随机性，以及用户可配置的一个随机量（默认是使用time函数获取时间构造种子）同时决定，如下是相关代码：

```C
// lstate.c

/*
** Compute an initial seed with some level of randomness.
** Rely on Address Space Layout Randomization (if present) and
** current time.
*/
#define addbuff(b,p,e) \
  { size_t t = cast_sizet(e); \
    memcpy(b + p, &t, sizeof(t)); p += sizeof(t); }

static unsigned int luai_makeseed (lua_State *L) {
  char buff[3 * sizeof(size_t)];
  unsigned int h = cast_uint(time(NULL));
  int p = 0;
  addbuff(buff, p, L);  /* heap variable */
  addbuff(buff, p, &h);  /* local variable */
  addbuff(buff, p, &lua_newstate);  /* public function */
  lua_assert(p == sizeof(buff));
  return luaS_hash(buff, p, h);
}
```

种子的存放和使用，相关代码：

``` C
// lstate.c

/* 创建状态机时存放在全局状态机种 */
LUA_API lua_State *lua_newstate (lua_Alloc f, void *ud) {
  ...
  g->seed = luai_makeseed(L);
  ...
}

/* 返回或者构建短字符串 */
static TString *internshrstr (lua_State *L, const char *str, size_t l) {
  ...
  unsigned int h = luaS_hash(str, l, g->seed);
  ...
}

/* 构建长字符串 */
TString *luaS_createlngstrobj (lua_State *L, size_t l) {
  TString *ts = createstrobj(L, l, LUA_VLNGSTR, G(L)->seed);
  ...
}
```