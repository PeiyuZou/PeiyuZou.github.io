<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Back Number</title>
  
  
  <link href="https://peiyuzou.github.io/atom.xml" rel="self"/>
  
  <link href="https://peiyuzou.github.io/"/>
  <updated>2025-07-16T04:18:04.250Z</updated>
  <id>https://peiyuzou.github.io/</id>
  
  <author>
    <name>Z.P.Y</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>4.5 相关问题</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/4.5-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/4.5-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2025-07-16T03:32:12.000Z</published>
    <updated>2025-07-16T04:18:04.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组分配在栈-or-堆">数组分配在栈 or 堆？</h1><p>这个问题不同语言有不同的结果。</p><p>对于 C++ 来说，静态数组（编译时确定大小）和 std:array分配在栈上，动态数组（new[]）和 std::vector 分配在堆上。</p><p>对于 C# 来说，都是分配在堆上，但是提供了关键字 stackalloc在栈上分配：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Span&lt;<span class="built_in">int</span>&gt; stackSpan = <span class="keyword">stackalloc</span> <span class="built_in">int</span>[<span class="number">100</span>];</span><br></pre></td></tr></table></figure><h1id="数组存储在栈上和存储在堆上对时间效率和空间效率是否有影响">数组存储在栈上和存储在堆上，对时间效率和空间效率是否有影响？</h1><p>存储在栈上和堆上的数组都被存储在连续内存空间内，数据操作效率基本一致。然而，栈和堆具有各自的特点，从而导致以下不同点。</p><ul><li>分配和释放效率：栈是一块较小的内存，分配由编译器自动完成；而堆内存相对更大，可以在代码中动态分配，更容易碎片化。因此，堆上的分配和释放操作通常比栈上的慢。</li><li>大小限制：栈内存相对较小，堆的大小一般受限于可用内存。因此堆更加适合存储大型数组。</li><li>灵活性：栈上的数组的大小需要在编译时确定，而堆上的数组的大小可以在运行时动态确定。</li></ul><h1id="为什么数组要求相同类型的元素而在链表中却没有强调相同类型呢">为什么数组要求相同类型的元素，而在链表中却没有强调相同类型呢？</h1><p>链表由节点组成，通过指针连接，所以各个节点可以存储不同类型的数据。</p><p>而数组必须是相同类型，这样才能通过计算偏移量来获取对应元素位置。例如，数组同时包含int 和 long 两种类型，单个元素分别占用 4 字节和 8 字节，此时就不能用公式计算偏移量了，因为数组中包含了两种 “元素长度” 。</p><h1id="在列表末尾添加元素是否时时刻刻都为-o1">在列表末尾添加元素是否时时刻刻都为<span class="math inline">\(O(1)\)</span> ？</h1><p>如果添加元素时超出列表长度，则需要先扩容列表再添加。系统会申请一块新的内存，并将原列表的所有元素搬运过去，这时候时间复杂度就会是<span class="math inline">\(O(n)\)</span> 。</p><h1 id="列表的内存浪费如何避免">列表的内存浪费如何避免？</h1><p>我们可以通过预先确定列表的最大长度来在初始化时给列表分配一个固定长度的空间并且确保在生命周期内不会扩容，这样可以尽量减少内存空间的浪费，同时也避免了扩容带来的时间和空间的开销。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组分配在栈-or-堆&quot;&gt;数组分配在栈 or 堆？&lt;/h1&gt;
&lt;p&gt;这个问题不同语言有不同的结果。&lt;/p&gt;
&lt;p&gt;对于 C++ 来说，静态数组（编译时确定大小）和 std:array
分配在栈上，动态数组（new[]）和 std::vector 分配在堆上。</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="04-数组与链表" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>4.4 内存与缓存</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/4.4-%E5%86%85%E5%AD%98%E4%B8%8E%E7%BC%93%E5%AD%98/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/4.4-%E5%86%85%E5%AD%98%E4%B8%8E%E7%BC%93%E5%AD%98/</id>
    <published>2025-07-16T03:12:31.000Z</published>
    <updated>2025-07-16T03:25:51.314Z</updated>
    
    <content type="html"><![CDATA[<p>我们在本章讨论的数组和链表，它们分别代表代表了 “连续存储” 和“分散存储”两种物理结构，物理结构在很大程度上决定了程序对内存和缓存的使用效率。</p><h1 id="计算机存储设备">计算机存储设备</h1><p>计算机中包括三种类型的存储设备：硬盘（harddisk）、内存（random-access memory, RAM）、缓存（cache memory）</p><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr><th>硬盘</th><th>内存</th><th>缓存</th></tr></thead><tbody><tr><td>用途</td><td>长期存储数据，包括操作系统、程序、文件等</td><td>临时存储当前运行的程序和正在处理的数据</td></tr><tr><td>易失性</td><td>断电后数据不会丢失</td><td>断电后数据会丢失</td></tr><tr><td>容量</td><td>较大，TB 级别</td><td>较小，GB 级别</td></tr><tr><td>速度</td><td>较慢，几百到几千 MB/s</td><td>较快，几十 GB/s</td></tr><tr><td>价格（人民币）</td><td>较便宜，几毛到几元 / GB</td><td>较贵，几十到几百元 / GB</td></tr></tbody></table><p>这种多层级的设计并非偶然，而是计算机科学家和工程师们经过深思熟虑的结果：</p><ul><li><strong>硬盘难以被内存取代</strong>。首先，内存中的数据在断电后会丢失，因此它不适合长期存储数据；其次，内存的成本是硬盘的几十倍，这使得它难以在消费者市场普及。</li><li><strong>缓存的大容量和高速度难以兼得</strong>。随着 L1、L2、L3缓存的容量逐步增大，其物理尺寸会变大，与 CPU核心之间的物理距离会变远，从而导致数据传输时间增加，元素访问延迟变高。在当前技术下，多层级的缓存结构是容量、速度和成本之间的最佳平衡点。</li></ul><p><img src="memory_cache_0.png" alt="计算机存储系统" /><br /></p><p>总的来说，硬盘用于长期存储大量数据，内存用于临时存储程序运行中正在处理的数据，而缓存则用于存储经常访问的数据和指令，以提高程序运行效率。三者共同协作，确保计算机系统高效运行。</p><p>在程序运行时，数据会从硬盘中被读取到内存中，供 CPU计算使用。缓存可以看作 CPU 的一部分，它通过智能地从内存加载数据，给 CPU提供高速的数据读取，从而显著提升程序的执行效率，减少对较慢的内存的依赖。</p><p><img src="memory_cache_1.png"alt="硬盘、内存和缓存之间的数据流通" /><br /></p><h1 id="数据结构的内存效率">数据结构的内存效率</h1><p>在内存空间利用方面，数组和链表各自具有优势和局限性。</p><p>一方面，内存是有限的，且同一块内存不能被多个程序共享，因此我们希望数据结构能够尽可能高效地利用空间。数组的元素紧密排列，不需要额外的空间来存储链表节点间的引用（指针），因此空间效率更高。然而，数组需要一次性分配足够的连续内存空间，这可能导致内存浪费，数组扩容也需要额外的时间和空间成本。相比之下，链表以“节点” 为单位进行动态内存分配和回收，提供了更大的灵活性。</p><p>另一方面，在程序运行时，随着反复申请与释放内存，空闲内存的碎片化程度会越来越高，从而导致内存的利用效率降低。数组由于其连续的存储方式，相对不容易导致内存碎片化。相反，链表的元素是分散存储的，在频繁的插入与删除操作中，更容易导致内存碎片化。</p><h1 id="数据结构的缓存效率">数据结构的缓存效率</h1><h2 id="cache-miss">Cache Miss</h2><p>缓存虽然在空间容量上远小于内存，但它比内存快得多，在程序执行速度上起着至关重要的作用。由于缓存的容量有限，只能存储一小部分频繁访问的数据，因此当CPU 尝试访问的数据不在缓存中时，就会发生<strong>缓存未命中（cachemiss）</strong>，此时 CPU 不得不从速度较慢的内存中加载所需数据。</p><p>显然，<strong>“缓存未命中” 越少，CPU读写数据的效率就越高，程序性能也就越好</strong>。我们将 CPU从缓存中成功获取数据的比例称为缓存命中率（cache hitrate），这个指标通常用来衡量缓存效率。</p><h2 id="缓存的机制">缓存的机制</h2><p>为了尽可能达到更高的效率，缓存会采取以下数据加载机制。</p><ul><li><strong>缓存行</strong>：缓存不是单个字节地存储与加载数据，而是以缓存行为单位。相比于单个字节的传输，缓存行的传输形式更加高效。</li><li><strong>预取机制</strong>：处理器会尝试预测数据访问模式（例如顺序访问、固定步长跳跃访问等），并根据特定模式将数据加载至缓存之中，从而提升命中率。</li><li><strong>空间局部性</strong>：如果一个数据被访问，那么它附近的数据可能近期也会被访问。因此，缓存在加载某一数据时，也会加载其附近的数据，以提高命中率。</li><li><strong>时间局部性</strong>：如果一个数据被访问，那么它在不久的将来很可能再次被访问。缓存利用这一原理，通过保留最近访问过的数据来提高命中率。</li></ul><h2 id="缓存层面对比数组和链表">缓存层面对比数组和链表</h2><p>数组和链表对缓存的利用效率是不同的，主要体现在以下几个方面。</p><ul><li><strong>占用空间</strong>：链表元素比数组元素占用空间更多，导致缓存中容纳的有效数据量更少。</li><li><strong>缓存行</strong>：链表数据分散在内存各处，而缓存是“按行加载”的，因此加载到无效数据的比例更高。</li><li><strong>预取机制</strong>：数组比链表的数据访问模式更具“可预测性”，即系统更容易猜出即将被加载的数据。</li><li><strong>空间局部性</strong>：数组被存储在集中的内存空间中，因此被加载数据附近的数据更有可能即将被访问。</li></ul><p>总体而言，<strong>数组具有更高的缓存命中率，因此它在操作效率上通常优于链表</strong>。这使得在解决算法问题时，基于数组实现的数据结构往往更受欢迎。</p><p>需要注意的是，<strong>高缓存效率并不意味着数组在所有情况下都优于链表</strong>。实际应用中选择哪种数据结构，应根据具体需求来决定。例如，数组和链表都可以实现“栈” 数据结构，但它们适用于不同场景。</p><ul><li>在做算法题时，我们会倾向于选择基于数组实现的栈，因为它提供了更高的操作效率和随机访问的能力，代价仅是需要预先为数组分配一定的内存空间。</li><li>如果数据量非常大、动态性很高、栈的预期大小难以估计，那么基于链表实现的栈更加合适。链表能够将大量数据分散存储于内存的不同部分，并且避免了数组扩容产生的额外开销。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们在本章讨论的数组和链表，它们分别代表代表了 “连续存储” 和
“分散存储”
两种物理结构，物理结构在很大程度上决定了程序对内存和缓存的使用效率。&lt;/p&gt;
&lt;h1 id=&quot;计算机存储设备&quot;&gt;计算机存储设备&lt;/h1&gt;
&lt;p&gt;计算机中包括三种类型的存储设备：硬盘（ha</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="04-数组与链表" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>4.3 列表</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/4.3-%E5%88%97%E8%A1%A8/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/4.3-%E5%88%97%E8%A1%A8/</id>
    <published>2025-07-16T02:56:55.000Z</published>
    <updated>2025-07-16T03:04:22.264Z</updated>
    
    <content type="html"><![CDATA[<p>列表（list）是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。</p><ul><li>链表天然可以看作一个列表，其支持元素增删查改操作，并且可以灵活动态扩容。</li><li>数组也支持元素增删查改，但由于其长度不可变，因此只能看作一个具有长度限制的列表。</li></ul><p>当使用数组实现列表时，<strong>长度不可变的性质会导致列表的实用性降低</strong>。这是因为我们通常无法事先确定需要存储多少数据，从而难以选择合适的列表长度。若长度过小，则很可能无法满足使用需求；若长度过大，则会造成内存空间浪费。</p><p>为解决此问题，我们可以使用<strong>动态数组（dynamicarray）</strong>来实现列表。它继承了数组的各项优点，并且可以在程序运行过程中进行动态扩容。</p><p>实际上，许多编程语言中的标准库提供的列表是基于动态数组实现的，比如 C#的 List 和 C++ 的 vector 等。我们下面讨论的 “列表” 请视为 “动态数组”。</p><h1 id="常用操作">常用操作</h1><h2 id="初始化">1. 初始化</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化列表 */</span></span><br><span class="line"><span class="comment">// 无初始值</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; nums1 = [];</span><br><span class="line"><span class="comment">// 有初始值</span></span><br><span class="line"><span class="built_in">int</span>[] numbers = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; nums = [.. numbers];</span><br></pre></td></tr></table></figure><h2 id="访问元素">2. 访问元素</h2><p>列表本质上是数组，因此可以在 <spanclass="math inline">\(O(1)\)</span> 时间内访问和更新元素，效率很高。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 访问元素 */</span></span><br><span class="line"><span class="built_in">int</span> num = nums[<span class="number">1</span>];  <span class="comment">// 访问索引 1 处的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 更新元素 */</span></span><br><span class="line">nums[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// 将索引 1 处的元素更新为 0</span></span><br></pre></td></tr></table></figure><h2 id="插入与删除元素">3. 插入与删除元素</h2><p>本质上和数组相同，只是封装了接口：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 清空列表 */</span></span><br><span class="line">nums.Clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在尾部添加元素 */</span></span><br><span class="line">nums.Add(<span class="number">1</span>);</span><br><span class="line">nums.Add(<span class="number">3</span>);</span><br><span class="line">nums.Add(<span class="number">2</span>);</span><br><span class="line">nums.Add(<span class="number">5</span>);</span><br><span class="line">nums.Add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在中间插入元素 */</span></span><br><span class="line">nums.Insert(<span class="number">3</span>, <span class="number">6</span>);  <span class="comment">// 在索引 3 处插入数字 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除元素 */</span></span><br><span class="line">nums.RemoveAt(<span class="number">3</span>);  <span class="comment">// 删除索引 3 处的元素</span></span><br></pre></td></tr></table></figure><h2 id="遍历列表">4. 遍历列表</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 通过索引遍历列表 */</span></span><br><span class="line"><span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Count; i++) &#123;</span><br><span class="line">    count += nums[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 直接遍历列表元素 */</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">    count += num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拼接列表">5. 拼接列表</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 拼接两个列表 */</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt; nums1 = [<span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">9</span>];</span><br><span class="line">nums.AddRange(nums1);  <span class="comment">// 将列表 nums1 拼接到 nums 之后</span></span><br></pre></td></tr></table></figure><h2 id="排序列表">6. 排序列表</h2><p>完成列表排序后，我们便可以使用在数组类算法题中经常考查的 “二分查找”和 “双指针” 算法。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 排序列表 */</span></span><br><span class="line">nums.Sort(); <span class="comment">// 排序后，列表元素从小到大排列</span></span><br></pre></td></tr></table></figure><h1 id="列表的实现">列表的实现</h1><p>我们来用 C# 实现一个建议列表，有三个重点设计：</p><ul><li><strong>初始容量</strong>：选取一个合理的数组初始容量。在本示例中，我们选择10 作为初始容量。</li><li><strong>数量记录</strong>：声明一个变量 size，用于记录列表当前元素数量，并随着元素插入和删除实时更新。根据此变量，我们可以定位列表尾部，以及判断是否需要扩容。</li><li><strong>扩容机制</strong>：若插入元素时列表容量已满，则需要进行扩容。先根据扩容倍数创建一个更大的数组，再将当前数组的所有元素依次移动至新数组。在本示例中，我们规定每次将数组扩容至之前的2 倍。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 列表类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyList</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[] arr;           <span class="comment">// 数组（存储列表元素）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> arrCapacity = <span class="number">10</span>;    <span class="comment">// 列表容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> arrSize = <span class="number">0</span>;         <span class="comment">// 列表长度（当前元素数量）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">int</span> extendRatio = <span class="number">2</span>;  <span class="comment">// 每次列表扩容的倍数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构造方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyList</span>()</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="built_in">int</span>[arrCapacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取列表长度（当前元素数量）*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Size</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arrSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取列表容量 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Capacity</span>()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arrCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 访问元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Get</span>(<span class="params"><span class="built_in">int</span> index</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 索引如果越界，则抛出异常，下同</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= arrSize)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> arr[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 更新元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Set</span>(<span class="params"><span class="built_in">int</span> index, <span class="built_in">int</span> num</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= arrSize)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        arr[index] = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在尾部添加元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> num</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 元素数量超出容量时，触发扩容机制</span></span><br><span class="line">        <span class="keyword">if</span> (arrSize == arrCapacity)</span><br><span class="line">            ExtendCapacity();</span><br><span class="line">        arr[arrSize] = num;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        arrSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 在中间插入元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="built_in">int</span> index, <span class="built_in">int</span> num</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= arrSize)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        <span class="comment">// 元素数量超出容量时，触发扩容机制</span></span><br><span class="line">        <span class="keyword">if</span> (arrSize == arrCapacity)</span><br><span class="line">            ExtendCapacity();</span><br><span class="line">        <span class="comment">// 将索引 index 以及之后的元素都向后移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = arrSize - <span class="number">1</span>; j &gt;= index; j--) &#123;</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[index] = num;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        arrSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Remove</span>(<span class="params"><span class="built_in">int</span> index</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= arrSize)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfRangeException(<span class="string">&quot;索引越界&quot;</span>);</span><br><span class="line">        <span class="built_in">int</span> num = arr[index];</span><br><span class="line">        <span class="comment">// 将将索引 index 之后的元素都向前移动一位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = index; j &lt; arrSize - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新元素数量</span></span><br><span class="line">        arrSize--;</span><br><span class="line">        <span class="comment">// 返回被删除的元素</span></span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 列表扩容 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ExtendCapacity</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 新建一个长度为 arrCapacity * extendRatio 的数组，并将原数组复制到新数组</span></span><br><span class="line">        Array.Resize(<span class="keyword">ref</span> arr, arrCapacity * extendRatio);</span><br><span class="line">        <span class="comment">// 更新列表容量</span></span><br><span class="line">        arrCapacity = arr.Length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将列表转换为数组 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span>[] <span class="title">ToArray</span>()</span> &#123;</span><br><span class="line">        <span class="comment">// 仅转换有效长度范围内的列表元素</span></span><br><span class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[arrSize];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; arrSize; i++) &#123;</span><br><span class="line">            arr[i] = Get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;列表（list）是一个抽象的数据结构概念，它表示元素的有序集合，支持元素访问、修改、添加、删除和遍历等操作，无须使用者考虑容量限制的问题。列表可以基于链表或数组实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表天然可以看作一个列表，其支持元素增删查改操作，并且可以灵活动态扩容。&lt;/</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="04-数组与链表" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>4.2 链表</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/4.2-%E9%93%BE%E8%A1%A8/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/4.2-%E9%93%BE%E8%A1%A8/</id>
    <published>2025-07-16T02:39:34.000Z</published>
    <updated>2025-07-16T02:55:14.453Z</updated>
    
    <content type="html"><![CDATA[<p>存储数组的内存空间必须是连续的，而当数组非常大时，内存可能无法提供如此大的连续空间。此时链表的灵活性优势就体现出来了。</p><p>和数组一样，链表（linkedlist）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过“引用”相连接。引用记录了下一个节点的内存地址，通过它可以从当前节点访问到下一个节点。</p><p>链表的设计使得各个节点可以分散存储在内存各处，它们的内存地址无须连续。</p><p><img src="linked_list_0.png" alt="链表定义与存储方式" /><br /></p><p>每个节点都包含两项数据：节点的 “值” 和指向下一节点的 “引用”</p><ul><li>链表的首个节点被称为 “头节点” ，最后一个节点被称为 “尾节点”</li><li>尾节点指向的是 “空” ，它在 Java、C++ 和 Python 中分别被记为null、nullptr 和 None</li><li>在 C、C++、Go 和 Rust 等支持指针的语言中，上述 “引用” 应被替换为“指针”</li></ul><p>链表节点 ListNode除了包含值，还需额外保存一个引用（指针）。因此在相同数据量下，链表比数组占用更多的内存空间：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 链表节点类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="title">int</span> <span class="title">x</span>) &#123;  <span class="comment">//构造函数</span></span><br><span class="line">    <span class="built_in">int</span> val = x;         <span class="comment">// 节点值</span></span><br><span class="line">    ListNode? next;      <span class="comment">// 指向下一节点的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常用操作">常用操作</h1><h2 id="初始化">1. 初始化</h2><p>建立链表分为两步，第一步是初始化各个节点对象，第二步是构建节点之间的引用关系</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化链表 1 -&gt; 3 -&gt; 2 -&gt; 5 -&gt; 4 */</span></span><br><span class="line"><span class="comment">// 初始化各个节点</span></span><br><span class="line">ListNode n0 = <span class="keyword">new</span>(<span class="number">1</span>);</span><br><span class="line">ListNode n1 = <span class="keyword">new</span>(<span class="number">3</span>);</span><br><span class="line">ListNode n2 = <span class="keyword">new</span>(<span class="number">2</span>);</span><br><span class="line">ListNode n3 = <span class="keyword">new</span>(<span class="number">5</span>);</span><br><span class="line">ListNode n4 = <span class="keyword">new</span>(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 构建节点之间的引用</span></span><br><span class="line">n0.next = n1;</span><br><span class="line">n1.next = n2;</span><br><span class="line">n2.next = n3;</span><br><span class="line">n3.next = n4;</span><br></pre></td></tr></table></figure><p>我们通常将头节点当作链表的代称，比如以上代码中的链表可记作链表 n0。</p><h2 id="插入节点">2. 插入节点</h2><p>在链表中插入节点非常容易,只需改变两个节点引用（指针）即可，时间复杂度为 <spanclass="math inline">\(O(1)\)</span>，相比数组更高效（特别是大量数据的情况下）</p><p><img src="linked_list_1.png" alt="链表插入节点示例" /><br /></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在链表的节点 n0 之后插入节点 P */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span>(<span class="params">ListNode n0, ListNode P</span>)</span> &#123;</span><br><span class="line">    ListNode? n1 = n0.next;</span><br><span class="line">    P.next = n1;</span><br><span class="line">    n0.next = P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除节点">3. 删除节点</h2><p>删除节点也非常方便，只需改变一个节点的引用（指针）即可。</p><p>请注意，尽管在删除操作完成后节点 P 仍然指向 n1，但实际上遍历此链表已经无法访问到 P ，这意味着 P已经不再属于该链表了。</p><p><img src="linked_list_2.png" alt="链表删除节点" /><br /></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除链表的节点 n0 之后的首个节点 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">ListNode n0</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n0.next == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// n0 -&gt; P -&gt; n1</span></span><br><span class="line">    ListNode P = n0.next;</span><br><span class="line">    ListNode? n1 = P.next;</span><br><span class="line">    n0.next = n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问节点">4. 访问节点</h2><p>在链表中访问节点的效率较低。需要从头节点出发，逐个向后遍历，直至找到目标节点，时间复杂度为<span class="math inline">\(O(n)\)</span> ，而数组是 <spanclass="math inline">\(O(1)\)</span></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 访问链表中索引为 index 的节点 */</span></span><br><span class="line">ListNode? Access(ListNode? head, <span class="built_in">int</span> index) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找节点">5. 查找节点</h2><p>同样也是线性查找：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在链表中查找值为 target 的首个节点 */</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Find</span>(<span class="params">ListNode? head, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head.val == target)</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        head = head.next;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组-vs.-链表">数组 vs. 链表</h1><table><thead><tr><th></th><th>数组</th><th>链表</th></tr></thead><tbody><tr><td>存储方式</td><td>连续内存空间</td><td>分散内存空间</td></tr><tr><td>容量扩展</td><td>长度不可变</td><td>可灵活扩展</td></tr><tr><td>内存效率</td><td>元素占用内存少、但可能浪费空间</td><td>元素占用内存多</td></tr><tr><td>访问元素</td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(n)\)</span></td></tr><tr><td>添加元素</td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(1)\)</span></td></tr><tr><td>删除元素</td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(1)\)</span></td></tr></tbody></table><h1 id="常见链表类型">常见链表类型</h1><ul><li><strong>单向链表</strong>：即前面介绍的普通链表。单向链表的节点包含值和指向下一节点的引用两项数据。我们将首个节点称为头节点，将最后一个节点称为尾节点，尾节点指向空None 。</li><li><strong>环形链表</strong>：如果我们令单向链表的尾节点指向头节点（首尾相接），则得到一个环形链表。在环形链表中，任意节点都可以视作头节点。</li><li><strong>双向链表</strong>：与单向链表相比，双向链表记录了两个方向的引用。双向链表的节点定义同时包含指向后继节点（下一个节点）和前驱节点（上一个节点）的引用（指针）。相较于单向链表，双向链表更具灵活性，可以朝两个方向遍历链表，但相应地也需要占用更多的内存空间。</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 双向链表节点类 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ListNode</span>(<span class="title">int</span> <span class="title">x</span>) &#123;  <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">int</span> val = x;    <span class="comment">// 节点值</span></span><br><span class="line">    ListNode next;  <span class="comment">// 指向后继节点的引用</span></span><br><span class="line">    ListNode prev;  <span class="comment">// 指向前驱节点的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="linked_list_3.png" alt="常见链表种类" /><br /></p><h1 id="典型应用">典型应用</h1><h2 id="单向链表">单向链表</h2><ul><li><strong>栈与队列</strong>：当插入和删除操作都在链表的一端进行时，它表现的特性为先进后出，对应栈；当插入操作在链表的一端进行，删除操作在链表的另一端进行，它表现的特性为先进先出，对应队列。</li><li><strong>哈希表</strong>：链式地址是解决哈希冲突的主流方案之一，在该方案中，所有冲突的元素都会被放到一个链表中。</li><li><strong>图</strong>：邻接表是表示图的一种常用方式，其中图的每个顶点都与一个链表相关联，链表中的每个元素都代表与该顶点相连的其他顶点。</li></ul><h2 id="环形链表">环形链表</h2><p>常用于需要周期性操作的场景，比如操作系统的资源调度。</p><ul><li><strong>时间片轮转调度算法</strong>：在操作系统中，时间片轮转调度算法是一种常见的CPU调度算法，它需要对一组进程进行循环。每个进程被赋予一个时间片，当时间片用完时，CPU将切换到下一个进程。这种循环操作可以通过环形链表来实现。</li><li><strong>数据缓冲区</strong>：在某些数据缓冲区的实现中，也可能会使用环形链表。比如在音频、视频播放器中，数据流可能会被分成多个缓冲块并放入一个环形链表，以便实现无缝播放。</li></ul><h2 id="双向链表">双向链表</h2><p>常用于需要快速查找前一个和后一个元素的场景：</p><ul><li><strong>高级数据结构</strong>：比如在红黑树、B树中，我们需要访问节点的父节点，这可以通过在节点中保存一个指向父节点的引用来实现，类似于双向链表。</li><li><strong>浏览器历史</strong>：在网页浏览器中，当用户点击前进或后退按钮时，浏览器需要知道用户访问过的前一个和后一个网页。双向链表的特性使得这种操作变得简单。</li><li><strong>LRU算法</strong>：在缓存淘汰（LRU）算法中，我们需要快速找到最近最少使用的数据，以及支持快速添加和删除节点。这时候使用双向链表就非常合适。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;存储数组的内存空间必须是连续的，而当数组非常大时，内存可能无法提供如此大的连续空间。此时链表的灵活性优势就体现出来了。&lt;/p&gt;
&lt;p&gt;和数组一样，链表（linked
list）是一种线性数据结构，其中的每个元素都是一个节点对象，各个节点通过
“引用”
相连接。引用记</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="04-数组与链表" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>4.1 数组</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/4.1-%E6%95%B0%E7%BB%84/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/4.1-%E6%95%B0%E7%BB%84/</id>
    <published>2025-07-16T02:07:42.000Z</published>
    <updated>2025-07-16T02:36:15.320Z</updated>
    
    <content type="html"><![CDATA[<p>数组（array）是一种线性数据结构，其将<strong>相同类型</strong>的元素存储在连续的内存空间中。</p><p><img src="array_0.png" alt="数组定义与存储方式" /><br /></p><h1 id="常用操作">常用操作</h1><h2 id="初始化">1. 初始化</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 初始化数组 */</span></span><br><span class="line"><span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]; <span class="comment">// [ 0, 0, 0, 0, 0 ]</span></span><br><span class="line"><span class="built_in">int</span>[] nums = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>一般有两种初始化方式：无初始值、给定初始值。在未指定初始值的情况下，大多数编程语言会将数组元素初始化为<span class="math inline">\(0\)</span> 。</p><h2 id="访问元素">2. 访问元素</h2><p>数组元素被存储在连续的内存空间中，给定数组内存地址（首元素内存地址）和某个元素的索引，通过下图的计算就可以算出指定元素的内存地址：</p><p><img src="array_1.png" alt="数组元素的内存地址计算" /><br /></p><p>数组首个元素的索引为 <span class="math inline">\(0\)</span>，这似乎有些反直觉，因为从 <span class="math inline">\(1\)</span>开始计数会更自然。但从地址计算公式的角度看，索引本质上是内存地址的偏移量。首个元素的地址偏移量是<span class="math inline">\(0\)</span> ，因此它的索引为 <spanclass="math inline">\(0\)</span> 是合理的。</p><p>在数组中访问元素非常高效，我们可以在 <spanclass="math inline">\(O(1)\)</span>时间内随机访问数组中的任意一个元素</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 随机访问元素 */</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">RandomAccess</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">    Random random = <span class="keyword">new</span>();</span><br><span class="line">    <span class="comment">// 在区间 [0, nums.Length) 中随机抽取一个数字</span></span><br><span class="line">    <span class="built_in">int</span> randomIndex = random.Next(nums.Length);</span><br><span class="line">    <span class="comment">// 获取并返回随机元素</span></span><br><span class="line">    <span class="built_in">int</span> randomNum = nums[randomIndex];</span><br><span class="line">    <span class="keyword">return</span> randomNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入元素">3. 插入元素</h2><p>在数组中间插入一个元素，需要将该元素之后的所有元素都向后移动一位，再把元素赋值给该索引：</p><p><img src="array_2.png" alt="数组插入元素示例" /><br /></p><p>由于数组的长度是固定的，因此插入一个元素必定会导致数组尾部元素 “丢失”。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在数组的索引 index 处插入元素 num */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> num, <span class="built_in">int</span> index</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 把索引 index 以及之后的所有元素向后移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = nums.Length - <span class="number">1</span>; i &gt; index; i--) &#123;</span><br><span class="line">        nums[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 num 赋给 index 处的元素</span></span><br><span class="line">    nums[index] = num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除元素">4. 删除元素</h2><p>若想删除索引 <span class="math inline">\(i\)</span>处的元素，则需要把索引 <span class="math inline">\(i\)</span>之后的元素都向前移动一位：</p><p><img src="array_3.png" alt="数组删除元素示例" /><br /></p><p>删除元素完成后，原先末尾的元素变得 “无意义”了，所以我们无须特意去修改它</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 删除索引 index 处的元素 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Remove</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> index</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 把索引 index 之后的所有元素向前移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = index; i &lt; nums.Length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        nums[i] = nums[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历数组">5. 遍历数组</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 遍历数组 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traverse</span>(<span class="params"><span class="built_in">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 通过索引遍历数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++) &#123;</span><br><span class="line">        count += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接遍历数组元素</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        count += num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找元素">6. 查找元素</h2><p>数组查找元素的操作是 “线性查找” ：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在数组中查找指定元素 */</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Find</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> target</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩容数组">7. 扩容数组</h2><p>在复杂的系统环境中，程序难以保证数组之后的内存空间是可用的，从而无法安全地扩展数组容量。因此在大多数编程语言中，<strong>数组的长度是不可变的</strong>。</p><p>如果我们希望扩容数组，则需重新建立一个更大的数组，然后把原数组元素依次复制到新数组。这是一个<span class="math inline">\(O(n)\)</span>的操作，在数组很大的情况下非常耗时。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 扩展数组长度 */</span></span><br><span class="line"><span class="function"><span class="built_in">int</span>[] <span class="title">Extend</span>(<span class="params"><span class="built_in">int</span>[] nums, <span class="built_in">int</span> enlarge</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化一个扩展长度后的数组</span></span><br><span class="line">    <span class="built_in">int</span>[] res = <span class="keyword">new</span> <span class="built_in">int</span>[nums.Length + enlarge];</span><br><span class="line">    <span class="comment">// 将原数组中的所有元素复制到新数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++) &#123;</span><br><span class="line">        res[i] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回扩展后的新数组</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组小结">数组小结</h1><h2 id="优缺点分析">优缺点分析</h2><p>优点：</p><ul><li><strong>空间效率高</strong>：数组为数据分配了连续的内存块，无须额外的结构开销，这也让访问、遍历、查找非常快</li><li><strong>支持随机访问</strong>：数组允许在 <spanclass="math inline">\(O(1)\)</span> 时间内访问任何元素</li><li><strong>缓存局部性</strong>：当访问数组元素时，计算机不仅会加载它，还会缓存其周围的其他数据，从而借助高速缓存来提升后续操作的执行速度</li></ul><p>缺点：</p><ul><li><strong>插入、删除效率低</strong>：时间复杂度高（<spanclass="math inline">\(O(n)\)</span>），需要移动大量元素</li><li><strong>长度不可变</strong>：数组在初始化后长度就固定了，扩容数组需要将所有数据复制到新数组，开销很大</li><li><strong>空间浪费</strong>：如果数组分配的大小超过实际所需，那么多余的空间就被浪费了</li></ul><h2 id="典型应用">典型应用</h2><ul><li>随机访问：如果我们想随机抽取一些样本，那么可以用数组存储，并生成一个随机序列，根据索引实现随机抽样。</li><li>排序和搜索：数组是排序和搜索算法最常用的数据结构。快速排序、归并排序、二分查找等都主要在数组上进行。</li><li>查找表：当需要快速查找一个元素或其对应关系时，可以使用数组作为查找表。假如我们想实现字符到ASCII 码的映射，则可以将字符的 ASCII码值作为索引，对应的元素存放在数组中的对应位置。</li><li>机器学习：神经网络中大量使用了向量、矩阵、张量之间的线性代数运算，这些数据都是以数组的形式构建的。数组是神经网络编程中最常使用的数据结构。</li><li>数据结构实现：数组可以用于实现栈、队列、哈希表、堆、图等数据结构。例如，图的邻接矩阵表示实际上是一个二维数组。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;数组（array）是一种线性数据结构，其将&lt;strong&gt;相同类型&lt;/strong&gt;的元素存储在连续的内存空间中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;array_0.png&quot; alt=&quot;数组定义与存储方式&quot; /&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;h1 id=&quot;常用操作&quot;&gt;常用</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="04-数组与链表" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/04-%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>3.3 数字编码</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.3-%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.3-%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81/</id>
    <published>2025-07-15T02:25:59.000Z</published>
    <updated>2025-07-15T03:06:16.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原码反码和补码">原码、反码和补码</h1><p>在上一节的表格中我们发现，所有整数类型能够表示的负数都比正数多一个，例如byte 的取值范围是 <span class="math inline">\([-128, 127]\)</span>。这个现象比较反直觉，我们需要先了解原码、反码和补码：</p><ul><li>原码：我们将数字的二进制表示的最高位视为符号位，其中 0 表示正数， 1表示负数，其余位表示数字的值。</li><li>反码：正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反。</li><li>补码：正数的补码与其原码相同，负数的补码是在其反码的基础上加 1。</li></ul><p><img src="num_encode_0.png"alt="原码、反码与补码之间的相互转换" /><br /></p><p><strong>在计算机中，数字是以“补码”的形式存储的</strong>，这一点非常重要，但为什么不用原码呢？</p><p>原码虽然最直观，但存在一些局限性。一方面，负数的原码不能直接用于运算。例如在原码下计算<span class="math inline">\(1 + (-2)\)</span> ，得到的结果是 <spanclass="math inline">\(-3\)</span> ，这显然是不对的。</p><p><span class="math display">\[\begin{align}1 + (-2) &amp;= 0000\,0001 + 1000\,0010 \\    &amp;= 1000\,0011 \\    &amp;= -3\end{align}\]</span></p><p>为了解决此问题，计算机引入了反码：</p><p><span class="math display">\[\begin{align}1 + (-2) &amp;= 0000\,0001(原码) + 1000\,0010(原码) \\    &amp;= 0000\,0001(反码) + 1111\,1101(反码) \\    &amp;= 1111\,1110(反码) \\    &amp;= 1000\,0001(原码) \\    &amp;= -1\end{align}\]</span></p><p>另一方面，数字零的原码有 <span class="math inline">\(-0\)</span> 和<span class="math inline">\(+0\)</span>两种表示方式。如果是这样，计算机要处理零相关的判断需要同时处理这两个，降低运行效率。为了统一正负零，计算机引入了补码：</p><p><span class="math display">\[\begin{align}-0 &amp;= 1000\,0000(原码) \\    &amp;= 1111\,1111(反码) \\    &amp;= 1\,0000\,0001(补码)\end{align}\]</span></p><p>在负零的反码基础上加 1 会产生进位，但 byte 类型的长度只有 8位，因此溢出到第 9 位的 1会被舍弃。因此得到的补码中，正负零都是同一个值了。</p><p>然而，补码 <span class="math inline">\(1000\,0000\)</span>是一个例外，它并没有对应的原码。根据转换方法，我们得到该补码的原码为<span class="math inline">\(0000\,0000\)</span>。这显然是矛盾的，因为该原码表示数字 <spanclass="math inline">\(0\)</span>，它的补码应该是自身。计算机规定这个特殊的补码 <spanclass="math inline">\(1000\,0000\)</span> 代表 <spanclass="math inline">\(-128\)</span> 。实际上，<spanclass="math inline">\((-1) + (-127)\)</span> 在补码下的计算结果就是<span class="math inline">\((-128)\)</span> 。</p><p><span class="math display">\[\begin{align}(-127) + (-1) &amp;= 1111\,1111(原码) + 1000\,0001(原码) \\    &amp;= 1000\,0000(反码) + 1111\,1110(反码) \\    &amp;= 1000\,0001(补码) + 1111\,1111(补码) \\    &amp;= 1000\,0000(补码) \\    &amp;= -128\end{align}\]</span></p><p>你可能已经发现了，上述所有计算都是加法运算。这暗示着一个重要事实：<strong>计算机内部的硬件电路主要是基于加法运算设计的</strong>。这是因为加法运算相对于其他运算（比如乘法、除法和减法）来说，硬件实现起来更简单，更容易进行并行化处理，运算速度更快。</p><p>通过将加法与一些基本逻辑运算结合，计算机能够实现各种其他的数学运算。例如，计算减法<span class="math inline">\(a - b\)</span> 可以转换为计算加法 <spanclass="math inline">\(a + (-b)\)</span>；计算乘法和除法可以转换为计算多次加法或减法。</p><h1 id="浮点数编码">浮点数编码</h1><p><img src="num_encode_1.png"alt="IEEE 754 标准下的 float 的计算示例" /><br /></p><p>我们这里所说的浮点数以 float 为准，double 是同理的</p><p>float 相较于 int 而言，两者都是 32 位的长度，但是 float表示的值范围要大得多，但副作用是牺牲了精度：由于指数位的存在，浮点数float 的数值越大，相邻两个数字之间的差值就会趋向越大。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原码反码和补码&quot;&gt;原码、反码和补码&lt;/h1&gt;
&lt;p&gt;在上一节的表格中我们发现，所有整数类型能够表示的负数都比正数多一个，例如
byte 的取值范围是 &lt;span class=&quot;math inline&quot;&gt;&#92;([-128, 127]&#92;)&lt;/span&gt;
。这个现象</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="03-数据结构" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>3.2 基本数据类型</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.2-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.2-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-07-15T01:54:14.000Z</published>
    <updated>2025-07-15T02:13:07.861Z</updated>
    
    <content type="html"><![CDATA[<p>基本数据类型是 CPU可以直接进行运算的类型。基本数据类型以二进制的形式存储在计算机中。一个二进制位即为1 比特。在绝大多数现代操作系统中，1 字节（byte）由 8比特（bit）组成。</p><p>以下是 C# 中的基本数据类型</p><table><colgroup><col style="width: 11%" /><col style="width: 13%" /><col style="width: 11%" /><col style="width: 25%" /><col style="width: 26%" /><col style="width: 11%" /></colgroup><thead><tr><th>类型分类</th><th>符号</th><th>占用空间</th><th>最小值</th><th>最大值</th><th>默认值</th></tr></thead><tbody><tr><td>整数</td><td><code>sbyte</code></td><td>1 字节</td><td><span class="math inline">\(-2^7\)</span></td><td><span class="math inline">\(2^7 - 1\)</span></td><td>0</td></tr><tr><td>整数</td><td><code>byte</code></td><td>1 字节</td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(2^8 - 1\)</span></td><td>0</td></tr><tr><td>整数</td><td><code>short</code></td><td>2 字节</td><td><span class="math inline">\(-2^{15}\)</span></td><td><span class="math inline">\(2^{15} - 1\)</span></td><td>0</td></tr><tr><td>整数</td><td><code>ushort</code></td><td>2 字节</td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(2^{16} - 1\)</span></td><td>0</td></tr><tr><td>整数</td><td><code>int</code></td><td>4 字节</td><td><span class="math inline">\(-2^{31}\)</span></td><td><span class="math inline">\(2^{31} - 1\)</span></td><td>0</td></tr><tr><td>整数</td><td><code>uint</code></td><td>4 字节</td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(2^{32} - 1\)</span></td><td>0</td></tr><tr><td>整数</td><td><code>long</code></td><td>8 字节</td><td><span class="math inline">\(-2^{63}\)</span></td><td><span class="math inline">\(2^{63} - 1\)</span></td><td>0</td></tr><tr><td>整数</td><td><code>ulong</code></td><td>8 字节</td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(2^{64} - 1\)</span></td><td>0</td></tr><tr><td>浮点数</td><td><code>float</code></td><td>4 字节</td><td><span class="math inline">\(\approx -3.4 \times10^{38}\)</span></td><td><span class="math inline">\(\approx 3.4 \times 10^{38}\)</span></td><td>0.0f</td></tr><tr><td>浮点数</td><td><code>double</code></td><td>8 字节</td><td><span class="math inline">\(\approx -1.8 \times10^{308}\)</span></td><td><span class="math inline">\(\approx 1.8 \times10^{308}\)</span></td><td>0.0d</td></tr><tr><td>字符</td><td><code>char</code></td><td>2 字节</td><td><code>U+0000</code></td><td><code>U+FFFF</code></td><td><code>\0</code></td></tr><tr><td>布尔</td><td><code>bool</code></td><td>1 字节</td><td><code>false</code></td><td><code>true</code></td><td>false</td></tr></tbody></table><p>需要注意：</p><ul><li>字符 char 的大小在 C 和 C++ 中为 1字节，在大多数编程语言中取决于特定的字符编码方法。</li><li>即使表示布尔量仅需 1 位（0 或 1），它在内存中通常也存储为 1字节。这是因为现代计算机 CPU 通常将 1 字节作为最小寻址内存单元。</li></ul><p>基本数据类型提供了数据的 “内容类型” ，而数据结构提供了数据的“组织方式”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基本数据类型是 CPU
可以直接进行运算的类型。基本数据类型以二进制的形式存储在计算机中。一个二进制位即为
1 比特。在绝大多数现代操作系统中，1 字节（byte）由 8
比特（bit）组成。&lt;/p&gt;
&lt;p&gt;以下是 C# 中的基本数据类型&lt;/p&gt;
&lt;table&gt;</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="03-数据结构" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>3.1 数据结构的分类</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E7%B1%BB/</id>
    <published>2025-07-15T01:41:15.000Z</published>
    <updated>2025-07-15T01:51:43.910Z</updated>
    
    <content type="html"><![CDATA[<p>常见的数据结构包括：数组、链表、栈、队列、哈希表、树、堆、图</p><p>数据结构的分类，按照逻辑结构分：</p><ul><li>线性</li><li>非线性</li></ul><p>按照物理结构分：</p><ul><li>连续</li><li>分散</li></ul><h1 id="线性和非线性">线性和非线性</h1><ul><li>线性数据结构：元素之间是一对一的顺序关系，比如数组、链表、栈、队列、哈希表</li><li>非线性数据结构：元素之间是一对多或者多对多的关系<ul><li>树形结构（一对多）：树、堆、哈希表</li><li>网状结构（多对多）：图</li></ul></li></ul><p><img src="data_struct_0.png"alt="线性数据结构与非线性数据结构" /><br /></p><h1 id="连续与分散">连续与分散</h1><p>当算法程序运行时，正在处理的数据主要存储在内存中。系统通过内存地址来访问目标位置的数据。</p><p><img src="data_struct_1.png"alt="内存条、内存空间、内存地址" /><br /></p><p>在数据结构与算法的设计中，内存资源是一个重要的考虑因素。算法所占用的内存峰值不应超过系统剩余空闲内存；如果缺少连续大块的内存空间，那么所选用的数据结构必须能够存储在分散的内存空间内。</p><p><img src="data_struct_2.png"alt="连续空间存储与分散空间存储" /><br /></p><p>值得说明的是，所有数据结构都是基于数组、链表或二者的组合实现的。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。</p><ul><li>基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 <spanclass="math inline">\(\ge3\)</span> 的数组）等。</li><li>基于链表可实现：栈、队列、哈希表、树、堆、图等。</li></ul><p>链表在初始化后，仍可以在程序运行过程中对其长度进行调整，因此也称“动态数据结构”。数组在初始化后长度不可变，因此也称“静态数据结构”。值得注意的是，数组可通过重新分配内存实现长度变化，从而具备一定的“动态性”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;常见的数据结构包括：数组、链表、栈、队列、哈希表、树、堆、图&lt;/p&gt;
&lt;p&gt;数据结构的分类，按照逻辑结构分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性&lt;/li&gt;
&lt;li&gt;非线性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按照物理结构分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连续&lt;/li&gt;
</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="03-数据结构" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>01.方法和函数</title>
    <link href="https://peiyuzou.github.io/wiki/98-%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9/01.%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/"/>
    <id>https://peiyuzou.github.io/wiki/98-%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9/01.%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/</id>
    <published>2025-07-15T01:34:16.000Z</published>
    <updated>2025-07-15T01:37:37.646Z</updated>
    
    <content type="html"><![CDATA[<p>函数（function）可以被独立执行，所有参数都以显式传递。方法（method）与一个对象关联，被隐式传递给调用它的对象，能够对类的实例中包含的数据进行操作。</p><p>下面以几种常见的编程语言为例来说明：</p><ul><li>C语言是过程式编程语言，没有面向对象的概念，所以只有函数。但我们可以通过创建结构体（struct）来模拟面向对象编程，与结构体相关联的函数就相当于其他编程语言中的方法。</li><li>Java 和 C#是面向对象的编程语言，代码块（方法）通常作为某个类的一部分。静态方法的行为类似于函数，因为它被绑定在类上，不能访问特定的实例变量。</li><li>C++ 和 Python既支持过程式编程（函数），也支持面向对象编程（方法）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;函数（function）可以被独立执行，所有参数都以显式传递。方法（method）与一个对象关联，被隐式传递给调用它的对象，能够对类的实例中包含的数据进行操作。&lt;/p&gt;
&lt;p&gt;下面以几种常见的编程语言为例来说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C
语言是过程式编程语言，</summary>
      
    
    
    
    <category term="98-易混淆点" scheme="https://peiyuzou.github.io/categories/98-%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9/"/>
    
    
    <category term="易混淆点" scheme="https://peiyuzou.github.io/tags/%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>03.中央处理器</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/03.%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/03.%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2025-07-14T13:56:30.000Z</published>
    <updated>2025-07-16T02:04:01.566Z</updated>
    
    <content type="html"><![CDATA[<p>中央处理器，常称 CPU（Central ProcessingUnit），我们本篇从一个高层次视角去了解 CPU的组成，每一个根线不是指代真正的数据线，而是一组完善电路的抽象，代表这里有某种连接，这种高层次视角称“微体系架构” （MicroArchitecture）</p><h1 id="cpu-组成">CPU 组成</h1><p>首先，我们要准备一个 RAM ，但注意<strong>内存不是 CPU的组成部分</strong>，这里是为了演示 CPU如何和内存打交道，进而解释它每个组成部分在其中发挥的作用。</p><p>为了简单，我们假设有一个只有 16 个地址的RAM（如下图所示），因此它的地址可以用 4 位值表示（0 ~ 15），这 16个地址中存储了若干的指令或者数据。对于数据来说，其中的 8位都是值。对于指令来说，高 4 位代表操作码，低 4位代表目标数据在内存或者寄存器中的地址。（这里只是举例，在实际的内存中可能和这个设计不一样，也可能更复杂）</p><p><img src="cpu_0.png" alt="内存" /><br /></p><h2 id="设立寄存器">设立寄存器</h2><p>为了操作数据和存储临时数据，我们需要给 CPU 安排 4 个寄存器：</p><p><img src="cpu_1.png" alt="临时存储和操作数据的寄存器" /><br /></p><p>我们给 CPU 支持的所有指令分配一个操作码，对应上面指令中的高 4位，比如下图：</p><p><img src="cpu_2.png" alt="指令表" /><br /></p><p>我们还需要另外两个寄存器：</p><ul><li>指令地址寄存器：用于追踪当前程序运行到哪里，存储的是指令在内存中的地址</li><li>指令寄存器：用于存储当前指令，方便 CPU 解码这个指令</li></ul><p><img src="cpu_3.png" alt="指令地址寄存器 和 指令寄存器" /><br /></p><p>计算机开始运行，所有寄存器被初始化为 0 ：</p><p><img src="cpu_4.png" alt="初始化寄存器" /><br /></p><h2 id="取指令">取指令</h2><p>计算机从内存中取指令，然后一条一条执行，首先指令地址寄存器访问内存的第一个地址，并且将第一个地址的内容（一条指令）放入指令寄存器中：</p><p><img src="cpu_5.png" alt="取指令阶段" /><br /></p><h2 id="解释并执行指令">解释并执行指令</h2><p>得到了一条指令后，计算机需要将这条指令解释。它的高 4位的值对应指令表中的第一条，即将指定内存地址的值放入寄存器 A 中：</p><p><img src="cpu_6.png" alt="解释并执行" /><br /></p><h2 id="继续取指令解释执行">继续取指令、解释、执行</h2><p>执行完一条指令后，指令地址寄存器指向的内存地址 + 1，继续读取下一条指令，然后解释执行。</p><h1 id="控制单元">控制单元</h1><p>由指令地址寄存器、指令寄存器、解码电路等部分组成了一个控制单元（ControlUnit），我们可以将它抽象出来：</p><p><img src="cpu_7.png" alt="控制单元" /><br /></p><h1 id="继续执行">继续执行</h1><h2 id="第二条指令">第二条指令</h2><p>CPU 继续取下一条指令并执行，第二条指令将内存地址 15 的值放在了寄存器B 中：</p><p><img src="cpu_8.png" alt="第二条指令的执行结果" /><br /></p><h2 id="第三条指令">第三条指令</h2><p>第三条指令比较特殊，它代表将两个寄存器的值相加，并将结果放在指定的第二个寄存器中，这里寄存器A 的地址为 00 ，寄存器 B 的地址为 01 ，因此是要将 B 中的值与 A中的值相加，结果放入 A 中：</p><p><img src="cpu_9.png" alt="第三条指令的解释阶段" /><br /></p><p>为了对两个值做算数运算，我们需要继续设立一个 ALU进来，控制单元会将两个寄存器的值作为 ALU 的两个输入，然后传递 ALU当前的操作码，计算得到的值并不会马上写入寄存器，而是放在一个临时的寄存器中（图中没有），当关闭ALU 之后再写入寄存器 A ，防止 ALU 的值错误：</p><p><img src="cpu_10.png" alt="第三条指令的执行阶段" /><br /></p><h2 id="最后一条指令">最后一条指令</h2><p>最后一条指令，将寄存器 A 中的值写入内存中：</p><p><img src="cpu_11.png" alt="第四条指令的执行结果" /><br /></p><h1 id="时钟">时钟</h1><p>时钟（Clock）用来管理 CPU 的执行节奏。</p><p><img src="cpu_12.png" alt="时钟" /><br /></p><p>它以精确的间隔来触发电信号，控制单元根据这个电信号去推动 CPU的内部操作。这频率不能太快，因为电的传输也需要时间（很少很少）。</p><p>CPU 执行一次 “取指令-解码-执行” 的速度叫做 “时钟速度”，它的单位是赫兹（Hz），现代 CPU 的主频已经达到了 GHz级别，我们常说的超频就是允许 CPU以更快的速度执行，但会增大用电量，并且可能损坏 CPU ，同样，许多 CPU也有降频功能，在闲置的时间段内降频可以降低耗电量，这些都是通过改变时钟速度实现的。</p><h1 id="对-cpu-做一次抽象">对 CPU 做一次抽象</h1><p>现在我们得到了一个简单的 CPU ，可以对它进行一次抽象：</p><p><img src="cpu_13.png" alt="CPU" /><br /></p><p>从这里也可以看出来，RAM 不是 CPU 的组成部分，但它们息息相关</p><h1 id="指令集">指令集</h1><p>上面提到的操作码，在实际计算机中远不止 4 个，也不止 4位，比如常见的让程序停止运行的 HALT指令等。为了让指令能更多，有两个策略：</p><ul><li>直接用更多位来表示指令，比如 32 位甚至 64 位</li><li>采用可变指令长度，比如 JUMP 指令占 8位，但它后面需要跟一个立即值，代表要跳转的内存地址，这样设计的话，指令长度可以是任意的，但是CPU 在读取阶段会更加复杂一些</li></ul><p>CPU 可以识别的这样一批指令叫做指令集，现代的 CPU 拥有上千条的指令，光ADD 指令都有很多变种，比我们例子中的要复杂很多，但是核心原理没有变。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;中央处理器，常称 CPU（Central Processing
Unit），我们本篇从一个高层次视角去了解 CPU
的组成，每一个根线不是指代真正的数据线，而是一组完善电路的抽象，代表这里有某种连接，这种高层次视角称
“微体系架构” （MicroArchitectur</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CrashCourse" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/"/>
    
    
    <category term="CS-101" scheme="https://peiyuzou.github.io/tags/CS-101/"/>
    
  </entry>
  
  <entry>
    <title>2.4 空间复杂度</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.4-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.4-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2025-07-14T09:45:37.000Z</published>
    <updated>2025-07-14T10:01:27.976Z</updated>
    
    <content type="html"><![CDATA[<p>空间复杂度（spacecomplexity）用于衡量算法占用内存空间随着数据量变大时的增长趋势。</p><h1 id="算法相关空间">算法相关空间</h1><p>算法在运行过程中使用的内存空间主要包括以下几种。</p><ul><li>输入空间：用于存储算法的输入数据</li><li>暂存空间：用于存储算法在运行过程中的变量、对象、函数上下文等数据<ul><li>暂存数据：用于保存算法运行过程中的各种常量、变量、对象等</li><li>栈帧空间：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放</li><li>指令空间：用于保存编译后的程序指令，在实际统计中通常忽略不计</li></ul></li><li>输出空间：用于存储算法的输出数据</li></ul><p>一般情况下，空间复杂度的统计范围是 “暂存空间” 加上 “输出空间” ：</p><p><img src="space_complex_0.png" alt="算法使用的相关空间" /><br /></p><p>代码举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 结构体 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node *next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行某些操作...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;        <span class="comment">// 输入数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>;          <span class="comment">// 暂存数据（常量）</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;                <span class="comment">// 暂存数据（变量）</span></span><br><span class="line">    Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>); <span class="comment">// 暂存数据（对象）</span></span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">func</span>();           <span class="comment">// 栈帧空间（调用函数）</span></span><br><span class="line">    <span class="keyword">return</span> a + b + c;         <span class="comment">// 输出数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="推算方法">推算方法</h1><p><strong>我们通常只关注最差空间复杂度</strong>。因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留：</p><ul><li>以最差输入数据为准</li><li>以算法运行中的峰值内存为准</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Algorithm</span>(<span class="params"><span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">0</span>;                   <span class="comment">// O(1)</span></span><br><span class="line">    <span class="built_in">int</span>[] b = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10000</span>];    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = <span class="keyword">new</span> <span class="built_in">int</span>[n]; <span class="comment">// O(n)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子，最差空间复杂度为 <spanclass="math inline">\(O(n)\)</span></p><p>在递归函数中，需要注意统计栈帧空间：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Function</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 循环的空间复杂度为 O(1) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Loop</span>(<span class="params"><span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Function();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 递归的空间复杂度为 O(n) */</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Recur</span>(<span class="params"><span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Recur(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常见类型">常见类型</h1><p><img src="space_complex_1.png" alt="常见的空间复杂度类型" /><br /></p><h2 id="常数阶-o1">常数阶 <span class="math inline">\(O(1)\)</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 常数阶 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Constant</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 常量、变量、对象占用 O(1) 空间</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10000</span>];</span><br><span class="line">    ListNode node = <span class="built_in">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 循环中的变量占用 O(1) 空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环中的函数占用 O(1) 空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">Function</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性阶-on">线性阶 <span class="math inline">\(O(n)\)</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性阶 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Linear</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 长度为 n 的数组占用 O(n) 空间</span></span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="comment">// 长度为 n 的列表占用 O(n) 空间</span></span><br><span class="line">    List&lt;ListNode&gt; nodes = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nodes.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">ListNode</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度为 n 的哈希表占用 O(n) 空间</span></span><br><span class="line">    Dictionary&lt;<span class="type">int</span>, string&gt; map = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        map.<span class="built_in">Add</span>(i, i.<span class="built_in">ToString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平方阶-on2">平方阶 <spanclass="math inline">\(O(n^2)\)</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 平方阶 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Quadratic</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 矩阵占用 O(n^2) 空间</span></span><br><span class="line">    <span class="type">int</span>[,] numMatrix = <span class="keyword">new</span> <span class="type">int</span>[n, n];</span><br><span class="line">    <span class="comment">// 二维列表占用 O(n^2) 空间</span></span><br><span class="line">    List&lt;List&lt;<span class="type">int</span>&gt;&gt; numList = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>&gt; tmp = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            tmp.<span class="built_in">Add</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        numList.<span class="built_in">Add</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指数阶-o2n">指数阶 <spanclass="math inline">\(O(2^n)\)</span></h2><p>指数阶常见于二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指数阶（建立满二叉树） */</span></span><br><span class="line">TreeNode? <span class="built_in">BuildTree</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> null;</span><br><span class="line">    TreeNode root = <span class="built_in">new</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        left = <span class="built_in">BuildTree</span>(n - <span class="number">1</span>),</span><br><span class="line">        right = <span class="built_in">BuildTree</span>(n - <span class="number">1</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对数阶-olog-n">对数阶 <span class="math inline">\(O(logn)\)</span></h2><p>对数阶常见于分治算法。例如归并排序，输入长度为 n的数组，每轮递归将数组从中点处划分为两半，形成高度为 <spanclass="math inline">\(log_{2}n\)</span> 的递归树，使用 <spanclass="math inline">\(O(log_{2}n)\)</span> 栈帧空间。</p><h1 id="权衡时间与空间">权衡时间与空间</h1><p><strong>降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然</strong>。我们将牺牲内存空间来提升算法运行速度的思路称为“以空间换时间” ；反之，则称为 “以时间换空间” 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;空间复杂度（space
complexity）用于衡量算法占用内存空间随着数据量变大时的增长趋势。&lt;/p&gt;
&lt;h1 id=&quot;算法相关空间&quot;&gt;算法相关空间&lt;/h1&gt;
&lt;p&gt;算法在运行过程中使用的内存空间主要包括以下几种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入空间：用于存储</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="02-复杂度分析" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2.3 时间复杂度</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.3-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.3-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2025-07-14T07:58:59.000Z</published>
    <updated>2025-07-14T09:46:12.527Z</updated>
    
    <content type="html"><![CDATA[<p>时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势</p><h1 id="统计时间增长趋势">统计时间增长趋势</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法 A 的时间复杂度：常数阶</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm_A</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 算法 B 的时间复杂度：线性阶</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm_B</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 算法 C 的时间复杂度：常数阶</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm_C</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析这个例子：</p><ul><li>算法 A 运行时间不随 n 的增大而增长，它的时间复杂度为 “常数阶”</li><li>算法 B 运行时间随着 n 增大呈线性增长。此算法的时间复杂度被称为“线性阶”</li><li>算法 C 虽然运行时间很长，但它与输入数据大小与 n 无关，因此也是“常数阶”</li></ul><h1 id="时间复杂度推算方法">时间复杂度推算方法</h1><h2 id="第一步统计操作数量">第一步：统计操作数量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    a = a + n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> * n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码如果精确地统计它的操作数量，应该是这样：</p><p><span class="math display">\[ T(n) = 2n(n + 1) + 5(n + 1) + 2 = 2n^2+ 7n + 3 \]</span></p><p>它的时间复杂度为 <span class="math inline">\(O(n^2)\)</span>（时间复杂度由 <span class="math inline">\(T(n)\)</span>中最高阶的项来决定），但我们可以通过技巧来快速推断：</p><ul><li>舍掉常数和系数，因为它们不会影响最终的计算</li><li>循环嵌套时使用乘法</li></ul><p>所以上述代码，我们可以直接得到操作数量：</p><p><span class="math display">\[ T(n) = n^2 + n \]</span></p><p>转为时间复杂度为 <span class="math inline">\(O(n^2)\)</span></p><h1 id="常见类型">常见类型</h1><p><img src="time_complex_0.png" alt="常见的时间复杂度类型" /><br /></p><p>以下分别用 C++ 代码举例：</p><h2 id="常数阶-o1">常数阶 <span class="math inline">\(O(1)\)</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 常数阶 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">constant</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性阶-on">线性阶 <span class="math inline">\(O(n)\)</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性阶 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">linear</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平方阶-on2">平方阶 <spanclass="math inline">\(O(n^2)\)</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 平方阶 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quadratic</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环次数与数据大小 n 成平方关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指数阶-o2n">指数阶 <spanclass="math inline">\(O(2^n)\)</span></h2><p>以 “细胞分裂” 为例，每轮是上一次的两倍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指数阶（循环实现） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exponential</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>, base = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 细胞每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; base; j++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        base *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对数阶-olog-n">对数阶 <span class="math inline">\(O(logn)\)</span></h2><p>与指数阶相反，对数阶反映了“每轮缩减到一半”的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对数阶（循环实现） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">logarithmic</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        n = n / <span class="number">2</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性对数阶-on-log-n">线性对数阶 <span class="math inline">\(O(nlog n)\)</span></h2><p>线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 <spanclass="math inline">\(O(n)\)</span> 和 <span class="math inline">\(O(logn)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性对数阶 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">linearLogRecur</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">linearLogRecur</span>(n / <span class="number">2</span>) + <span class="built_in">linearLogRecur</span>(n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阶乘阶-on">阶乘阶 <spanclass="math inline">\(O(n!)\)</span></h2><p>阶乘阶对应数学上的 “全排列” 问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 阶乘阶（递归实现） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorialRecur</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从 1 个分裂出 n 个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count += <span class="built_in">factorialRecur</span>(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最差最佳平均时间复杂度">最差、最佳、平均时间复杂度</h1><p>算法的时间效率往往不是固定的，而是与输入数据的分布有关。因此我们的算法的时间复杂度可能会变化。</p><p>我们在实际中很少使用最佳时间复杂度，因为通常只有在很小概率下才能达到，可能会带来一定的误导性。而最差时间复杂度更为实用，因为它给出了一个效率安全值，让我们可以放心地使用算法。</p><p>平均时间复杂度则是体现算法在随机输入数据下的运行效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势&lt;/p&gt;
&lt;h1 id=&quot;统计时间增长趋势&quot;&gt;统计时间增长趋势&lt;/h1&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="02-复杂度分析" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2.2 迭代和递归</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.2-%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.2-%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92/</id>
    <published>2025-07-14T07:36:59.000Z</published>
    <updated>2025-07-14T08:13:42.586Z</updated>
    
    <content type="html"><![CDATA[<p>在算法中，重复执行某个任务是很常见的，它与复杂度分析息息相关。常见的重复执行有迭代和递归，这两者也经常被搞混</p><h1 id="迭代">迭代</h1><p>迭代是在满足一定的条件下重复执行某段代码，直到这个条件不再满足，一般有以下几种：</p><ul><li>for 循环</li><li>while 循环</li><li>嵌套循环</li></ul><h1 id="递归">递归</h1><p>递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。</p><ul><li>递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li><li>归：触发 “终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li></ul><p>而从实现的角度看，递归代码主要包含三个要素。</p><ul><li>终止条件：用于决定什么时候由 “递” 转 “归”。</li><li>递归调用：对应 “递”，函数调用自身，通常输入更小或更简化的参数。</li><li>返回结果：对应 “归”，将当前递归层级的结果返回至上一层。</li></ul><p><img src="recursion_sum.png" alt="求和函数的递归过程" /><br /></p><h2 id="调用栈">调用栈</h2><p>递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果：</p><ul><li>函数的上下文数据都存储在称为 “栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，递归通常比迭代更加耗费内存空间。</li><li>递归调用函数会产生额外的开销。因此递归通常比循环的时间效率更低。</li></ul><p>在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出错误。</p><h2 id="尾递归">尾递归</h2><p>如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tailrecursion）。</p><p>为什么尾递归可以优化？因为尾递归中，递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。</p><h2 id="递归树">递归树</h2><p>当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。</p><p>思考实现一个斐波那契数列的计算，数列中的每个数字是前两个数字的和，即<span class="math inline">\(f(n) = f(n - 1) + f(n - 2)\)</span> ，C++函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 斐波那契数列：递归 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件 f(1) = 0, f(2) = 1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递归调用 f(n) = f(n-1) + f(n-2)</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">fib</span>(n - <span class="number">1</span>) + <span class="built_in">fib</span>(n - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 返回结果 f(n)</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在函数内递归调用了两个函数，这意味着从一个调用产生了两个调用分支。这样不断递归调用下去，最终将产生一棵层数为n 的递归树（recursion tree）。</p><p><img src="recursion_tree.png" alt="斐波那契数列的递归树" /><br /></p><p>从本质上看，递归体现了 “将问题分解为更小子问题”的思维范式，这种分治策略至关重要。</p><ul><li>从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。</li><li>从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。</li></ul><h1 id="两者对比">两者对比</h1><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr><th></th><th>迭代</th><th>递归</th></tr></thead><tbody><tr><td>实现方式</td><td>循环结构</td><td>函数调用自身</td></tr><tr><td>时间效率</td><td>效率通常较高，无函数调用开销</td><td>每次函数调用都会产生开销</td></tr><tr><td>内存使用</td><td>通常使用固定大小的内存空间</td><td>累积函数调用可能使用大量的栈帧空间</td></tr><tr><td>适用问题</td><td>适用于简单循环任务，代码直观、可读性好</td><td>适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在算法中，重复执行某个任务是很常见的，它与复杂度分析息息相关。常见的重复执行有迭代和递归，这两者也经常被搞混&lt;/p&gt;
&lt;h1 id=&quot;迭代&quot;&gt;迭代&lt;/h1&gt;
&lt;p&gt;迭代是在满足一定的条件下重复执行某段代码，直到这个条件不再满足，一般有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="02-复杂度分析" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2.1 数据结构和算法概览</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.1-%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E8%AF%84%E4%BC%B0/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.1-%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E8%AF%84%E4%BC%B0/</id>
    <published>2025-07-14T07:16:59.000Z</published>
    <updated>2025-07-14T07:32:48.803Z</updated>
    
    <content type="html"><![CDATA[<p>算法的目标：</p><ul><li>找到问题解法</li><li>寻找最优解法</li></ul><p>所以<strong>算法效率</strong>是评价算法优劣的指标，包含两个维度：</p><ul><li>时间效率</li><li>空间效率</li></ul><p>效率评估的方法主要分：实际测试、理论估算</p><h1 id="实际测试">实际测试</h1><p>对比两个算法最直接的方式是用一台计算机直接运行然后对比它们的运行时间和内存占用情况，但是这种方式也存在很大的局限性：</p><ul><li>难以排除测试环境的干扰因素。测试机器的硬件会影响我们的测试，比如一个算法的并行度较高，那么它就更适合在多核CPU上运行，一个算法的内存操作密集，那么它在高性能内存上的表现就会更好。但我们不可能在大量机器上做测试对比。</li><li>展开完整测试非常耗费资源。随着输入数据量的变化，算法会表现出不同的效率。但我们的测试输入样例是有限的。</li></ul><h1 id="理论估算">理论估算</h1><p>由于实际测试具有较大的局限性，所以一般我们使用<strong>复杂度分析</strong>来评估算法，它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;算法的目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到问题解法&lt;/li&gt;
&lt;li&gt;寻找最优解法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以&lt;strong&gt;算法效率&lt;/strong&gt;是评价算法优劣的指标，包含两个维度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间效率&lt;/li&gt;
&lt;li&gt;空间效</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="02-复杂度分析" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>1.1 数据结构和算法概览</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/01-%E6%A6%82%E8%A7%88/1.1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/01-%E6%A6%82%E8%A7%88/1.1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/</id>
    <published>2025-07-14T07:02:48.000Z</published>
    <updated>2025-07-16T03:13:46.957Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据结构与算法这部分的内容是对 Hello算法（https://www.hello-algo.com/）做的个人笔记，转载请标注来源。</p></blockquote><h1 id="算法定义">算法定义</h1><p>算法（algorithm）是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性。</p><ul><li>问题是明确的，包含清晰的输入和输出定义。</li><li>具有可行性，能够在有限步骤、时间和内存空间下完成。</li><li>各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。</li></ul><h1 id="数据结构定义">数据结构定义</h1><p>数据结构（datastructure）是组织和存储数据的方式，涵盖数据内容、数据之间关系和数据操作方法，它具有以下设计目标。</p><ul><li>空间占用尽量少，以节省计算机内存。</li><li>数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。</li><li>提供简洁的数据表示和逻辑信息，以便算法高效运行。</li></ul><p>数据结构设计是一个充满权衡的过程。如果想在某方面取得提升，往往需要在另一方面作出妥协。下面举两个例子。</p><ul><li>链表相较于数组，在数据添加和删除操作上更加便捷，但牺牲了数据访问速度。</li><li>图相较于链表，提供了更丰富的逻辑信息，但需要占用更大的内存空间。</li></ul><h1 id="数据结构与算法的关系">数据结构与算法的关系</h1><ul><li>数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。</li><li>算法为数据结构注入生命力。数据结构本身仅存储数据信息，结合算法才能解决特定问题。</li><li>算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据结构与算法这部分的内容是对 Hello
算法（https://www.hello-algo.com/）做的个人笔记，转载请标注来源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;算法定义&quot;&gt;算法定义&lt;/h1&gt;
&lt;p&gt;算法（al</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="01-概览" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/01-%E6%A6%82%E8%A7%88/"/>
    
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>02.寄存器和内存</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/02.%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/02.%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98/</id>
    <published>2025-07-12T14:37:30.000Z</published>
    <updated>2025-07-15T01:25:14.188Z</updated>
    
    <content type="html"><![CDATA[<p>计算机的存储分为随机访问存储（RAM）和持久存储，这一节讨论的是前者，即：计算机在通电的状态下，如何存储数据</p><h1 id="如何存储-1-bit-的数据">如何存储 1 bit 的数据</h1><p>计算机通电后的电流都是单向流动的，所以要在通电时存储电信号，工程师对逻辑电路做了处理，让输出电信号回流到其中一个输出：</p><p><img src="latch_0.png" alt="可以存储 1 和 0 的电路" /><br /></p><p>上面的两个电路分别可以存储 1 和0，但是这还不够，毕竟它们的存储都是不可改变的，为此，逻辑电路被组合了起来：</p><p><img src="latch_1.png" alt="AND-OR 锁存器" /><br /></p><p>这个电路被称为锁存器（AND-ORLatch），是因为它锁住了一个位的值，这样就真正意义上存储了 1 bit的值！</p><p>但是使用 <code>设置</code> 和 <code>复位</code>两条线来输入比较难以理解，易用的结构应该是下面这样的：</p><p><img src="latch_2.png"alt="更易用的设计：一条输入线和一条允许写入线" /><br /></p><p>所以又有了这样的电路，我们称之为门锁（Gate Latch）：</p><p><img src="latch_3.png" alt="门锁的电路实现" /><br /></p><p>之所以称为门锁，是因为它可以打开和关上，我们不必过于关心它的实现细节，所以再次抽象：</p><p><img src="latch_4.png" alt="门锁" /><br /></p><p>这样，我们拥有了一个真正意义上可以存储 1 bit 数据的锁存器</p><h1 id="寄存器register">寄存器（Register）</h1><p>我们把 8 个锁存器并成一排形成一组，这样我们就得到了一个寄存器。</p><p>寄存器能够存储一个数字，寄存器有多少位，就叫<code>位宽</code>。早期的计算机使用 8 位宽的寄存器，后面 16 位、32位、直到如今的 64 位。</p><p>想象一下，如果我们要往一个寄存器里面写值，那么我们至少需要 8根输入线和 8 根输出线，但 “允许写入线” 可以只用一根，将 8个锁存器全部连通。这样，当寄存器要写入数据时，把 “允许写入线” 置 1，八根输入线写入数据后，再将 “允许写入线” 置 0 即可。</p><h1 id="内存">内存</h1><p>现在我们的存储规模再次提升，超过单个寄存器，存储 256位数据，线的数量就会来到 64 + 64 + 1 = 129 根！</p><p>于是矩阵式的电路设计出现了。锁存器不再是单纯并排排布，而是网格排布，下图是存256 位的 16x16的锁存器布局，当我们要写入某个锁存器时，只需要同时启用对应的行线和列线：</p><p><img src="latch_5.png" alt="16x16 的网格布局" /><br /></p><p>这样，我们需要的线就变成了：</p><ul><li>1 根数据线</li><li>1 根 “允许写入线”</li><li>16 行和 16 列的线用于选择锁存器</li></ul><p>129 根线被优化为 1 + 1 + 16 + 16 = 34 根线，即使加上 “允许读取线”，也才 35 根线</p><h2 id="多路复用器">多路复用器</h2><p>采用矩阵式电路设计后，我们用可以用行数加列数来表示一个锁存器的地址，比如第12 行 8 列的锁存器地址是 <code>11001000</code> 。行和列分别占 4 bit，如何把这个 4位的值转换到电路上，就要用到<strong>多路复用器（Multiplexer）</strong></p><p><img src="latch_6.png" alt="行和列都需要一个多路复用器" /><br /></p><p>两个多路复用器，分别用来转换行和列的地址</p><h2 id="对内存抽象">对内存抽象</h2><p>以上的结构做一次抽象，得到下面的 256 bit 的内存：</p><p><img src="latch_7.png" alt="单个 256 bit 内存的抽象" /><br /></p><p>它使用 8 位地址（4 位行和 4位列），一条数据线，一条写入线和一条读取线</p><p>我们将 8 个 256 bit 内存并排排布，用 8 根线串联控制地址，用 2根线串联分别控制写入和读取，再对每个内存单独用 1 根数据线（共 8根数据线），可以实现<strong>在指定 8 位地址存储一个 8位数字</strong>：</p><p><img src="latch_8.png" alt="RAM 的电路设计" /><br /></p><p>对这个电路再次做抽象，我们就得到了一个可寻址的内存，由于地址最多有256 个，所以我们最多可以存储 256 个 8 位值：</p><p><img src="latch_9.png" alt="RAM" /><br /></p><p>由于可以随时访问任意位置，这样的内存被叫做 RAM (Random AccessMemory，随机访问存储器)。现代的内存条可以达到几十 GB容量，归根结底就是排布了大量类似这样的内存电路。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计算机的存储分为随机访问存储（RAM）和持久存储，这一节讨论的是前者，即：计算机在通电的状态下，如何存储数据&lt;/p&gt;
&lt;h1 id=&quot;如何存储-1-bit-的数据&quot;&gt;如何存储 1 bit 的数据&lt;/h1&gt;
&lt;p&gt;计算机通电后的电流都是单向流动的，所以要在通电时存储电信号</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CrashCourse" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/"/>
    
    
    <category term="CS-101" scheme="https://peiyuzou.github.io/tags/CS-101/"/>
    
  </entry>
  
  <entry>
    <title>01.算数逻辑单元</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/01.%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/01.%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/</id>
    <published>2025-07-12T13:28:47.000Z</published>
    <updated>2025-07-14T01:39:24.734Z</updated>
    
    <content type="html"><![CDATA[<p>算数逻辑单元，通常叫做 ALU（Arithmetic &amp; LogicUnit），它包含两个单元：算数单元和逻辑单元</p><h1 id="算数单元">算数单元</h1><p>算数单元负责了计算机的所有算数计算，了解它需要先理解<strong>半加器</strong>和<strong>全加器</strong></p><h2 id="半加器">半加器</h2><p>思考我们在单个 <code>bit（位）</code> 上做二进制加法：</p><p><img src="half_adder_0.png" alt="二进制相加表格" /><br /></p><p>加法非常简单，但是结果无法用单个位存储，因为 <code>1 + 1</code>的结果带有进位（Carry），所以我们需要有两个输出值：</p><p><img src="half_adder_1.png" alt="半加器表格" /><br /></p><p>因此，我们可以抽象出一个 <code>半加器（half adder）</code>：</p><p><img src="half_adder_2.png" alt="半加器" /><br /></p><h2 id="全加器">全加器</h2><p>如果我们要实现多位数的相加，那么除了最低位，其余位都要处理这个进位，所以输入的值会变成三个：</p><p><img src="full_adder_0.png" alt="全加器表格" /><br /></p><p>所以我们又抽象出了一个 <code>全加器（full adder）</code>：</p><p><img src="full_adder_1.png" alt="全加器" /><br /></p><h2 id="制作-8-位加法器">制作 8 位加法器</h2><p>通过半加器和全加器，我们可以对多位表示的数进行加法运算，由于最低位不计算进位，所以使用半加器去处理，剩余的位使用全加器：</p><p><img src="full_adder_2.png" alt="8 位行波进位加法器" /><br /></p><p>由此我们得到了一个 8 位行波进位加法器（8-bit ripple carry adder）</p><p>注意最高位仍然有一个进位，当这个进位为1，代表两个数字之和太大，发生了溢出</p><h2 id="alu-的其他算数能力">ALU 的其他算数能力</h2><p>包含上面部分说的加法，ALU 一般还可以做以下的运算：</p><ul><li>加法</li><li>带进位的加法</li><li>减法</li><li>带借位的减法</li><li>正负取反</li><li>自增</li><li>自减</li><li>数字无改变，通过（All bits of A are passed through unmodified）</li></ul><p>对于简单的 ALU来说，它们没有能直接处理乘法和除法的算数单元，但是可以通过多次简单的运算来达到目的，比如<code>12 x 5</code> 变为<code>12 + 12 + 12 + 12 + 12</code>，而现代计算的 CPU比较先进，它们具备了专门做乘除法的算数单元</p><h1 id="逻辑单元">逻辑单元</h1><p>逻辑单元用来处理一些逻辑运算，比如<code>AND</code>、<code>OR</code>、<code>NOT</code>、<code>XOR</code>等，也可以用于做一些简单的数值测试，比如检查 ALU 的输出是否为 0</p><p><img src="logic_unit_0.png"alt="检查 ALU 输出是否为 0 的电路" /><br /></p><h1 id="alu-的抽象">ALU 的抽象</h1><p>一般工程师使用下图的 “V” 型图标表示一个 ALU ：</p><p><img src="alu_0.png" alt="ALU" /><br /></p><p>ALU 要求有两个 8 位的输入值，另外还要 4位的操作码，以此来确定怎么处理两个函数的计算（比如 1000代表相加），最终输出一个 8 位的值，另外还有一些标记位（单个bit），比如图中的三个：</p><ul><li>Overflow：运算是否发生了溢出</li><li>Zero：运算结果是否为零，判断两个数值是否相等的时候很有用</li><li>Negative：运算结果是否为负，判断大小时有用</li></ul><p>一些高级的 ALU 还会有其他的 Flags，但是这三个是比较通用的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;算数逻辑单元，通常叫做 ALU（Arithmetic &amp;amp; Logic
Unit），它包含两个单元：算数单元和逻辑单元&lt;/p&gt;
&lt;h1 id=&quot;算数单元&quot;&gt;算数单元&lt;/h1&gt;
&lt;p&gt;算数单元负责了计算机的所有算数计算，了解它需要先理解&lt;strong&gt;半加器&lt;/s</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CrashCourse" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/"/>
    
    
    <category term="CS-101" scheme="https://peiyuzou.github.io/tags/CS-101/"/>
    
  </entry>
  
  <entry>
    <title>01.Lz4压缩</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/01.Lz4/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/01.Lz4/</id>
    <published>2025-07-10T11:06:13.000Z</published>
    <updated>2025-07-11T01:43:50.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>LZ4 是一种无损压缩算法，提供每核 &gt; 500 MB/s的压缩速度，并可通过多核 CPU进行扩展。它具有极快的解码器，每核速度可达数 GB/s，通常会达到多核系统的RAM 速度极限。</p><p>作为 Unity AssetBundle 主推的压缩算法，它相比 Lzma拥有更快的速度（大约是 Lzma 的十倍以上）。并且是基于块压缩的（ChunkBased），可以按需选择加载部分块，而不用将整个文件全部加载，这对于内存来说是更友好的。唯一相较于Lzma 的劣势是压缩率，大约比 Lzma 高出 30%</p><h1 id="lz4-的原理">Lz4 的原理</h1><p>Lz4压缩后的文件由块组成，每一个压缩块则由若干序列组成，它的核心原理简单概括就是找出重复的字节序列，按照固定规则以更省空间的形式存储。先来看它的序列示意图：</p><p><img src="Lz4_Sequence.png" alt="Lz4的序列" /><br /></p><p>首先，开头的一个字节称为一个标记（Token），这个标记由两个 4位组成（因此值的范围从 0 到 15）</p><p>高 4位用于存储字面量（Literal）的长度，字面量是指压缩过程中无法被压缩的原始字节。由于4 位能表示的值范围有限，因此图中 Literal length+（图中黄色区域）用于支持更大的长度值的存储，这是一个可选的区域。如果 4位之内足够存储字面量的长度，这个区域就不存在，Token 之后会紧跟Literals（字面量）。如果该 4 位存储的值为 0，则代表没有字面量。如果为15（4 位全 1），则增加一个 Literal length+ 区域，其代表的值为 0 -255（一个字节的大小），此时字面量的长度 = 15 +这个字节的值。如果这个字节的值仍然满了（255），则继续增加一个新的字节，直到可以表示字面量的长度为止。（因此图中写的是0-n bytes）</p><p>这两个区域之后，则是字面量的存储区域，字面量是未压缩的字节，按原样复制。</p><p>紧接着是偏移量（Offset），这是一个两个字节的值（0-65535），它表示要从中复制匹配的位置。请注意，0是无效值，不会被使用。1 表示“当前位置 - 1字节”，另外需要注意，这个值使用小端格式存储（低位在前，高位在后）。通过偏移量，我们可以得到重复字节的起始位置</p><p>我们使用重复字节的起始位置加上匹配长度的值，就可以得到重复位置从哪个位置开始到哪个位置结束。匹配长度是指从在Token 的低 4位值存储，如果不够，再启用后面的可选区域，可选区域的规则和字面量长度的规则一致，但这里有一点细小的差异，匹配长度要求最小值为4，也就是说至少要 4个重复的字节才可以压缩，这应该是为了压缩率至少不能超过 1而设计的，毕竟压缩后变大了是不行的。这里存储的值如果为 0，代表匹配长度为4 个字节，如果值为 15，代表匹配长度为 19+个字节（可能启用了可选区域）</p><h1 id="进行一次计算">进行一次计算</h1><p><img src="Lz4_Exp.drawio.png" alt="原始字节序列" /><br /></p><p>假设我们有上面这个字节序列，其中每个字节编号一个索引，最大值是F（11111111），现在开始对它进行模拟压缩，步骤如下：</p><p><img src="Lz4.drawio.png" alt="模拟压缩步骤" /><br /></p><h2 id="压缩计算">压缩计算</h2><p>现在我们得到：</p><ul><li>字面量为[C, C, C, A, B, C, D, E, F, B, B, B]，长度为12。</li><li>偏移量为9</li><li>匹配长度为6</li></ul><p>首先第一个序列用来存储字面量：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Token：</span><br><span class="line">- 高 4 位：12（字面量长度，小于 15 无需额外字节）</span><br><span class="line">- 低 4 位：0（不存储匹配）</span><br><span class="line">Literals：[C, C, C, A, B, C, D, E, F, B, B, B]</span><br><span class="line">Offset：由于该序列仅表示字面量，因此不存储Offset</span><br></pre></td></tr></table></figure><p>第二个序列用来存储匹配数据：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">匹配信息:</span><br><span class="line">- 偏移量: 9</span><br><span class="line">- 匹配长度: 6</span><br><span class="line">Token:</span><br><span class="line">- 高4位: 0 (没有字面量)</span><br><span class="line">- 低4位: 2 (匹配长度 = 6-4 = 2)</span><br><span class="line">Token = 0x02</span><br><span class="line">偏移量编码: 0x0009 → 小端序 [0x09][0x00]</span><br></pre></td></tr></table></figure><p>得到最终压缩结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0xC0][C][C][C][A][B][C][D][E][F][B][B][B][0x02][0x09][0x00]</span><br><span class="line"></span><br><span class="line">原始数据: 18字节</span><br><span class="line">压缩数据: 16字节</span><br><span class="line">压缩率: 16/18 ≈ 88.9%</span><br><span class="line">节省: 2字节 (11.1%)</span><br></pre></td></tr></table></figure><h2 id="解压计算">解压计算</h2><p>解压Token1 (0xC0)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字面量长度: 12</span><br><span class="line">匹配长度: 0</span><br><span class="line">操作: 复制12个字面量</span><br><span class="line">输出: C C C A B C D E F B B B</span><br></pre></td></tr></table></figure><p>解压Token2 (0x02)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字面量长度: 0</span><br><span class="line">匹配长度: 2+4 = 6</span><br><span class="line">偏移量: 9</span><br><span class="line">操作: 从位置3开始复制6个字节</span><br><span class="line">输出: A B C D E F (复制位置3-8)</span><br></pre></td></tr></table></figure><p>最终结果与原数据一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C C C A B C D E F B B B A B C D E F</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;LZ4 是一种无损压缩算法，提供每核 &amp;gt; 500 MB/s
的压缩速度，并可通过多核 CPU
进行扩展。它具有极快的解码器，每核速度可达数 GB/s，通常会达到多核系统的
RAM 速度极限。&lt;/p&gt;
&lt;p&gt;作为 Uni</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="压缩算法" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Compression" scheme="https://peiyuzou.github.io/tags/Compression/"/>
    
  </entry>
  
  <entry>
    <title>05.Unity内存优化最佳实践</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/05.Unity%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/05.Unity%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2025-07-10T08:30:30.000Z</published>
    <updated>2025-07-10T08:30:39.063Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"/>
    
    <category term="Unity内存管理" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Unity" scheme="https://peiyuzou.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>04.Unity Managed Memory</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/04.Unity%20Managed%20Memory/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/04.Unity%20Managed%20Memory/</id>
    <published>2025-07-10T05:43:59.000Z</published>
    <updated>2025-07-10T08:18:00.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览">概览</h1><ul><li>VM 内存池<ul><li>VM 返回内存给操作系统的条件</li></ul></li><li>GC 机制<ul><li>GC 机制考量<ul><li>Throughput（回收能力）</li><li>Pause Times（暂停时长）</li><li>Fragmentation（碎片化）</li><li>Mutator overhead（额外消耗）</li><li>Scalability（可扩展性）</li><li>Portability（可移植性）</li></ul></li><li>使用的 GC<ul><li>Boehm<ul><li>Non-generaional</li><li>Non-compacting</li></ul></li><li>Incremental GC（渐进式GC）</li></ul></li><li>Memory fragmentation（内存碎片化）</li><li>Zombie Memory（僵尸内存）<ul><li>无用内存</li><li>没有释放</li><li>通过代码管理和性能工具分析</li></ul></li></ul></li></ul><h2 id="vm-内存池">VM 内存池</h2><p>Unity 编辑器进程自身使用 MonoVM，打包后的实际游戏进程根据脚本后端选择不同，使用 IL2Cpp Runtime 或者Mono VM。注意这里说的 VM 是指实际游戏进程使用的 VM。</p><p>Mono VM 的内存池，内存以 Block 的形式管理，当一个 Block 连续 6 次 GC没有被访问到，这块内存会被返回给系统，条件苛刻，比较难触发。</p><p>IL2CPP 更容易触发，因为它的内存管理更像一个传统 C++程序的内存管理模式。</p><blockquote><p>注意，GC 本身是不会把内存返还给操作系统的，它是回收给虚拟机。</p></blockquote><h2 id="unity-的-gc">Unity 的 GC</h2><h3 id="gc-机制的考量">1. GC 机制的考量</h3><ul><li>Throughput（回收能力）：一次GC能收回多少内存</li><li>Pause times（暂停时长）：GC时对主线程的影响会多大（卡顿）</li><li>Fragmentation（碎片化）：对整体内存池的碎片化影响多少</li><li>Mutatoroverhead（额外消耗）：GC时的消耗，GC时需要做很多的统计会产生消耗</li><li>Scalability（可拓展性）：拓展到多核多线程会不会有什么bug</li><li>Portability（可移植性）：在不同的平台上是否可以使用</li></ul><h3 id="boehm-gc-和-incremental-gc">2. Boehm GC 和 Incremental GC</h3><p>Unity 用的 Boehm GC，简单粗暴，不分代。它有以下特点：</p><ul><li>Non-generational（非分代式），即全都堆在一起，因为这样会很快。分代的话就是例如大内存，小内存，超小内存分在不同的内存区域来进行管理（SGenGC的设计思想）。</li><li>Non-Compacting（非压缩式），即当有内存被释放的时候，这块区域就空着。而压缩式的会重新排布，填充空白区域，使内存紧密排布。</li></ul><p>但目前 Unity 在 Mono 上已经使用 SGen GC （Scalable GenerationalGC，分代垃圾回收器）了，而 IL2CPP 则是嵌入了一个定制化后的 Boehm</p><p>结论如下表：</p><table><thead><tr><th>Unity后端</th><th>使用的GC</th><th>是否 Boehm</th><th>是否支持分代</th></tr></thead><tbody><tr><td>Mono（编辑器）</td><td>Mono SGen GC</td><td>非 Boehm</td><td>是</td></tr><tr><td>IL2CPP</td><td>Boehm GC（定制版）</td><td>是</td><td>否</td></tr><tr><td>DOTS/Burst</td><td>无托管堆</td><td>无GC</td><td>N/A</td></tr></tbody></table><p>Unity 另外实装了 IncrementalGC，主要解决主线程卡顿的问题，现在进行一次GC主线程被迫要停下来，遍历所有的Memory Island，决定哪些要被 GC掉，会造成一定时间的主线程卡顿。Incremental GC把前面暂停主线程的事分帧做了，这样主线程不会出现峰值。</p><h3 id="内存碎片化">3. 内存碎片化</h3><p>非压缩式的内存虽然快（避免了内存重新排布的时间消耗），但是容易造成内存碎片化。内存的碎片化容易间接内存异常上涨，比如内存总用量下降了，但是还在继续分配新的空间。例如，内存中有一些空白的内存区域时，分配了一块较大内存时，却没有任何的一个空间放得下（即使整体的空间足够），导致内存扩充很多。</p><p>因此建议在需要连续分配内存的情况下，先操作大内存，然后操作小内存，可以一定程度上减轻碎片化。</p><h3 id="僵尸内存">4. 僵尸内存</h3><p>这个和内存泄漏常被人搞混在一起。僵尸内存是指碎片化内存之间空出的内存，这部分内存可能成为僵尸内存。这种情况实际上并不是内存泄露，因为这些内存并没有被泄露，泄露指这块内存没有任何人可以访问和管理，但实际上这块内存一直在内存池里。</p><h1 id="managed-memory-最佳实践">Managed Memory 最佳实践</h1><h2 id="dont-null-it-destroy-it">1. Don’t Null it, Destroy it</h2><p>用 Destroy，别用 null，显示的调用 Destroy 才能真正的销毁掉。</p><h2 id="class-和-struct-不要混用">2. Class 和 Struct 不要混用</h2><p>这个不赘述</p><h2 id="pool-in-pool">3. Pool In Pool</h2><p>高频使用的部分自己建一个内存池去重用</p><h2 id="closures-and-anonymous-methods闭包和匿名函数">4. Closures andanonymous methods（闭包和匿名函数）</h2><p>所有的匿名函数和闭包在 C# 编 IL 代码时都会被 new 成一个Class（匿名class），所以在里面所有变量以及new的东西，都是要占内存的。</p><h2 id="coroutines协程">5. Coroutines（协程）</h2><p>协程属于闭包和匿名函数的特例，游戏开始启动一个协程直到游戏结束才释放，是错误的做法。因为协程只要没被释放，里面的所有变量，即使是局部变量（包括值类型），也都会在内存里。建议用的时候才生产一个协程，不用的时候就丢掉。</p><h2 id="configurations配置表">6. Configurations（配置表）</h2><p>全部配置表一下全部进内存也是不明智的，可以考虑分关加载等策略。</p><h2 id="singleton单例">7. Singleton（单例）</h2><p>慎用单例，不要什么都往里放，因为里面的变量会一直占用内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概览&quot;&gt;概览&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;VM 内存池
&lt;ul&gt;
&lt;li&gt;VM 返回内存给操作系统的条件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;GC 机制
&lt;ul&gt;
&lt;li&gt;GC 机制考量
&lt;ul&gt;
&lt;li&gt;Throughput（回收能力）&lt;</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"/>
    
    <category term="Unity内存管理" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Unity" scheme="https://peiyuzou.github.io/tags/Unity/"/>
    
  </entry>
  
</feed>
