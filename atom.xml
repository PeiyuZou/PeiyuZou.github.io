<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Per-Fragment</title>
  
  
  <link href="https://peiyuzou.github.io/atom.xml" rel="self"/>
  
  <link href="https://peiyuzou.github.io/"/>
  <updated>2025-07-08T12:03:55.536Z</updated>
  <id>https://peiyuzou.github.io/</id>
  
  <author>
    <name>Z.P.Y</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>03.协议族和套接字类型</title>
    <link href="https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/03.%E5%8D%8F%E8%AE%AE%E6%97%8F%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B/"/>
    <id>https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/03.%E5%8D%8F%E8%AE%AE%E6%97%8F%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-07-04T03:38:58.000Z</published>
    <updated>2025-07-08T12:03:55.536Z</updated>
    
    <content type="html"><![CDATA[<p>在创建套接字的时候，我们调用了 <code>socket</code>函数，函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">SOCKET <span class="title function_">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><ul><li>af: 套接字使用的地址族（Address Family）或者协议族（ProtocolFamily）</li><li>type: 套接字传输类型</li><li>protocol：最终使用的协议</li></ul><h1 id="协议族protocol-family">协议族（Protocol Family）</h1><p>以下是协议族的部分分类：</p><table><thead><tr><th>名称</th><th>协议族</th></tr></thead><tbody><tr><td>PF_INET</td><td>IPv4互联网协议族</td></tr><tr><td>PF_INET6</td><td>IPv6互联网协议族</td></tr><tr><td>PF_LOCAL</td><td>本地通信的UNIX协议族</td></tr><tr><td>PF_PACKET</td><td>底层套接字的协议族</td></tr><tr><td>PF_IPX</td><td>IPX Novell协议族</td></tr></tbody></table><p>只需关心 PF_INET 即可，例子中会用到它</p><h1 id="套接字类型">套接字类型</h1><p>这个参数指定了数据传输方式，这里介绍两种最具代表性的：SOCK_STREAM 和SOCK_DGRAM</p><h2 id="sock_stream">1.SOCK_STREAM</h2><p>SOCK_STREAM 又称为面向连接的套接字。它有以下特性：</p><ul><li>基于连接：传输端和接收端必须一一对应（端对端传输），且需要先建立连接</li><li>数据可靠：保证数据不丢失且按序到达</li><li>数据边界：无消息边界，数据以字节流的形式传输</li><li>对应协议：TCP</li></ul><h2 id="sock_dgram">2.SOCK_DGRAM</h2><p>SOCK_DGRAM 又称为面向消息的套接字。它有以下特性：</p><ul><li>基于消息：不需要建立连接，直接发送</li><li>数据不可靠：可能丢包、重复、乱序</li><li>数据边界：有消息边界，一次发送的数据是一整个报文</li><li>对应协议：UDP</li></ul><h1 id="最终协议的选择">最终协议的选择</h1><p>其实通过接口签名的前两个参数进行组合，大多数情况下程序就已经可以得到最终的协议了，比如，PF_INET+ SOCK_STREAM 可以确定用户要使用 TCP 协议，所以这种情况下第三个参数传 0也可以。</p><p>但是存在前两个参数组合也无法确认最终协议的情况：在同一个协议族中，存在多个使用相同传输方式的协议。</p><p>所以这里设计了第三个参数，用来指定这个最终的协议，所以使用 TCP 的Socket 也可以这么写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hSocket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br></pre></td></tr></table></figure><h1 id="af-和-pf">AF 和 PF ?</h1><p>在上述的 socket 函数签名中，第一个参数是 af，但是我们实际调用的时候，传入的是 PF_INET：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数签名</span></span><br><span class="line">SOCKET <span class="title function_">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际调用</span></span><br><span class="line">hSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>要解释这个传参的问题，要先从 AF 和 PF 本身讲起。</p><ul><li>AF (Address Family) 指地址族，强调地址类型，比如 IPv4 在 AF中指的是地址类型为 IPv4</li><li>PF (Protocol Family) 指协议族，IPv4 在 PF 中强调的是协议类型为IPv4</li></ul><p>从语义来说，这个函数的签名要求传入的是地址类型，但是我们之所以可以传入PF_INET 的原因是：在 Winsock 和大多数系统中，AF_XXX 和 PF_XXX是同一个值！如下图的定义：</p><p><img src="AF_PF_Define.png" alt="AF 和 PF 的相关定义" /><br /></p><p>这本质上是历史语义的问题，在实际的使用中，无论是 AF 还是 PF都不会出现问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在创建套接字的时候，我们调用了 &lt;code&gt;socket&lt;/code&gt;
函数，函数签名如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;</summary>
      
    
    
    
    <category term="08-网络编程" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Socket" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/"/>
    
    
  </entry>
  
  <entry>
    <title>02.使用C语言实现一个WinSock简易例子</title>
    <link href="https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/02.%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWinSock%E7%AE%80%E6%98%93%E4%BE%8B%E5%AD%90/"/>
    <id>https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/02.%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWinSock%E7%AE%80%E6%98%93%E4%BE%8B%E5%AD%90/</id>
    <published>2025-07-02T05:56:32.000Z</published>
    <updated>2025-07-04T03:26:40.928Z</updated>
    
    <content type="html"><![CDATA[<p>WinSock 是指 Windows Socket，是 Windows 平台的套接字。</p><h1 id="服务端代码">服务端代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello_server.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接ws2_32.lib库，提供Windows Socket API</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    WSADATA wsaData;                <span class="comment">// Windows Socket库信息结构体</span></span><br><span class="line">    SOCKET hServSock, hClntSock;    <span class="comment">// 服务器socket句柄和客户端socket句柄</span></span><br><span class="line">    SOCKADDR_IN servAddr, clntAddr; <span class="comment">// 服务器和客户端地址信息结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> szClntAddt;                 <span class="comment">// 客户端地址结构体大小</span></span><br><span class="line">    <span class="type">char</span> message[] = <span class="string">&quot;nice day&quot;</span>;    <span class="comment">// 要发送给客户端的消息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查命令行参数数量，需要端口号</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Windows Socket库，请求版本2.2</span></span><br><span class="line">    <span class="keyword">if</span>(WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;WSAStartup() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP socket (PF_INET: IPv4, SOCK_STREAM: TCP, 0: 默认协议)</span></span><br><span class="line">    hServSock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(hServSock == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;socket() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置服务器地址信息</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servAddr));          <span class="comment">// 清零结构体</span></span><br><span class="line">    servAddr.sin_family = AF_INET;                   <span class="comment">// 设置地址族为IPv4</span></span><br><span class="line">    servAddr.sin_addr.s_addr = htonl(INADDR_ANY);    <span class="comment">// 绑定到所有可用网络接口</span></span><br><span class="line">    servAddr.sin_port = htons(atoi(argv[<span class="number">1</span>]));        <span class="comment">// 设置端口号并转换为网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将socket绑定到指定地址和端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(hServSock, (SOCKADDR*)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr)) == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;bind() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听连接请求，最大等待队列长度为5</span></span><br><span class="line">    <span class="keyword">if</span>(listen(hServSock, <span class="number">5</span>) == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;listen() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受客户端连接请求</span></span><br><span class="line">    szClntAddt = <span class="keyword">sizeof</span>(clntAddr);</span><br><span class="line">    hClntSock = accept(hServSock, (SOCKADDR*)&amp;clntAddr, &amp;szClntAddt);</span><br><span class="line">    <span class="keyword">if</span>(hClntSock == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;accept() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向客户端发送消息</span></span><br><span class="line">    send(hClntSock, message, <span class="keyword">sizeof</span>(message), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端和服务器socket，清理Windows Socket库</span></span><br><span class="line">    closesocket(hClntSock);</span><br><span class="line">    closesocket(hServSock);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理函数：打印错误信息并退出程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);  <span class="comment">// 输出错误信息到标准错误流</span></span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);     <span class="comment">// 换行</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);                 <span class="comment">// 退出程序，返回错误码1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="客户端代码">客户端代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello_client.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接ws2_32.lib库，提供Windows Socket API</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    WSADATA wsaData;        <span class="comment">// Windows Socket库信息结构体</span></span><br><span class="line">    SOCKET hSocket;         <span class="comment">// 客户端socket句柄</span></span><br><span class="line">    SOCKADDR_IN servAddr;   <span class="comment">// 服务器地址信息结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> message[<span class="number">30</span>];       <span class="comment">// 存储从服务器接收的消息</span></span><br><span class="line">    <span class="type">int</span> strLen = <span class="number">0</span>;         <span class="comment">// 累计接收的字节数</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, readLen = <span class="number">0</span>;  <span class="comment">// idx: 消息缓冲区索引, readLen: 单次接收的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查命令行参数数量，需要IP地址和端口号</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Windows Socket库，请求版本2.2</span></span><br><span class="line">    <span class="keyword">if</span>(WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;WSAStartup() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP socket (PF_INET: IPv4, SOCK_STREAM: TCP, 0: 默认协议)</span></span><br><span class="line">    hSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSocket == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;socket() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置服务器地址信息</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servAddr));              <span class="comment">// 清零结构体</span></span><br><span class="line">    servAddr.sin_family = AF_INET;                       <span class="comment">// 设置地址族为IPv4</span></span><br><span class="line">    servAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);       <span class="comment">// 设置服务器IP地址</span></span><br><span class="line">    servAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));            <span class="comment">// 设置端口号并转换为网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span>(connect(hSocket, (SOCKADDR*)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr)) == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐字节接收服务器发送的数据，直到连接关闭</span></span><br><span class="line">    <span class="keyword">while</span>(readLen = recv(hSocket, &amp;message[idx++], <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(readLen == <span class="number">-1</span>)  <span class="comment">// 接收出错</span></span><br><span class="line">        &#123;</span><br><span class="line">            ErrorHandling(<span class="string">&quot;recv() error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        strLen += readLen;  <span class="comment">// 累计接收的总字节数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印接收到的消息和总接收次数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from server : %s \n&quot;</span>, message);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function read call count : %d \n&quot;</span>, strLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭socket并清理Windows Socket库</span></span><br><span class="line">    closesocket(hSocket);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理函数：打印错误信息并退出程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);  <span class="comment">// 输出错误信息到标准错误流</span></span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);     <span class="comment">// 换行</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);                 <span class="comment">// 退出程序，返回错误码1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编译运行">编译运行</h1><p>注意需要链接 ws2_32.lib 库，有两种方法：</p><ul><li>通过 Visual Studio 等集成开发环境，设置附加依赖项，把 ws2_32.lib链接进来</li><li>在编译运行时，通过命令行链接</li></ul><p>编译链接的命令行如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello_client.c -o hClientWin -lws2_32</span><br></pre></td></tr></table></figure><p>意味编译 hello_client.c 并与 ws2_32.lib 链接，最终输出 hClientWin.exe文件。</p><p>运行服务端程序，指定一个端口号，会发现程序进入了等待状态，因为调用的<code>accept</code> 函数还未返回。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:<span class="title">NetCoding</span>\<span class="title">Socket</span>&gt;<span class="title">hServerWin</span> 9190</span></span><br><span class="line"><span class="function">(空白)</span></span><br></pre></td></tr></table></figure><p>接着运行客户端程序，指定对应的 ip 和port，命令行得到打印结果，同时服务端程序也运行完毕。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:<span class="title">NetCoding</span>\<span class="title">Socket</span>&gt;<span class="title">hClientWin</span> 127.0.0.1 9190</span></span><br><span class="line"><span class="function"><span class="title">Message</span> <span class="title">from</span> <span class="title">server</span> : <span class="title">nice</span> <span class="title">day</span></span></span><br><span class="line"><span class="function"><span class="title">Function</span> <span class="title">read</span> <span class="title">call</span> <span class="title">count</span> : 9</span></span><br></pre></td></tr></table></figure><h1 id="需要注意的点">需要注意的点</h1><p>在客户端代码中，是逐字节接收服务器发送的数据。其实这里可以根据实际需求调整，不一定是一个字节一个字节地接收。这里这样写是因为想要展示非对称的传输：我们使用了IPv4 + 流失传输的组合（下节介绍），符合这一组合的协议只有 TCP 协议，而TCP协议的传输是非对称的，即服务端的发送次数和客户端的接收次数不一定相等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;WinSock 是指 Windows Socket，是 Windows 平台的套接字。&lt;/p&gt;
&lt;h1 id=&quot;服务端代码&quot;&gt;服务端代码&lt;/h1&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</summary>
      
    
    
    
    <category term="08-网络编程" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Socket" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/"/>
    
    
  </entry>
  
  <entry>
    <title>01.Socket概览</title>
    <link href="https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/01.Socket%E6%A6%82%E8%A7%88/"/>
    <id>https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/01.Socket%E6%A6%82%E8%A7%88/</id>
    <published>2025-07-02T05:55:31.000Z</published>
    <updated>2025-07-02T06:02:47.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先入为主">先入为主</h1><p>网络编程的实际意义就是在两台连网的计算机之间交换数据。除开所需的物理连接外，只需要编写数据传输软件就可以做到了，然而我们通常不需要担心这点，因为操作系统已经为我们提供了名为Socket 的部件来完成这个事。</p><p>由此可以得出定义：Socket（又名套接字）是操作系统层面提供的用于网络传输的软件部件。</p><h1 id="套接字使用过程">套接字使用过程</h1><ul><li>创建套接字</li><li>分配IP地址和端口号</li><li>进入接收请求状态</li><li>受理连接请求</li></ul><p>这是整个套接字编程的“轮廓”</p><h1 id="文件描述符">文件描述符</h1><p>在windows平台又称“文件句柄”。文件描述符是系统分配给文件或者套接字的一个整数值。它类似于一个图书馆中某本书的编号，在程序员和操作系统两者之间，对文件或者套接字操作提供的一个便利性的指代。如果通过某个函数创建了一个套接字，一般会返回一整数，这个整数就是文件描述符，在下文的代码中，则可以使用这个句柄对套接字做一些操作，有点类似指针。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;先入为主&quot;&gt;先入为主&lt;/h1&gt;
&lt;p&gt;网络编程的实际意义就是在两台连网的计算机之间交换数据。除开所需的物理连接外，只需要编写数据传输软件就可以做到了，然而我们通常不需要担心这点，因为操作系统已经为我们提供了名为
Socket 的部件来完成这个事。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="08-网络编程" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Socket" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://peiyuzou.github.io/wiki/index/"/>
    <id>https://peiyuzou.github.io/wiki/index/</id>
    <published>2025-07-01T12:26:56.425Z</published>
    <updated>2024-11-22T03:25:05.428Z</updated>
    
    <content type="html"><![CDATA[<!-- <div><image src="images/pixel03.gif"></div> --><p>一些有关游戏开发和数学的话题、教程、记录</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- &lt;div&gt;
&lt;image src=&quot;images/pixel03.gif&quot;&gt;
&lt;/div&gt; --&gt;
&lt;p&gt;一些有关游戏开发和数学的话题、教程、记录&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://peiyuzou.github.io/wiki/06-%E5%BC%95%E6%93%8E%E5%BC%80%E5%8F%91/Blank/"/>
    <id>https://peiyuzou.github.io/wiki/06-%E5%BC%95%E6%93%8E%E5%BC%80%E5%8F%91/Blank/</id>
    <published>2025-07-01T12:26:56.404Z</published>
    <updated>2024-12-09T03:20:48.261Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="06-引擎开发" scheme="https://peiyuzou.github.io/categories/06-%E5%BC%95%E6%93%8E%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://peiyuzou.github.io/wiki/07-%E5%9B%BE%E5%BD%A2%E5%AD%A6/Blank/"/>
    <id>https://peiyuzou.github.io/wiki/07-%E5%9B%BE%E5%BD%A2%E5%AD%A6/Blank/</id>
    <published>2025-07-01T12:26:56.404Z</published>
    <updated>2024-12-09T03:20:48.262Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="07-图形学" scheme="https://peiyuzou.github.io/categories/07-%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://peiyuzou.github.io/wiki/04-%E7%A8%8B%E5%BA%8F%E6%95%B0%E5%AD%A6/Blank/"/>
    <id>https://peiyuzou.github.io/wiki/04-%E7%A8%8B%E5%BA%8F%E6%95%B0%E5%AD%A6/Blank/</id>
    <published>2025-07-01T12:26:56.366Z</published>
    <updated>2024-12-09T03:20:45.361Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="04-程序数学" scheme="https://peiyuzou.github.io/categories/04-%E7%A8%8B%E5%BA%8F%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Blank/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Blank/</id>
    <published>2025-07-01T12:26:56.304Z</published>
    <updated>2024-12-09T03:20:45.072Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>5.x 虚拟机相关函数解读</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/5.x-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E8%A7%A3%E8%AF%BB/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/5.x-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E8%A7%A3%E8%AF%BB/</id>
    <published>2025-01-16T02:12:00.000Z</published>
    <updated>2025-01-16T04:19:42.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lual_loadfilex">luaL_loadfilex</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** 用于加载 Lua 脚本文件或从标准输入读取脚本内容，并将其编译为 Lua 的字节码</span></span><br><span class="line"><span class="comment">** 输入：</span></span><br><span class="line"><span class="comment">**     L - 当前状态机</span></span><br><span class="line"><span class="comment">**     filename - 脚本文件名称</span></span><br><span class="line"><span class="comment">**     mode - 指定加载模式（t - 文本，b - 二进制，bt or NULL - 根据首字符自动检查）</span></span><br><span class="line"><span class="comment">** 输出：</span></span><br><span class="line"><span class="comment">**     编译结果的状态（LUA_OK等）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LUALIB_API <span class="type">int</span> <span class="title function_">luaL_loadfilex</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *filename,</span></span><br><span class="line"><span class="params">                                             <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">  LoadF lf;</span><br><span class="line">  <span class="type">int</span> status, readstatus;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到文件名在栈上的位置</span></span><br><span class="line">  <span class="type">int</span> fnameindex = lua_gettop(L) + <span class="number">1</span>;  <span class="comment">/* index of filename on the stack */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理filename参数</span></span><br><span class="line">  <span class="comment">// - 如果 filename 为 NULL，则从标准输入加载脚本并在栈顶压入 =stdin（标识输入来源）</span></span><br><span class="line">  <span class="comment">// - 如果提供了 filename，尝试以只读模式打开文件。如果失败，则调用 errfile 报错</span></span><br><span class="line">  <span class="keyword">if</span> (filename == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    lua_pushliteral(L, <span class="string">&quot;=stdin&quot;</span>);</span><br><span class="line">    lf.f = <span class="built_in">stdin</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_pushfstring(L, <span class="string">&quot;@%s&quot;</span>, filename);</span><br><span class="line">    lf.f = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (lf.f == <span class="literal">NULL</span>) <span class="keyword">return</span> errfile(L, <span class="string">&quot;open&quot;</span>, fnameindex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跳过文件中的注释</span></span><br><span class="line">  <span class="comment">// - 调用 skipcomment 跳过文件中的注释部分。c 保存第一个非注释字符</span></span><br><span class="line">  <span class="comment">// - 如果跳过注释后需要调整行号（如文件首行为注释），将换行符 \n 添加到缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> (skipcomment(&amp;lf, &amp;c))  <span class="comment">/* read initial portion */</span></span><br><span class="line">    lf.buff[lf.n++] = <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">/* add line to correct line numbers */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是二进制文件，重新以二进制模式打开</span></span><br><span class="line">  <span class="comment">// 如果文件的第一个字符与 LUA_SIGNATURE 匹配，表明可能是 Lua 的预编译二进制文件</span></span><br><span class="line">  <span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>] &amp;&amp; filename) &#123;  <span class="comment">/* binary file? */</span></span><br><span class="line">    lf.f = freopen(filename, <span class="string">&quot;rb&quot;</span>, lf.f);  <span class="comment">/* reopen in binary mode */</span></span><br><span class="line">    <span class="keyword">if</span> (lf.f == <span class="literal">NULL</span>) <span class="keyword">return</span> errfile(L, <span class="string">&quot;reopen&quot;</span>, fnameindex);</span><br><span class="line">    skipcomment(&amp;lf, &amp;c);  <span class="comment">/* re-read initial portion */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果第一个字符是非空字符，将其存入缓冲区，作为流的第一个有效字符</span></span><br><span class="line">  <span class="keyword">if</span> (c != EOF)</span><br><span class="line">    lf.buff[lf.n++] = c;  <span class="comment">/* &#x27;c&#x27; is the first character of the stream */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 lua_load 编译文件内容为 Lua 字节码</span></span><br><span class="line">  <span class="comment">// - 参数 getF 是一个回调函数，从 lf 中读取内容并提供给 lua_load</span></span><br><span class="line">  status = lua_load(L, getF, &amp;lf, lua_tostring(L, <span class="number">-1</span>), mode);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 ferror 检查文件是否读取错误</span></span><br><span class="line">  <span class="comment">// - 如果有错误，将 Lua 栈恢复到调用此函数之前的状态，并返回错误码</span></span><br><span class="line">  readstatus = ferror(lf.f);</span><br><span class="line">  <span class="keyword">if</span> (filename) fclose(lf.f);  <span class="comment">/* close file (even in case of errors) */</span></span><br><span class="line">  <span class="keyword">if</span> (readstatus) &#123;</span><br><span class="line">    lua_settop(L, fnameindex);  <span class="comment">/* ignore results from &#x27;lua_load&#x27; */</span></span><br><span class="line">    <span class="keyword">return</span> errfile(L, <span class="string">&quot;read&quot;</span>, fnameindex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理和返回</span></span><br><span class="line">  <span class="comment">// - 在成功加载文件后，移除栈上的文件名信息，保持栈的整洁</span></span><br><span class="line">  lua_remove(L, fnameindex);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lua_load">lua_load</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** 在编译解释阶段，负责两个事：</span></span><br><span class="line"><span class="comment">**     1.在执行编译前加锁确保线程安全，并初始化一个文件读取流</span></span><br><span class="line"><span class="comment">**     2.在编译完成后，给编译结果设置全局表作为第一个上值</span></span><br><span class="line"><span class="comment">** 输入：</span></span><br><span class="line"><span class="comment">**     L - 当前状态机</span></span><br><span class="line"><span class="comment">**     reader - 回调函数，用于逐步读取代码块的内容</span></span><br><span class="line"><span class="comment">**     data - 传递给 reader 的用户数据，通常是文件流或内存中的字符串，在 luaL_loadfilex 传过来的是指定文件的文件流</span></span><br><span class="line"><span class="comment">**     chunkname - 代码块的名字，用于错误提示</span></span><br><span class="line"><span class="comment">**     mode - 编译模式，文本还是二进制</span></span><br><span class="line"><span class="comment">** 输出：</span></span><br><span class="line"><span class="comment">**     成功时返回 LUA_OK，并将编译后的 Lua 函数（LClosure）压入栈顶</span></span><br><span class="line"><span class="comment">**     失败时返回错误代码，并将错误信息压入栈顶</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LUA_API <span class="type">int</span> <span class="title function_">lua_load</span> <span class="params">(lua_State *L, lua_Reader reader, <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">char</span> *chunkname, <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">  ZIO z;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加锁，确保线程安全</span></span><br><span class="line">  lua_lock(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缺省 chunkname</span></span><br><span class="line">  <span class="keyword">if</span> (!chunkname) chunkname = <span class="string">&quot;?&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 ZIO 流</span></span><br><span class="line">  <span class="comment">// - z 是一个 ZIO 结构，它封装了读取代码块内容的逻辑</span></span><br><span class="line">  <span class="comment">// - 将 reader 和 data 指定给这个 ZIO，确保用 reader 指定的方式读取 data 的文件内容</span></span><br><span class="line">  luaZ_init(L, &amp;z, reader, data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用解析器</span></span><br><span class="line">  <span class="comment">// - 此函数负责对代码块的解析和编译，它运行在一个受保护的环境中，可以捕获并处理运行时错误</span></span><br><span class="line">  <span class="comment">// - 解析完成后，将生成的 Lua 函数（LClosure）压入栈顶</span></span><br><span class="line">  status = luaD_protectedparser(L, &amp;z, chunkname, mode);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置全局环境</span></span><br><span class="line">  <span class="comment">// - L-&gt;top - 1 指向的是上一步生成的放在栈顶的 Lua 函数对象</span></span><br><span class="line">  <span class="comment">// - s2v 理解为 StackValue to TValue，它将一个栈元素转化为通用的 TValue 结构体</span></span><br><span class="line">  <span class="comment">// - clLvalue 进一步将 TValue 转化为 LClosure (Lua闭包)</span></span><br><span class="line">  <span class="comment">// - 如果有上值，获取全局表并将全局表设置为该函数的第一个上值</span></span><br><span class="line">  <span class="comment">// - luaC_barrier 确保垃圾回收的正确性，维护引用关系</span></span><br><span class="line">  <span class="keyword">if</span> (status == LUA_OK) &#123;  <span class="comment">/* no errors? */</span></span><br><span class="line">    LClosure *f = clLvalue(s2v(L-&gt;top - <span class="number">1</span>));  <span class="comment">/* get newly created function */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;nupvalues &gt;= <span class="number">1</span>) &#123;  <span class="comment">/* does it have an upvalue? */</span></span><br><span class="line">      <span class="comment">/* get global table from registry */</span></span><br><span class="line">      <span class="type">const</span> TValue *gt = getGtable(L);</span><br><span class="line">      <span class="comment">/* set global table as 1st upvalue of &#x27;f&#x27; (may be LUA_ENV) */</span></span><br><span class="line">      setobj(L, f-&gt;upvals[<span class="number">0</span>]-&gt;v, gt);</span><br><span class="line">      luaC_barrier(L, f-&gt;upvals[<span class="number">0</span>], gt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放锁并返回结果</span></span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="f_parser">f_parser</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** lua_load 函数工作流程的一部分</span></span><br><span class="line"><span class="comment">** 输入：</span></span><br><span class="line"><span class="comment">**     L - 当前状态机</span></span><br><span class="line"><span class="comment">**     ud - 一个通用的用户数据指针，在这里是一个指向 SParser 结构体的指针，包含了解析需要的信息</span></span><br><span class="line"><span class="comment">** 输出：</span></span><br><span class="line"><span class="comment">**     没有返回，自动检查文件流是二进制还是文本，转发调用 luaU_undump 和 luaY_parser</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f_parser</span> <span class="params">(lua_State *L, <span class="type">void</span> *ud)</span> &#123;</span><br><span class="line">  LClosure *cl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 ud 强制转换为 SParser 指针</span></span><br><span class="line">  <span class="comment">// - SParser 包含解析时所需的输入流（z）、缓冲区（buff）、动态数据结构（dyd）以及源文件的名字（name）</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SParser</span> *<span class="title">p</span> =</span> cast(<span class="keyword">struct</span> SParser *, ud);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查文件流类型，转发调用解析函数</span></span><br><span class="line">  <span class="comment">// - 二进制调用 luaU_undump</span></span><br><span class="line">  <span class="comment">// - 文本源码调用 luaY_parser</span></span><br><span class="line">  <span class="type">int</span> c = zgetc(p-&gt;z);  <span class="comment">/* read first character */</span></span><br><span class="line">  <span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>]) &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">&quot;binary&quot;</span>);</span><br><span class="line">    cl = luaU_undump(L, p-&gt;z, p-&gt;name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">&quot;text&quot;</span>);</span><br><span class="line">    cl = luaY_parser(L, p-&gt;z, &amp;p-&gt;buff, &amp;p-&gt;dyd, p-&gt;name, c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一致性校验，校验生成的闭包的实际 upvalues 数量是否等于函数原型中定义的数量</span></span><br><span class="line">  <span class="comment">// - nupvalues: 闭包中实际的 upvalues 数量</span></span><br><span class="line">  <span class="comment">// - sizeupvalues: 函数原型中声明的 upvalues 数量</span></span><br><span class="line">  lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化闭包的 Upvalues（外部变量的引用）</span></span><br><span class="line">  <span class="comment">// - Upvalues 是闭包执行环境的重要组成部分，确保函数可以正确访问外部变量</span></span><br><span class="line">  luaF_initupvals(L, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="luay_parser">luaY_parser</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** lua_load 函数工作流程的核心部分，将文本流源码解析生成可执行的函数闭包</span></span><br><span class="line"><span class="comment">** 输入：</span></span><br><span class="line"><span class="comment">**     L - 当前状态机</span></span><br><span class="line"><span class="comment">**     z - 输入流对象，封装了输入数据（源码的文本流）</span></span><br><span class="line"><span class="comment">**     buff - 动态缓冲区，用于存储解析过程中的临时数据</span></span><br><span class="line"><span class="comment">**     dyd - 动态数据结构，包含作用域变量、标签、跳转等动态信息</span></span><br><span class="line"><span class="comment">**     name - 源文件的名称，用于生成调试信息</span></span><br><span class="line"><span class="comment">**     firstchar - 输入流的第一个字符，通常在调用时已经读取</span></span><br><span class="line"><span class="comment">** 输出：</span></span><br><span class="line"><span class="comment">**     返回生成的函数闭包（注意词法分析器的表出栈了，函数闭包仍然在栈上）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LClosure *<span class="title function_">luaY_parser</span> <span class="params">(lua_State *L, ZIO *z, Mbuffer *buff,</span></span><br><span class="line"><span class="params">                       Dyndata *dyd, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> firstchar)</span> &#123;</span><br><span class="line">  LexState lexstate;</span><br><span class="line">  FuncState funcstate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建主函数闭包</span></span><br><span class="line">  <span class="comment">// - 使用 luaF_newLclosure 创建一个 LClosure 对象。主闭包对应整个 Lua 源码文件的顶层函数</span></span><br><span class="line">  <span class="comment">// - 使用 setclLvalue2s 将闭包对象放置在 Lua 堆栈顶端，确保不会被垃圾回收器错误清理</span></span><br><span class="line">  <span class="comment">// - 增加堆栈顶指针，以存放闭包</span></span><br><span class="line">  LClosure *cl = luaF_newLclosure(L, <span class="number">1</span>);  <span class="comment">/* create main closure */</span></span><br><span class="line">  setclLvalue2s(L, L-&gt;top, cl);  <span class="comment">/* anchor it (to avoid being collected) */</span></span><br><span class="line">  luaD_inctop(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建词法分析器的哈希表</span></span><br><span class="line">  <span class="comment">// - 为词法分析器创建一张哈希表，存储标识符等信息</span></span><br><span class="line">  <span class="comment">// - 将该表放置在 Lua 堆栈顶端，防止其被垃圾回收器清理</span></span><br><span class="line">  lexstate.h = luaH_new(L);  <span class="comment">/* create table for scanner */</span></span><br><span class="line">  sethvalue2s(L, L-&gt;top, lexstate.h);  <span class="comment">/* anchor it */</span></span><br><span class="line">  luaD_inctop(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化函数原型</span></span><br><span class="line">  <span class="comment">// - 创建函数原型: 调用 luaF_newproto 创建函数原型对象（Proto），并将其关联到闭包的 p 字段</span></span><br><span class="line">  <span class="comment">// - 对象屏障: 使用 luaC_objbarrier 确保垃圾回收器正确处理新创建对象之间的引用</span></span><br><span class="line">  <span class="comment">// - 设置调试信息: 将 source 字段设置为源码的名称</span></span><br><span class="line">  funcstate.f = cl-&gt;p = luaF_newproto(L);</span><br><span class="line">  luaC_objbarrier(L, cl, cl-&gt;p);</span><br><span class="line">  funcstate.f-&gt;source = luaS_new(L, name);  <span class="comment">/* create and anchor TString */</span></span><br><span class="line">  luaC_objbarrier(L, funcstate.f, funcstate.f-&gt;source);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化词法和语法分析器</span></span><br><span class="line">  <span class="comment">// - 关联动态数据: 将动态缓冲区和动态数据与词法分析器状态关联</span></span><br><span class="line">  <span class="comment">// - 清空动态数据: 重置动态作用域变量、跳转目标和标签的计数</span></span><br><span class="line">  <span class="comment">// - 设置输入流: 调用 luaX_setinput 初始化词法分析器，设置输入流 z、调试信息 source 和首字符 firstchar</span></span><br><span class="line">  lexstate.buff = buff;</span><br><span class="line">  lexstate.dyd = dyd;</span><br><span class="line">  dyd-&gt;actvar.n = dyd-&gt;gt.n = dyd-&gt;label.n = <span class="number">0</span>;</span><br><span class="line">  luaX_setinput(L, &amp;lexstate, z, funcstate.f-&gt;source, firstchar);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析主函数</span></span><br><span class="line">  <span class="comment">// - 调用核心函数 mainfunc，解析整个 Lua 源码文件，构建语法树和函数原型</span></span><br><span class="line">  mainfunc(&amp;lexstate, &amp;funcstate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查解析一致性</span></span><br><span class="line">  <span class="comment">// - 检查语法解析是否正确结束：</span></span><br><span class="line">  <span class="comment">//     - 没有多余的嵌套函数</span></span><br><span class="line">  <span class="comment">//     - FuncState 中的 nups（upvalue 数量）为 1</span></span><br><span class="line">  <span class="comment">//     - LexState 中 fs（当前的函数状态）为 NULL</span></span><br><span class="line">  <span class="comment">// - 检查动态数据是否清空</span></span><br><span class="line">  lua_assert(!funcstate.prev &amp;&amp; funcstate.nups == <span class="number">1</span> &amp;&amp; !lexstate.fs);</span><br><span class="line">  <span class="comment">/* all scopes should be correctly finished */</span></span><br><span class="line">  lua_assert(dyd-&gt;actvar.n == <span class="number">0</span> &amp;&amp; dyd-&gt;gt.n == <span class="number">0</span> &amp;&amp; dyd-&gt;label.n == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理堆栈并返回</span></span><br><span class="line">  L-&gt;top--;  <span class="comment">/* remove scanner&#x27;s table */</span></span><br><span class="line">  <span class="keyword">return</span> cl;  <span class="comment">/* closure is on the stack, too */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lual_loadfilex&quot;&gt;luaL_loadfilex&lt;/h1&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    <category term="源码阅读" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="05-虚拟机" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>5.1 Lua执行的大致过程</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/5.1-Lua%E6%89%A7%E8%A1%8C%E7%9A%84%E5%A4%A7%E8%87%B4%E8%BF%87%E7%A8%8B/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/5.1-Lua%E6%89%A7%E8%A1%8C%E7%9A%84%E5%A4%A7%E8%87%B4%E8%BF%87%E7%A8%8B/</id>
    <published>2025-01-15T02:06:22.000Z</published>
    <updated>2025-07-01T11:47:43.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="和其他语言的执行差异">和其他语言的执行差异</h1><p>一般语言分为编译型语言（Compiled Language）和解释型语言（InterpretedLanguage）。前者会先将代码编译为目标机器可运行的机器码，而后由目标机器直接运行，编译型语言的特点是在编译阶段实现跨平台，不同平台的编译结果不一样，由于它能由机器直接执行，速度会很快。解释型语言则是将代码交给解释器翻译执行，它的特点是由解释器来实现跨平台，平台的差异由语言自身的解释器来解决，由于它需要由解释器来执行，相比前者会慢不少。</p><p><img src="LuaVm01.drawio.png" alt="语言间的执行差异" /><br /></p><p>Lua作为一门解释型语言，它实现了自己的虚拟机充当解释器的角色，来解释执行 Lua代码。这里有一点需要注意，Lua会先将代码进行语法词法分析，生成虚拟机能看懂的字节码（后称OpCode），再由虚拟机执行。现在不少解释型语言和Lua采用了一样的思路，虽然最终是在解释器中执行，但是仍然预先制定了一套语言定制化的编译规则，将代码编译为对应的字节码后再交给解释器执行，这样做会加快代码的执行速度但是仍然有部分语言是采用直接解释执行。比如Bash、AWK、早期的 PHP、Basic 等</p><h2 id="lua-的即时编译和jit的区别">Lua 的即时编译和JIT的区别</h2><p>Lua虽然是先编译为字节码，再交由虚拟机执行，但编译也是发生在运行阶段的，也就是说Lua是即时编译的。即时编译并不会妨碍它作为解释型语言在运行时可修改的特性，但Lua 的即时编译和传统的 JIT 有所不同。</p><p>Lua 的编译执行过程分为两个阶段：</p><ul><li>即时编译阶段（源代码 –&gt; 字节码）<ul><li>当 Lua 脚本被加载时，Lua 虚拟机会将源代码即时编译为字节码</li><li>这一步发生在运行时，即每次加载脚本时都会进行，这个编译过程由<code>lua_load</code> 函数完成</li></ul></li><li>解释运行阶段（字节码 –&gt; 执行）<ul><li>编译后的字节码并不会被进一步编译为机器码，而是由 Lua虚拟机逐条解释执行</li></ul></li></ul><p>Lua 的即时编译与真正的 JIT 编译的区别在于：Lua即时编译的结果并非目标机器码，而是一种中间表示，只有它的虚拟机能够解释执行。</p><h2 id="lua-为何不采用-jit-编译">Lua 为何不采用 JIT 编译？</h2><p>它的官方解释器（PUC-Rio Lua）并没有集成 JIT 编译器，原因如下：</p><ul><li>跨平台性：<ul><li>Lua以简单和轻量为核心设计目标，官方解释器支持多种平台，而字节码和虚拟机的实现更容易移植</li><li>JIT 编译器需要针对特定的 CPU 架构生成机器码，移植性较差</li></ul></li><li>嵌入式使用：<ul><li>Lua主要被设计为嵌入式脚本语言，典型场景包括嵌入游戏引擎、应用程序等</li><li>字节码解释足以满足大部分需求，同时减少了 JIT编译的复杂性和内存开销</li></ul></li><li>性能需求：<ul><li>Lua 的性能在许多嵌入式场景下已经足够</li><li>对于更高性能需求的场景，可以使用 LuaJIT（Lua 的一个 JIT编译器版本，将字节码直接编译为机器码，极大提升了性能）</li></ul></li></ul><h1 id="虚拟机概览">虚拟机概览</h1><p>除了 Lua，还有一些其他语言也实现了自己的虚拟机比如 Java 和Python。一般一个语言的虚拟机的职责如下：</p><ul><li>将源代码编译成虚拟机可识别执行的字节码</li><li>为函数调用准备调用栈</li><li>内部维持一个指令指针（IP，InstructionPointer）来保存下一个将执行的指令地址。在 Lua 中，该 IP 对应的是 PC指针，后续会讲</li><li>模拟一个 CPU 的运行：循环拿出由 IP指向的字节码，根据字节码格式进行解码，然后执行</li></ul><p>这样一来，一台抽象的计算机就出现了，这也是它们被称为虚拟机的原因。</p><p>虚拟机有两种实现方式：基于栈（stack-based）和基于寄存器（register-based），市面上常见的都是前者，而Lua 属于后者。</p><h2 id="基于栈的虚拟机">基于栈的虚拟机</h2><p>对于这种虚拟机，字节码的操作数从栈顶弹出，执行完操作后再压入栈顶，下图是一个加法操作后栈结构的变化：</p><p><img src="LuaVm02.drawio.png" alt="基于栈的虚拟机" /><br /></p><p>这个操作对应的伪代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POP 2</span><br><span class="line">POP 1</span><br><span class="line">ADD 2,1,result</span><br><span class="line">PUSH result</span><br></pre></td></tr></table></figure><p>完成一个加法操作需要 4条字节码，需要用额外的指令准备数据是这种设计的缺点。但是优点是指令不需要关心操作数的地址，在执行操作前已经将操作数准备在栈顶了</p><h2 id="基于寄存器的虚拟机">基于寄存器的虚拟机</h2><p>和基于栈的虚拟机不同，这种虚拟机将操作数存放在 “CPU的寄存器”中，这个寄存器不是物理意义上的寄存器，而是虚拟机的一种抽象实现。它实现前面的加法操作的示意图如下：</p><p><img src="LuaVm03.drawio.png" alt="基于寄存器的虚拟机" /><br /></p><p>它对应的伪代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD R1,R2,R3 <span class="comment">#寄存器R1与R2相加结果保存在寄存器R3中</span></span><br></pre></td></tr></table></figure><p>这种虚拟机的优点是，指令简短，但缺点是程序需要关注操作数的位置。Lua选择这种寄存器的主要目的是尽可能高效。</p><h1 id="执行源码概览">执行源码概览</h1><p>这里以一个宏观的角度浏览整个编译解释和执行的流程，具体函数的分析参考<ahref="https://peiyuzou.github.io/wiki/02-编程语言/Lua/源码阅读/05-虚拟机/5.x-虚拟机相关函数解读/">函数解读</a></p><h2 id="lual_dofile">luaL_dofile</h2><p>这是 Lua 执行文件的调用函数，本身是个宏，等效于先调用<code>luaL_loadfile</code>，再调用 <code>lua_ocall</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> luaL_dofile(L, fn) \</span></span><br><span class="line"><span class="meta">(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))</span></span><br></pre></td></tr></table></figure><p>luaL_loadfile 负责进行词法语法分析，lua_pcall则将分析结果放到虚拟机中执行</p><h2 id="编译解释流程">编译解释流程</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;和其他语言的执行差异&quot;&gt;和其他语言的执行差异&lt;/h1&gt;
&lt;p&gt;一般语言分为编译型语言（Compiled Language）和解释型语言（Interpreted
Language）。前者会先将代码编译为目标机器可运行的机器码，而后由目标机器直接运行，编译型语言的</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    <category term="源码阅读" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="05-虚拟机" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Lua" scheme="https://peiyuzou.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>4.2 表相关的算法</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/4.2-%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/4.2-%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AE%97%E6%B3%95/</id>
    <published>2025-01-14T03:05:06.000Z</published>
    <updated>2025-01-14T10:01:19.410Z</updated>
    
    <content type="html"><![CDATA[<p>在上一节中，我们简要提到了表的数组部分和哈希部分会进行自适应调整；以正整数为键的数据可能会存储在数组部分，也可能存储在哈希部分；存储在数组部分时，它的键就是数组的索引；而存储在哈希部分时，就是单纯的键值对。Lua有一个标准去做这个调整，保证数组和哈希部分有最优的边界。</p><p>我们在来看这个例子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">t[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">t[<span class="number">100</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>插入的这两个元素对外部使用者来说，并不能准确地知道它们究竟写入了数组还是哈希表。我们先跳过它的写入逻辑，来看看table 是怎么处理查找的。</p><h1 id="查找">查找</h1><p>table 处理查找的伪代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> key &gt; <span class="number">0</span> <span class="keyword">and</span> key &lt;= 数组大小 <span class="keyword">then</span> <span class="comment">--在数组索引范围内</span></span><br><span class="line">    尝试在数组部分查找</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    尝试在哈希部分查找</span><br><span class="line">    <span class="comment">--[[</span></span><br><span class="line"><span class="comment">        1.计算出key的哈希值，根据哈希值访问Node数组得到哈希桶位置</span></span><br><span class="line"><span class="comment">        2.遍历哈希桶链表，直到找到对应key</span></span><br><span class="line"><span class="comment">    ]]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>可以看出来，一个正整数，只有在数组索引范围内时，其存储才会落在数组部分。否则也会存储在哈希部分。</p><h1 id="新增">新增</h1><p>上面关于查找的算法可以看出来，table 的哈希部分采用链地址法。Lua将哈希桶所在的位置称为<code>mainposition</code>。哈希部分的链表结构和普通链地址法的哈希表一致：</p><p><img src="LuaTableHash.drawio.png" alt="table的哈希表结构" /><br /></p><p>那么 Lua 在往 table新增数据的时候，是如何处理的？让我们关注两个入口函数<code>luaH_set</code> 和 <code>luaH_setint</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaH_set</span> <span class="params">(lua_State *L, Table *t, <span class="type">const</span> TValue *key, TValue *value)</span> &#123;</span><br><span class="line">  <span class="type">const</span> TValue *slot = luaH_get(t, key);</span><br><span class="line">  luaH_finishset(L, t, key, slot, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">luaH_setint</span> <span class="params">(lua_State *L, Table *t, lua_Integer key, TValue *value)</span> &#123;</span><br><span class="line">  <span class="type">const</span> TValue *p = luaH_getint(t, key);</span><br><span class="line">  <span class="keyword">if</span> (isabstkey(p)) &#123;</span><br><span class="line">    TValue k;</span><br><span class="line">    setivalue(&amp;k, key);</span><br><span class="line">    luaH_newkey(L, t, &amp;k, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    setobj2t(L, cast(TValue *, p), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和以前的版本不同，Lua 5.4.4 中并没有<code>luaH_setstr</code>、<code>luaH_setnum</code>等API，它使用了一个公共的 <code>luaH_set</code>来满足全部类型数据的新增，这本身是得益于 TValue 结构的优化。</p><h2 id="luah_setint">luaH_setint ?</h2><p>而 <code>luaH_setint</code>则是基于整数键做出的优化函数，它会判断整数键是否属于表的数组部分，从而绕过了非整数键的检查逻辑。这样具有更高的访问效率，减少了很多不必要的逻辑计算。</p><p>举个例子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">t[<span class="number">1</span>] = <span class="string">&quot;a&quot;</span>    <span class="comment">-- 整数键</span></span><br><span class="line">t[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;b&quot;</span> <span class="comment">-- 字符串键</span></span><br></pre></td></tr></table></figure><p><code>t[1] = "a"</code></p><ul><li>Lua会调用 <code>luaH_setint</code></li><li>如果键 <code>1</code> 落在数组部分，直接将 <code>"a"</code>存入数组部分</li><li>如果键超出数组范围或数组未分配足够大小，调整 alimit或将键值存入哈希部分</li></ul><p><code>t["key"] = "b"</code></p><ul><li>Lua 会调用 <code>luaH_set</code></li><li>根据键的类型（字符串），计算其哈希值，找到对应的哈希桶并插入</li></ul><h2 id="luah_newkey">luaH_newkey</h2><p>不管是调用 <code>luaH_setint</code> 还是<code>luaH_set</code>，如果新增的键不存在，都牵涉到一个函数<code>luaH_newkey</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** inserts a new key into a hash table; first, check whether key&#x27;s main</span></span><br><span class="line"><span class="comment">** position is free. If not, check whether colliding node is in its main</span></span><br><span class="line"><span class="comment">** position or not: if it is not, move colliding node to an empty place and</span></span><br><span class="line"><span class="comment">** put new key in its main position; otherwise (colliding node is in its main</span></span><br><span class="line"><span class="comment">** position), new key goes to an empty position.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">luaH_newkey</span> <span class="params">(lua_State *L, Table *t, <span class="type">const</span> TValue *key, TValue *value)</span> &#123;</span><br><span class="line">  Node *mp;</span><br><span class="line">  TValue aux;</span><br><span class="line">  <span class="keyword">if</span> (l_unlikely(ttisnil(key)))</span><br><span class="line">    luaG_runerror(L, <span class="string">&quot;table index is nil&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ttisfloat(key)) &#123;</span><br><span class="line">    lua_Number f = fltvalue(key);</span><br><span class="line">    lua_Integer k;</span><br><span class="line">    <span class="keyword">if</span> (luaV_flttointeger(f, &amp;k, F2Ieq)) &#123;  <span class="comment">/* does key fit in an integer? */</span></span><br><span class="line">      setivalue(&amp;aux, k);</span><br><span class="line">      key = &amp;aux;  <span class="comment">/* insert it as an integer */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l_unlikely(luai_numisnan(f)))</span><br><span class="line">      luaG_runerror(L, <span class="string">&quot;table index is NaN&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ttisnil(value))</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">/* do not insert nil values */</span></span><br><span class="line">  mp = mainpositionTV(t, key);</span><br><span class="line">  <span class="keyword">if</span> (!isempty(gval(mp)) || isdummy(t)) &#123;  <span class="comment">/* main position is taken? */</span></span><br><span class="line">    Node *othern;</span><br><span class="line">    Node *f = getfreepos(t);  <span class="comment">/* get a free place */</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;  <span class="comment">/* cannot find a free place? */</span></span><br><span class="line">      rehash(L, t, key);  <span class="comment">/* grow table */</span></span><br><span class="line">      <span class="comment">/* whatever called &#x27;newkey&#x27; takes care of TM cache */</span></span><br><span class="line">      luaH_set(L, t, key, value);  <span class="comment">/* insert key into grown table */</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lua_assert(!isdummy(t));</span><br><span class="line">    othern = mainpositionfromnode(t, mp);</span><br><span class="line">    <span class="keyword">if</span> (othern != mp) &#123;  <span class="comment">/* is colliding node out of its main position? */</span></span><br><span class="line">      <span class="comment">/* yes; move colliding node into free position */</span></span><br><span class="line">      <span class="keyword">while</span> (othern + gnext(othern) != mp)  <span class="comment">/* find previous */</span></span><br><span class="line">        othern += gnext(othern);</span><br><span class="line">      gnext(othern) = cast_int(f - othern);  <span class="comment">/* rechain to point to &#x27;f&#x27; */</span></span><br><span class="line">      *f = *mp;  <span class="comment">/* copy colliding node into free pos. (mp-&gt;next also goes) */</span></span><br><span class="line">      <span class="keyword">if</span> (gnext(mp) != <span class="number">0</span>) &#123;</span><br><span class="line">        gnext(f) += cast_int(mp - f);  <span class="comment">/* correct &#x27;next&#x27; */</span></span><br><span class="line">        gnext(mp) = <span class="number">0</span>;  <span class="comment">/* now &#x27;mp&#x27; is free */</span></span><br><span class="line">      &#125;</span><br><span class="line">      setempty(gval(mp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* colliding node is in its own main position */</span></span><br><span class="line">      <span class="comment">/* new node will go into free position */</span></span><br><span class="line">      <span class="keyword">if</span> (gnext(mp) != <span class="number">0</span>)</span><br><span class="line">        gnext(f) = cast_int((mp + gnext(mp)) - f);  <span class="comment">/* chain new position */</span></span><br><span class="line">      <span class="keyword">else</span> lua_assert(gnext(f) == <span class="number">0</span>);</span><br><span class="line">      gnext(mp) = cast_int(f - mp);</span><br><span class="line">      mp = f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setnodekey(L, mp, key);</span><br><span class="line">  luaC_barrierback(L, obj2gco(t), key);</span><br><span class="line">  lua_assert(isempty(gval(mp)));</span><br><span class="line">  setobj2t(L, gval(mp), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们逐段分析，看看这个函数做了什么。</p><ul><li>首先是第 11 ~ 24 行，这一段针对 key做了一些错误处理，中间的分支对于浮点数键做了处理：如果 key是一个浮点数，但是它的值是一个整数，那么把 key 作为一个整型值插入。</li><li>第 25 行，计算得到 key 的哈希值mainposition，也就是它在哈希数组中的哈希桶的地址</li><li>先看 58 ~ 61 行，该 mainposition 位置空闲，这里直接将 key 和 value设置给该位置的 Node</li><li>再看 26 ~ 57 行，该 mainposition位置冲突（我们暂且称这里存放的节点为冲突节点）<ul><li>28 ~ 34 行，尝试找一个空闲位置，如果没有，执行一次 rehash 扩张一次table，然后插入 key 和 value</li><li>36 行，有现成的空闲位置，那么计算这个冲突节点的 mainposition<ul><li>37 ~ 48 行，冲突节点的 mainposition在其它位置，那么把冲突节点移动到一个空闲位置</li><li>50 ~ 57 行，冲突节点的 mainposition 就在它当前位置，那么把当前 key和 value 插入空闲位置</li></ul></li></ul></li></ul><p>总结就是：首先，检查 key的主位置是否空闲。如果不是，则检查冲突节点是否在其主位置：如果不是，则将冲突节点移至空位置并将key 放入其主位置；否则（冲突节点在其主位置），key 将移至空位置</p><blockquote><p>这里要重点注意，整个操作都是基于哈希表进行的，而没有关于数组的逻辑。因为在执行<code>luaH_newkey</code> 之前，一定是通过 <code>luaH_get</code> 或者<code>luaH_getint</code>在数组部分检查过了，数组部分不存在的情况下，才会走进<code>luaH_newkey</code> 的逻辑。</p></blockquote><h2 id="rehash">rehash</h2><p>从前面的代码可见，在空闲空间不足的情况下，table 会自动执行一次rehash，这个函数就是我们在前一节提到的自适应调整数组部分和哈希部分空间的算法，让我们来看看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** nums[i] = number of keys &#x27;k&#x27; where 2^(i - 1) &lt; k &lt;= 2^i</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rehash</span> <span class="params">(lua_State *L, Table *t, <span class="type">const</span> TValue *ek)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> asize;  <span class="comment">/* optimal size for array part */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> na;  <span class="comment">/* number of keys in the array part */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nums[MAXABITS + <span class="number">1</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> totaluse;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= MAXABITS; i++) nums[i] = <span class="number">0</span>;  <span class="comment">/* reset counts */</span></span><br><span class="line">  setlimittosize(t);</span><br><span class="line">  na = numusearray(t, nums);  <span class="comment">/* count keys in array part */</span></span><br><span class="line">  totaluse = na;  <span class="comment">/* all those keys are integer keys */</span></span><br><span class="line">  totaluse += numusehash(t, nums, &amp;na);  <span class="comment">/* count keys in hash part */</span></span><br><span class="line">  <span class="comment">/* count extra key */</span></span><br><span class="line">  <span class="keyword">if</span> (ttisinteger(ek))</span><br><span class="line">    na += countint(ivalue(ek), nums);</span><br><span class="line">  totaluse++;</span><br><span class="line">  <span class="comment">/* compute new size for array part */</span></span><br><span class="line">  asize = computesizes(nums, &amp;na);</span><br><span class="line">  <span class="comment">/* resize the table to new computed sizes */</span></span><br><span class="line">  luaH_resize(L, t, asize, totaluse - na);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的大致算法思路如下：</p><ul><li>分配一个数组 <code>nums</code>，初始它的每个元素都是0，假设它的下标用变量 i 表示，它的每个元素的含义是 key 的值在 <spanclass="math inline">\({2^{(i-1)}}\)</span> ~ <spanclass="math inline">\({2^i}\)</span> 之间的元素数量（左开右闭）</li><li>遍历数组部分，统计元素数量更新到 nums</li><li>遍历哈希部分，只统计正整数键，更新到 nums</li><li>此时，整个 table 的正整数 key 的分配已经统计在了 nums 中。接着遍历nums数组，找到范围区间内包含的整数数量大于50%，满足这个条件的索引可能有很多个，只要索引最大的那个</li><li>这个索引作为重新散列后的数组大小，也就是之前提到的<code>alimit</code>，凡是超过这个值的 key，就分配到了哈希部分</li></ul><p>从这个函数可以看出 Lua的设计思想：简单高效、且尽量节省内存。在重新散列的过程中，除了要增大table的大小来容纳新的数据外，还借此机会调整了数组和哈希两个部分，让两部分都尽可能发挥其容纳效率。</p><p>下面的图是调整后的数组部分的示意图，每个 2的幂之间的空间的存储率都大于 50%，这也是 Lua认为数组达到最大容纳效率的标准：</p><p><img src="LuaTableRehash.drawio.png"alt="rehash调整后的数组" /><br /></p><h2 id="代价">代价？</h2><p>从上面的分析可以看出， Lua解释器会自动进行重新散列，并且对使用者来说是透明的。从算法和以往对哈希表扩容的经验来看，这个操作的开销不会很小，然而我们在知晓其原理后，可以手动减少它的发生，来看一个例子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">    t[i] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个代码执行会触发 3 次 rehash：</p><ul><li>第一次，为了装下 t[1] , Lua 触发了一次 rehash，数组部分长度设置为1</li><li>第二次，数组长度设置为 2</li><li>第三次，数组长度设置为 4</li></ul><p>也就是说，如果数组部分要装下一个数，需要执行 n 次 rehash，保证 <spanclass="math inline">\({2^n}\)</span> 大于key。对于超多元素的表，比如100万个元素，其实也不过触发了 20 次rehash。但是在一个需要创建大量小长度的表的情况下，这个问题会很严重。但是我们可以尽可能地减少它，来看对比：</p><p><img src="202401141725.png" alt="创建大量小长度的表" /><br /></p><p>我们使用预填充的方法，减少触发重新散列，这里的优化提高了一倍多的速度！</p><h1 id="迭代">迭代</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaH_next</span> <span class="params">(lua_State *L, Table *t, StkId key)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> asize = luaH_realasize(t);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = findindex(L, t, s2v(key), asize);  <span class="comment">/* find original key */</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; asize; i++) &#123;  <span class="comment">/* try first array part */</span></span><br><span class="line">    <span class="keyword">if</span> (!isempty(&amp;t-&gt;<span class="built_in">array</span>[i])) &#123;  <span class="comment">/* a non-empty entry? */</span></span><br><span class="line">      setivalue(s2v(key), i + <span class="number">1</span>);</span><br><span class="line">      setobj2s(L, key + <span class="number">1</span>, &amp;t-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i -= asize; cast_int(i) &lt; sizenode(t); i++) &#123;  <span class="comment">/* hash part */</span></span><br><span class="line">    <span class="keyword">if</span> (!isempty(gval(gnode(t, i)))) &#123;  <span class="comment">/* a non-empty entry? */</span></span><br><span class="line">      Node *n = gnode(t, i);</span><br><span class="line">      getnodekey(L, s2v(key), n);</span><br><span class="line">      setobj2s(L, key + <span class="number">1</span>, gval(n));</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* no more elements */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lua中表的迭代并没有设计迭代器，很大原因是为了兼容数组部分和哈希部分的访问。</p><p>luaH_next 大致的逻辑是在当前 key 的基础上找下一个有效键值对</p><ul><li>如果 key 是 nil，表示从头开始遍历，否则找到该 key的位置，然后从下一个位置继续</li><li>优先遍历数组部分，因为顺序表遍历更快，找到下一个非空值。</li><li>如果数组部分没有找到，再遍历哈希部分，这部分就需要遍历每个桶，找到下一个有效键值对</li><li>不管在是数组部分还是哈希部分找到，都将键和值压入 Lua栈，并返回成功或失败（1或0）</li></ul><h1 id="取长度">取长度</h1><p>在 Lua 中，我们可以提供元方法 <code>__len</code>来自定义表的取长度方法，Lua 本身默认提供了 <code>#</code>作为取长度符号。</p><p>它的取长度的结果不是 table 的全部元素的数量，而是 table的序列部分的长度，这个序列部分指表的第一个键的值连续的数据子集，比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(#&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">nil</span>,<span class="number">10</span>&#125;) <span class="comment">-- 输出 5</span></span><br></pre></td></tr></table></figure><p>这和数组部分无关，尽管它看起来像是数组，这个所谓的序列对哈希部分也是一样的规则：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t1 = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(#t1) <span class="comment">-- 输出 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t2 = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="number">2</span>,</span><br><span class="line">    [<span class="number">5</span>] = <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(#t2) <span class="comment">-- 输出 2</span></span><br></pre></td></tr></table></figure><p>如果一个表混合了这两种风格，那么优先取数组部分的长度：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(#&#123;[<span class="number">1</span>] = <span class="number">1</span>, [<span class="number">2</span>] = <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;) <span class="comment">-- 输出 3</span></span><br></pre></td></tr></table></figure><p>取长度对应的源码函数是<code>luaH_getn</code>，这里不赘述了，它的算法思路大致就是先在数组部分取长度，没有取成功就在哈希部分取</p><h1 id="总结">总结</h1><p>Lua的表内部分为数组部分和哈希部分，虽然对使用者是透明的，但是理解其存储原理会帮助我们更正确地使用它：</p><ul><li>尽量避免混用数组和哈希，提升效率</li><li>可以通过预先分配的方式，减少 rehash</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一节中，我们简要提到了表的数组部分和哈希部分会进行自适应调整；以正整数为键的数据可能会存储在数组部分，也可能存储在哈希部分；存储在数组部分时，它的键就是数组的索引；而存储在哈希部分时，就是单纯的键值对。Lua有一个标准去做这个调整，保证数组和哈希部分有最优的边界。&lt;/p</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    <category term="源码阅读" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="04-表" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/"/>
    
    
    <category term="Lua" scheme="https://peiyuzou.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>2.1 Lua中的数据类型</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.1-Lua%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.1-Lua%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2024-12-10T09:27:20.000Z</published>
    <updated>2025-01-14T02:18:56.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础类型">基础类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (lua.h)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** basic types</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNONE(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNIL0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TBOOLEAN1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TLIGHTUSERDATA2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNUMBER3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TSTRING4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTABLE5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TFUNCTION6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TUSERDATA7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTHREAD8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_NUMTYPES9</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>宏</th><th>类型描述</th><th>对应数据结构</th></tr></thead><tbody><tr><td>LUA_TNONE</td><td>无效类型</td><td>无</td></tr><tr><td>LUA_TNIL</td><td>空</td><td>无</td></tr><tr><td>LUA_TBOOLEAN</td><td>布尔</td><td>无</td></tr><tr><td>LUA_TLIGHTUSERDATA</td><td>指针</td><td>void *</td></tr><tr><td>LUA_TNUMBER</td><td>数值</td><td>lua_Number</td></tr><tr><td>LUA_TSTRING</td><td>字符串</td><td>TString</td></tr><tr><td>LUA_TTABLE</td><td>表</td><td>Table</td></tr><tr><td>LUA_TFUNCTION</td><td>函数</td><td>CClosure、LClosure</td></tr><tr><td>LUA_TUSERDATA</td><td>指针</td><td>Udata</td></tr><tr><td>LUA_TTHREAD</td><td>Lua虚拟机、协程</td><td>lua_State</td></tr></tbody></table><p>宏 <code>LUA_NUMTYPES</code> 指有效数据类型的数量，即0~8共9个</p><p>其中 <code>LUA_TLIGHTUSERDATA</code> 和 <code>LUA_TUSERDATA</code>均是指针，userdata 指一些外部的用户知晓的内存块，它们的类型不被 Lua定义，用指针来访问它们以在 Lua中实现对外部数据的操作。两者的区别在于，LUA_TLIGHTUSERDATA的分配释放由外部自己管理，所以 Lua将它视为值类型，因为不需要分配任何额外空间来存储数据，仅仅只是一个指针而已。LUA_TUSERDATA则由内部管理，Lua 为它定义了 <code>Udata</code>结构，存储它的数据，并且加入GC的管理。</p><blockquote><p>需要注意的是，这些宏并不是真正的类型，只是用某个数字代指这个类型，真正的类型是表格中的最后一列：对应数据结构</p></blockquote><h1 id="动态类型是如何实现的">动态类型是如何实现的？</h1><p>Lua是动态类型的语言，动态类型指一个变量在不同时刻可以是不同类型的</p><p>它通过一个通用结构体 <code>TValue</code>来定义任意的类型，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Tagged Values. This is the basic representation of values in Lua:</span></span><br><span class="line"><span class="comment">** an actual value plus a tag with its type.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TValuefieldsValue value_; lu_byte tt_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TValue</span> &#123;</span></span><br><span class="line">  TValuefields;</span><br><span class="line">&#125; TValue;</span><br></pre></td></tr></table></figure><p>简单来说，<code>tt_</code>用于标记这个结构体是什么类型，<code>value_</code>则存储实际的值数据。当一个变量需要变为其他类型时，改变它的 tt_字段的值，同时设置对应的 Value_ 值即可做到。</p><h1 id="类型标记type-tag">类型标记（Type Tag）</h1><p><code>tt_</code> 全称是 Type Tag ，用于标记当前对象的类型，它被声明为<code>lu_byte</code> 类型，lu_byte 宏代指 unsigned char类型（占一个字节，范围0~255），由于基础类型的标记最高值是8，因此低4位被设计用于标记基础类型，其它的位设计如下：</p><table><thead><tr><th>7 bit</th><th>6 bit</th><th>5-4 bit</th><th>3-0 bit</th></tr></thead><tbody><tr><td>reserved</td><td>GC Tag</td><td>variant type tag</td><td>basic type tag</td></tr></tbody></table><p>从表中可以看到，除了低4位被用于标记基础类型，Lua还在 bits(4-5)设计了变种类型，变种类型让 Lua对类型标记进一步划分，用于内部更加多样化的数据支持、更加精确地处理数据、甚至是提升性能。如下是Lua 将数值类型 LUA_TNUMBER 进行变种得到整型数和浮点数的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (lobject.h)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** tags for Tagged Values have the following use of bits:</span></span><br><span class="line"><span class="comment">** bits 0-3: actual tag (a LUA_T* constant)</span></span><br><span class="line"><span class="comment">** bits 4-5: variant bits</span></span><br><span class="line"><span class="comment">** bit 6: whether value is collectable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* add variant bits to a type */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> makevariant(t,v)((t) | ((v) &lt;&lt; 4))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Variant tags for numbers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_VNUMINTmakevariant(LUA_TNUMBER, 0)  <span class="comment">/* integer numbers */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_VNUMFLTmakevariant(LUA_TNUMBER, 1)  <span class="comment">/* float numbers */</span></span></span><br></pre></td></tr></table></figure><p>除了 variant type tag 和 basic type tag，还有用于标记是否可被回收的GC Tag。而 bit 7 目前保留没有任何作用</p><h1id="tvalue的结构设计valuegcobject和gcunion">TValue的结构设计（Value、GCObject和GCUnion）</h1><p><img src="Lua通用数据结构的设计.drawio.png"alt="Struct of TValue" /><br /></p><h2 id="tvalue">TValue</h2><p><code>TValue</code> 结构如上图所示，包含一个联合体<code>value_</code> 和一个类型标记 <code>tt_</code>，对应源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Tagged Values. This is the basic representation of values in Lua:</span></span><br><span class="line"><span class="comment">** an actual value plus a tag with its type.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TValuefieldsValue value_; lu_byte tt_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TValue</span> &#123;</span></span><br><span class="line">  TValuefields;</span><br><span class="line">&#125; TValue;</span><br></pre></td></tr></table></figure><p><code>tt_</code> 标记了联合体 <code>value_</code>分配的空间中值的具体类型，由此知道该以什么样的结构使用这块内存。另外，前述内容也提到<code>tt_</code>的第7位标记了当前类型是否是可回收类型，以下代码是判断一个对象是否是可回收的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bit mark for collectable types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ISCOLLECTABLE(1 &lt;&lt; 6)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> iscollectable(o)(rawtt(o) &amp; BIT_ISCOLLECTABLE)</span></span><br></pre></td></tr></table></figure><h2 id="value">Value</h2><p>再看 <code>Value</code> 的设计，这个域负责存储实际的值，我们知道 Lua有自己的垃圾回收机制，因此它的类型设计包含了可回收和不可回收两种。</p><p>在 <code>Value</code> 这一层面，Lua将这两种类型区分开了，可回收的对象表达为一个指针，而没有直接存储它。不可回收的类型则全部声明为联合体的域。整个联合体只是在栈上分配了一个空间，存储这些域的其中之一：</p><ul><li>GCObject *gc：指向一个可回收对象的内存地址</li><li>void *p：本质就是一个指针，Lua中称它为<code>lightuserdata</code>，和 <code>userdata</code> 不同，前者不需要Lua 管理内存，只是作为变量保存一个地址。后者则需要 Lua 负责管理内存</li><li>lua_CFunction f：本质上也是一个指针，指向一个 C 函数</li><li>lua_Integer i：存储整型数值</li><li>lua_Number n：存储浮点数值</li></ul><h2 id="gcunion和gcobject">GCUnion和GCObject</h2><p>为了更好地理解 <code>GCObject</code>，我们要先了解<code>GCUnion</code> 这个联合体</p><p><code>GCUnion</code> 是真正定义GC对象存储位置的结构，Lua中的全部可回收类型都定义为它的域</p><p>其中比较特殊的是 <code>GCObject</code>，它只包含一个<code>CommonHeader</code> 宏，源码定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Common Header for all collectable objects (in macro form, to be</span></span><br><span class="line"><span class="comment">** included in other objects)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CommonHeaderstruct GCObject *next; lu_byte tt; lu_byte marked</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Common type for all collectable objects */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GCObject</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">&#125; GCObject;</span><br></pre></td></tr></table></figure><p><code>CommonHeader</code> 包含三个域：</p><ul><li>GCObject *next：这个指针指向下一个 GC 对象，所有 GC 对象通过各自的next 指针链接起来形成整个 GC 链表</li><li>lu_byte tt：也是类型标记，和 <code>tt_</code> 相同，但由于<code>GCObject</code>在堆内存中单独分配，所以这里为它再存了一份，便于访问</li><li>lu_byte marked：GC 阶段的标记</li></ul><p>Lua 中需要 GC 的类型很多，但在作为可回收对象时，都是统一作为<code>GCObject</code> 类型。这里很多人会产生一个疑问：GCUnion作为一个联合体，同一个内存如何转换 <code>GCObject</code>和其他类型？</p><p>要回答这个问题，需要看其他 GC 类型的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  ... <span class="comment">/* other fields */</span></span><br><span class="line">&#125; TString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Udata</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  ... <span class="comment">/* other fields */</span></span><br><span class="line">&#125; Udata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  ... <span class="comment">/* other fields */</span></span><br><span class="line">&#125; Table;</span><br></pre></td></tr></table></figure><p>现在应该明白了，所有类型的内存头部都是相同的结构<code>CommonHeader</code>，相当于需要把一个类型作为<code>GCObject</code> 的时候，只是访问了这个头部结构的内存数据罢了。</p><p>除开 <code>GCObject</code> ，其他的类型我们先简单了解下：</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>TString</td><td>字符串</td></tr><tr><td>Udata</td><td>用户数据指针</td></tr><tr><td>Closure</td><td>闭包</td></tr><tr><td>Table</td><td>表</td></tr><tr><td>Proto</td><td>函数原型</td></tr><tr><td>lua_State</td><td>Lua虚拟机</td></tr><tr><td>UpVal</td><td>上值</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础类型&quot;&gt;基础类型&lt;/h1&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    <category term="源码阅读" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="02-数据类型" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
    <category term="Lua" scheme="https://peiyuzou.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>4.1 表的数据结构</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/4.1-%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/4.1-%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2024-12-10T06:59:20.000Z</published>
    <updated>2025-01-14T03:00:34.696Z</updated>
    
    <content type="html"><![CDATA[<p>Lua 用 table 来表示一切数据结构，为了效率，Lua 将 table 的存储分为了<code>数组</code> 和 <code>哈希表</code> 两个部分。</p><ul><li>数组部分提供了紧凑且高效的随机访问。它的索引从1开始，这是 Lua区别于其他语言的一个地方。</li><li>无法存进数组的其他数据则存储在哈希表中，它的键可以是除nil外的任意值。</li></ul><p>这样的分开存储对使用者来说完全透明，但是我们需要掌握它存储的原理和逻辑，否则会造成预想不到的性能开销。它的数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte flags;  <span class="comment">/* 1&lt;&lt;p means tagmethod(p) is not present */</span></span><br><span class="line">  lu_byte lsizenode;  <span class="comment">/* log2 of size of &#x27;node&#x27; array */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> alimit;  <span class="comment">/* &quot;limit&quot; of &#x27;array&#x27; array */</span></span><br><span class="line">  TValue *<span class="built_in">array</span>;  <span class="comment">/* array part */</span></span><br><span class="line">  Node *node;</span><br><span class="line">  Node *lastfree;  <span class="comment">/* any free position is before this position */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> *<span class="title">metatable</span>;</span></span><br><span class="line">  GCObject *gclist;</span><br><span class="line">&#125; Table;</span><br></pre></td></tr></table></figure><p>简单介绍下它的每个域：</p><ul><li>CommonHeader：可回收对象默认在头部分配的内存</li><li>flags：表示这个表提供了哪些元方法，置 1的位代表对应的元方法没有实现，元方法对应的 bit 定义在 ltm.h 文件中</li><li>lsizenode：存储哈希表的大小，它的值是以2为底的对数。比如哈希表的长度是256，那么lsizenode 的值为8，由此我们可以得到两个信息：<ul><li>哈希表扩容是在原基础上加一倍，哈希表的内存大小始终是 2 的幂</li><li>这个域之所以是 byte 类型，是因为足够了</li></ul></li><li>alimit：表示数组部分的逻辑边界，下文详解</li><li>array：指向数组部分的指针</li><li>node：指向哈希部分起始位置的指针</li><li>lastfree：指向哈希部分最后位置的指针</li><li>metatable：指向当前表的元表的指针</li><li>gclist：GC相关的链表，后续讲GC再探讨</li></ul><h1 id="alimit">alimit</h1><p><code>alimit</code> 理解为 array limit，是 Lua 5.4引入的一个字段，用于标记 Table 数组部分的<code>逻辑边界</code>。它的主要作用是动态调整数组部分的有效范围，从而优化表的访问效率。</p><p>怎么理解所谓的逻辑边界？首先，Lua对数组的内存分配并不是最大索引是多少就分配多少，而是一个和哈希表大小挂钩自适应调整大小的分配规则（下文会分析），最后数组的大小会调整为一个2的幂。而alimit 代表当前数组部分实际使用的索引范围。</p><p>先说下这个自适应调整是什么意思，假设我们有以下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">t[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">t[<span class="number">100</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>我们往一个 table中插入了两个元素，这两个元素一定会分配在数组中吗？这是不一定的。Lua会根据数组部分的有效索引和哈希部分的全部正整数key（数组下标只能是正整数）的分布情况，以一个位图算法计算出一个边界，超过这个边界的部分会存储在哈希表中，这是整个自适应调整的大致逻辑，后面讲table 相关算法时会详细分解。</p><h2 id="那为什么需要-alimit">那为什么需要 alimit ?</h2><ul><li>优化性能：在 Lua中，数组部分的大小会根据表的使用情况动态调整，但实际使用的范围可能小于分配的大小。使用alimit 可以快速判断哪些索引属于数组部分，而无需频繁操作内存。</li><li>支持稀疏数组：Lua 表可以是稀疏的，即索引并非连续的整数。alimit帮助区分哪些索引属于数组部分，哪些应该存储在哈希部分。</li></ul><h2 id="使用-alimit-的场景">使用 alimit 的场景</h2><ul><li>快速访问：通过 alimit，Lua可以快速判断某个索引是否在数组部分的有效范围内，而无需逐一检查。</li><li>表的结构发生变化：如插入或删除元素，Lua会重新评估表的分布（rehash）。在 rehash 过程中，Lua 会调整 alimit以确保数组部分的逻辑边界是最优的。</li></ul><h2id="为什么不再存储数组的实际大小物理大小">为什么不再存储数组的实际大小（物理大小）？</h2><p>首先通过 alimit可以非常迅速地计算出实际大小，两者同时存储有些浪费。alimit对于判断索引范围帮助更大，因此没有存储实际大小。</p><p>通过 alimit 算实际大小，本质上是算一个大于 alimit的最小2的幂。如果一个 table 频繁地rehash，这部分也存在一定的计算开销，Lua 考虑到了这个问题，让我们看看通过alimit 计算实际大小的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** True if value of &#x27;alimit&#x27; is equal to the real size of the array</span></span><br><span class="line"><span class="comment">** part of table &#x27;t&#x27;. (Otherwise, the array part must be larger than</span></span><br><span class="line"><span class="comment">** &#x27;alimit&#x27;.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> limitequalsasize(t)(isrealasize(t) || ispow2((t)-&gt;alimit))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Returns the real size of the &#x27;array&#x27; array</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LUAI_FUNC <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">luaH_realasize</span> <span class="params">(<span class="type">const</span> Table *t)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (limitequalsasize(t))</span><br><span class="line">    <span class="keyword">return</span> t-&gt;alimit;  <span class="comment">/* this is the size */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size = t-&gt;alimit;</span><br><span class="line">    <span class="comment">/* compute the smallest power of 2 not smaller than &#x27;n&#x27; */</span></span><br><span class="line">    size |= (size &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    size |= (size &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    size |= (size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    size |= (size &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    size |= (size &gt;&gt; <span class="number">16</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (UINT_MAX &gt;&gt; 30) &gt; 3</span></span><br><span class="line">    size |= (size &gt;&gt; <span class="number">32</span>);  <span class="comment">/* unsigned int has more than 32 bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    size++;</span><br><span class="line">    lua_assert(ispow2(size) &amp;&amp; size/<span class="number">2</span> &lt; t-&gt;alimit &amp;&amp; t-&gt;alimit &lt; size);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lua 对此做出的优化是，先判断当前 table 的 alimit是否和实际大小一致，不一致再计算。它的核心是 isrealasize方法，由此我们引申出下面的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** About &#x27;alimit&#x27;: if &#x27;isrealasize(t)&#x27; is true, then &#x27;alimit&#x27; is the</span></span><br><span class="line"><span class="comment">** real size of &#x27;array&#x27;. Otherwise, the real size of &#x27;array&#x27; is the</span></span><br><span class="line"><span class="comment">** smallest power of two not smaller than &#x27;alimit&#x27; (or zero iff &#x27;alimit&#x27;</span></span><br><span class="line"><span class="comment">** is zero); &#x27;alimit&#x27; is then used as a hint for #t.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITRAS(1 &lt;&lt; 7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> isrealasize(t)(!((t)-&gt;flags &amp; BITRAS))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> setrealasize(t)((t)-&gt;flags &amp;= cast_byte(~BITRAS))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> setnorealasize(t)((t)-&gt;flags |= BITRAS)</span></span><br></pre></td></tr></table></figure><p>结合上面的代码和它们的调用，这里 Lua 实际上是把结果记录在了<code>flags</code> 域中, 在第 8 位（bit 7）如果标记为 1，那么代表该表的alimit 不等于数组的实际大小。这里会产生一个疑问，flags本来是用于标记元方法是否有效，在第 8位存储，不会影响元方法的判断吗？（TM_SUB 是元方法掩码 7）</p><p>这里其实在设计上已经被切开了，当前表如果是元表，那么它的 flags域会被用于元方法标记，而不会有 BITRAS 的判断。如果当前表不是元表，那么flags 会用于标记 BITRAS</p><h1 id="哈希表的结构">哈希表的结构</h1><p><img src="LuaTable.drawio.png" alt="Table的数据结构" /><br /></p><p>上图可以看出，array 域指向一个数组部分的起始位置。node域指向一个哈希表的起始位置， lastfree 则是指向哈希表最后的位置。</p><p>这里我们需要关注下哈希表的节点，它的类型是<code>Node</code>，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Nodes for Hash tables: A pack of two TValue&#x27;s (key-value pairs)</span></span><br><span class="line"><span class="comment">** plus a &#x27;next&#x27; field to link colliding entries. The distribution</span></span><br><span class="line"><span class="comment">** of the key&#x27;s fields (&#x27;key_tt&#x27; and &#x27;key_val&#x27;) not forming a proper</span></span><br><span class="line"><span class="comment">** &#x27;TValue&#x27; allows for a smaller size for &#x27;Node&#x27; both in 4-byte</span></span><br><span class="line"><span class="comment">** and 8-byte alignments.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">NodeKey</span> &#123;</span></span><br><span class="line">    TValuefields;  <span class="comment">/* fields for value */</span></span><br><span class="line">    lu_byte key_tt;  <span class="comment">/* key type */</span></span><br><span class="line">    <span class="type">int</span> next;  <span class="comment">/* for chaining */</span></span><br><span class="line">    Value key_val;  <span class="comment">/* key value */</span></span><br><span class="line">  &#125; u;</span><br><span class="line">  TValue i_val;  <span class="comment">/* direct access to node&#x27;s value as a proper &#x27;TValue&#x27; */</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>Node 作为一个联合体，它头部的内存空间用于存储实际的值，这样可以通过i_val 域直接访问。当需要访问键和链表的内容时，结合后续的内存作为<code>NodeKey</code> 结构体访问。next 指向链表中的下一个节点，而 key_tt和 key_val 存储了键的类型和实际值</p><h1 id="表的创建和释放">表的创建和释放</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Table *<span class="title function_">luaH_new</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  GCObject *o = luaC_newobj(L, LUA_VTABLE, <span class="keyword">sizeof</span>(Table));</span><br><span class="line">  Table *t = gco2t(o);</span><br><span class="line">  t-&gt;metatable = <span class="literal">NULL</span>;</span><br><span class="line">  t-&gt;flags = cast_byte(maskflags);  <span class="comment">/* table has no metamethod fields */</span></span><br><span class="line">  t-&gt;<span class="built_in">array</span> = <span class="literal">NULL</span>;</span><br><span class="line">  t-&gt;alimit = <span class="number">0</span>;</span><br><span class="line">  setnodevector(L, t, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">luaH_free</span> <span class="params">(lua_State *L, Table *t)</span> &#123;</span><br><span class="line">  freehash(L, t);</span><br><span class="line">  luaM_freearray(L, t-&gt;<span class="built_in">array</span>, luaH_realasize(t));</span><br><span class="line">  luaM_free(L, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建和释放的逻辑很简单，创建时分配好内存空间，然后给初始化数组部分和哈希部分的指针。释放则是先释放掉哈希部分，然后是数组部分，最后释放掉整个表。</p><p>有一个点需要注意，设置哈希部分的逻辑是调用<code>setnodevector(L, t, 0)</code>，它的逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Creates an array for the hash part of a table with the given</span></span><br><span class="line"><span class="comment">** size, or reuses the dummy node if size is zero.</span></span><br><span class="line"><span class="comment">** The computation for size overflow is in two steps: the first</span></span><br><span class="line"><span class="comment">** comparison ensures that the shift in the second one does not</span></span><br><span class="line"><span class="comment">** overflow.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">setnodevector</span> <span class="params">(lua_State *L, Table *t, <span class="type">unsigned</span> <span class="type">int</span> size)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;  <span class="comment">/* no elements to hash part? */</span></span><br><span class="line">    t-&gt;node = cast(Node *, dummynode);  <span class="comment">/* use common &#x27;dummynode&#x27; */</span></span><br><span class="line">    t-&gt;lsizenode = <span class="number">0</span>;</span><br><span class="line">    t-&gt;lastfree = <span class="literal">NULL</span>;  <span class="comment">/* signal that it is using dummy node */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> lsize = luaO_ceillog2(size);</span><br><span class="line">    <span class="keyword">if</span> (lsize &gt; MAXHBITS || (<span class="number">1u</span> &lt;&lt; lsize) &gt; MAXHSIZE)</span><br><span class="line">      luaG_runerror(L, <span class="string">&quot;table overflow&quot;</span>);</span><br><span class="line">    size = twoto(lsize);</span><br><span class="line">    t-&gt;node = luaM_newvector(L, size, Node);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)size; i++) &#123;</span><br><span class="line">      Node *n = gnode(t, i);</span><br><span class="line">      gnext(n) = <span class="number">0</span>;</span><br><span class="line">      setnilkey(n);</span><br><span class="line">      setempty(gval(n));</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;lsizenode = cast_byte(lsize);</span><br><span class="line">    t-&gt;lastfree = gnode(t, size);  <span class="comment">/* all positions are free */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 Lua为了减少空表的维护，定义了一个不可改写的空哈希表：dummynode。空表被初始化时，node域直接指向这个全局节点。由于它是只读的，所以不会引起线程安全问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Lua 用 table 来表示一切数据结构，为了效率，Lua 将 table 的存储分为了
&lt;code&gt;数组&lt;/code&gt; 和 &lt;code&gt;哈希表&lt;/code&gt; 两个部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组部分提供了紧凑且高效的随机访问。它的索引从1开始，这是 Lua</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    <category term="源码阅读" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="04-表" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/"/>
    
    
    <category term="Lua" scheme="https://peiyuzou.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>3.2 字符串的相关实现</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/03-%E5%AD%97%E7%AC%A6%E4%B8%B2/3.2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/03-%E5%AD%97%E7%AC%A6%E4%B8%B2/3.2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-12-09T09:08:44.000Z</published>
    <updated>2024-12-09T09:35:20.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串比较">字符串比较</h1><p>短字符串的比较很简单，由于被内部化，只需要比较内存地址即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lstring.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** equality for short strings, which are always internalized</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eqshrstr(a,b)check_exp((a)-&gt;tt == LUA_VSHRSTR, (a) == (b))</span></span><br></pre></td></tr></table></figure><p>对于长字符串，首先比较长度，长度相同的情况下需要逐字节比较：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** equality for long strings</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">luaS_eqlngstr</span> <span class="params">(TString *a, TString *b)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> len = a-&gt;u.lnglen;</span><br><span class="line">  lua_assert(a-&gt;tt == LUA_VLNGSTR &amp;&amp; b-&gt;tt == LUA_VLNGSTR);</span><br><span class="line">  <span class="keyword">return</span> (a == b) ||  <span class="comment">/* same instance or... */</span></span><br><span class="line">    ((len == b-&gt;u.lnglen) &amp;&amp;  <span class="comment">/* equal length and ... */</span></span><br><span class="line">     (<span class="built_in">memcmp</span>(getstr(a), getstr(b), len) == <span class="number">0</span>));  <span class="comment">/* equal contents */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="短字符串的内部化">短字符串的内部化</h1><p>直接上内部化的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lstring.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Checks whether short string exists and reuses it or creates a new one.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> TString *<span class="title function_">internshrstr</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> l)</span> &#123;</span><br><span class="line">  TString *ts;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  stringtable *tb = &amp;g-&gt;strt;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> h = luaS_hash(str, l, g-&gt;seed);</span><br><span class="line">  TString **<span class="built_in">list</span> = &amp;tb-&gt;hash[lmod(h, tb-&gt;size)];</span><br><span class="line">  lua_assert(str != <span class="literal">NULL</span>);  <span class="comment">/* otherwise &#x27;memcmp&#x27;/&#x27;memcpy&#x27; are undefined */</span></span><br><span class="line">  <span class="keyword">for</span> (ts = *<span class="built_in">list</span>; ts != <span class="literal">NULL</span>; ts = ts-&gt;u.hnext) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == ts-&gt;shrlen &amp;&amp; (<span class="built_in">memcmp</span>(str, getstr(ts), l * <span class="keyword">sizeof</span>(<span class="type">char</span>)) == <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">/* found! */</span></span><br><span class="line">      <span class="keyword">if</span> (isdead(g, ts))  <span class="comment">/* dead (but not collected yet)? */</span></span><br><span class="line">        changewhite(ts);  <span class="comment">/* resurrect it */</span></span><br><span class="line">      <span class="keyword">return</span> ts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* else must create a new string */</span></span><br><span class="line">  <span class="keyword">if</span> (tb-&gt;nuse &gt;= tb-&gt;size) &#123;  <span class="comment">/* need to grow string table? */</span></span><br><span class="line">    growstrtab(L, tb);</span><br><span class="line">    <span class="built_in">list</span> = &amp;tb-&gt;hash[lmod(h, tb-&gt;size)];  <span class="comment">/* rehash with new size */</span></span><br><span class="line">  &#125;</span><br><span class="line">  ts = createstrobj(L, l, LUA_VSHRSTR, h);</span><br><span class="line">  <span class="built_in">memcpy</span>(getstr(ts), str, l * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">  ts-&gt;shrlen = cast_byte(l);</span><br><span class="line">  ts-&gt;u.hnext = *<span class="built_in">list</span>;</span><br><span class="line">  *<span class="built_in">list</span> = ts;</span><br><span class="line">  tb-&gt;nuse++;</span><br><span class="line">  <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们详细分析下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">global_State *g = G(L);</span><br><span class="line">stringtable *tb = &amp;g-&gt;strt;</span><br></pre></td></tr></table></figure><p>这里认证了短字符串存放在全局字符串表这个说法，<code>strt</code> 就是<code>string table</code> 的简写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> h = luaS_hash(str, l, g-&gt;seed);</span><br><span class="line">TString **<span class="built_in">list</span> = &amp;tb-&gt;hash[lmod(h, tb-&gt;size)];</span><br></pre></td></tr></table></figure><p><code>luaS_hash</code>在上节的Lua为应对DoS攻击做出的修改中有提到，这个函数用于计算字符串的哈希值。然后和经典的链式寻址哈希表的实现一致，lua也用形如<code>index = hash(key) % capacity</code>的逻辑计算得到哈希桶的下标。所以这里得到的 <code>list</code>就是当前字符串存储的桶（链表）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ts = *<span class="built_in">list</span>; ts != <span class="literal">NULL</span>; ts = ts-&gt;u.hnext) &#123;</span><br><span class="line">  <span class="keyword">if</span> (l == ts-&gt;shrlen &amp;&amp; (<span class="built_in">memcmp</span>(str, getstr(ts), l * <span class="keyword">sizeof</span>(<span class="type">char</span>)) == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/* found! */</span></span><br><span class="line">    <span class="keyword">if</span> (isdead(g, ts))  <span class="comment">/* dead (but not collected yet)? */</span></span><br><span class="line">      changewhite(ts);  <span class="comment">/* resurrect it */</span></span><br><span class="line">    <span class="keyword">return</span> ts;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这部分就是在桶中查是否有已经存过的相同字符串，（这也是内部化的核心，合并相同内容的字符串）如果有，那么就直接返回它，不用再创建。值得注意的是这里的<code>isdead</code> 和 <code>changewhite</code>的处理，原文对这里有清楚地解释：</p><blockquote><p>这里需要检查表中的字符串是否是死掉的字符串。这是因为Lua的垃圾收集过程是分步完成的。而向字符串池添加新字符串在任何步骤之间都可能发生。有可能在标记完字符串后发现有些字符串没有任何引用，但在下个步骤中又产生了相同的字符串导致这个字符串复活</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tb-&gt;nuse &gt;= tb-&gt;size) &#123;  <span class="comment">/* need to grow string table? */</span></span><br><span class="line">  growstrtab(L, tb);</span><br><span class="line">  <span class="built_in">list</span> = &amp;tb-&gt;hash[lmod(h, tb-&gt;size)];  <span class="comment">/* rehash with new size */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lstring.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">growstrtab</span> <span class="params">(lua_State *L, stringtable *tb)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (l_unlikely(tb-&gt;nuse == MAX_INT)) &#123;  <span class="comment">/* too many strings? */</span></span><br><span class="line">    luaC_fullgc(L, <span class="number">1</span>);  <span class="comment">/* try to free some... */</span></span><br><span class="line">    <span class="keyword">if</span> (tb-&gt;nuse == MAX_INT)  <span class="comment">/* still too many? */</span></span><br><span class="line">      luaM_error(L);  <span class="comment">/* cannot even create a message... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (tb-&gt;size &lt;= MAXSTRTB / <span class="number">2</span>)  <span class="comment">/* can grow string table? */</span></span><br><span class="line">    luaS_resize(L, tb-&gt;size * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Resize the string table. If allocation fails, keep the current size.</span></span><br><span class="line"><span class="comment">** (This can degrade performance, but any non-zero size should work</span></span><br><span class="line"><span class="comment">** correctly.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">luaS_resize</span> <span class="params">(lua_State *L, <span class="type">int</span> nsize)</span> &#123;</span><br><span class="line">  stringtable *tb = &amp;G(L)-&gt;strt;</span><br><span class="line">  <span class="type">int</span> osize = tb-&gt;size;</span><br><span class="line">  TString **newvect;</span><br><span class="line">  <span class="keyword">if</span> (nsize &lt; osize)  <span class="comment">/* shrinking table? */</span></span><br><span class="line">    tablerehash(tb-&gt;hash, osize, nsize);  <span class="comment">/* depopulate shrinking part */</span></span><br><span class="line">  newvect = luaM_reallocvector(L, tb-&gt;hash, osize, nsize, TString*);</span><br><span class="line">  <span class="keyword">if</span> (l_unlikely(newvect == <span class="literal">NULL</span>)) &#123;  <span class="comment">/* reallocation failed? */</span></span><br><span class="line">    <span class="keyword">if</span> (nsize &lt; osize)  <span class="comment">/* was it shrinking table? */</span></span><br><span class="line">      tablerehash(tb-&gt;hash, nsize, osize);  <span class="comment">/* restore to original size */</span></span><br><span class="line">    <span class="comment">/* leave table as it was */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* allocation succeeded */</span></span><br><span class="line">    tb-&gt;hash = newvect;</span><br><span class="line">    tb-&gt;size = nsize;</span><br><span class="line">    <span class="keyword">if</span> (nsize &gt; osize)</span><br><span class="line">      tablerehash(newvect, osize, nsize);  <span class="comment">/* rehash for new size */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是哈希表，自然离不开负载因子过大（哈希冲突严重）导致扩容这个话题，上面的代码也给出了Lua的方案，可以看出Lua的负载因子默认是1，即<code>size / capacity = 1</code> 时会触发扩容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ts = createstrobj(L, l, LUA_VSHRSTR, h);</span><br><span class="line"><span class="built_in">memcpy</span>(getstr(ts), str, l * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">ts-&gt;shrlen = cast_byte(l);</span><br><span class="line">ts-&gt;u.hnext = *<span class="built_in">list</span>;</span><br><span class="line">*<span class="built_in">list</span> = ts;</span><br><span class="line">tb-&gt;nuse++;</span><br><span class="line"><span class="keyword">return</span> ts;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** creates a new string object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> TString *<span class="title function_">createstrobj</span> <span class="params">(lua_State *L, <span class="type">size_t</span> l, <span class="type">int</span> tag, <span class="type">unsigned</span> <span class="type">int</span> h)</span> &#123;</span><br><span class="line">  TString *ts;</span><br><span class="line">  GCObject *o;</span><br><span class="line">  <span class="type">size_t</span> totalsize;  <span class="comment">/* total size of TString object */</span></span><br><span class="line">  totalsize = sizelstring(l);</span><br><span class="line">  o = luaC_newobj(L, tag, totalsize);</span><br><span class="line">  ts = gco2ts(o);</span><br><span class="line">  ts-&gt;hash = h;</span><br><span class="line">  ts-&gt;extra = <span class="number">0</span>;</span><br><span class="line">  getstr(ts)[l] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">/* ending 0 */</span></span><br><span class="line">  <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的这部分则是创建一个新的短字符串的逻辑，其核心是<code>createstrobj</code>函数，需要注意的是，为了兼容C接口，Lua会在字符串末尾加上一个<code>\0</code>，但这个结尾符并不计算在字符串长度内</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字符串比较&quot;&gt;字符串比较&lt;/h1&gt;
&lt;p&gt;短字符串的比较很简单，由于被内部化，只需要比较内存地址即可：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    <category term="源码阅读" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="03-字符串" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/03-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="Lua" scheme="https://peiyuzou.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>3.1 字符串的数据结构设计</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/03-%E5%AD%97%E7%AC%A6%E4%B8%B2/3.1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/03-%E5%AD%97%E7%AC%A6%E4%B8%B2/3.1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2024-12-09T05:47:03.000Z</published>
    <updated>2024-12-09T08:46:43.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本设计">基本设计</h1><ul><li>由任意的8位字符组合形成字符串</li><li>存储形式是带长度的内存块，也就是存内容的同时，也有额外空间保存长度</li><li>为了兼容C库函数，Lua的字符串也在其内容的末尾添加<code>\0</code>，标记字符串结束</li></ul><h1id="两种内部形式长字符串和短字符串">两种内部形式：长字符串和短字符串</h1><p>对于外部来说，字符串只有一种类型，归属于Lua的9种基本类型之一，源码定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lua.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** basic types</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNONE(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNIL0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TBOOLEAN1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TLIGHTUSERDATA2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNUMBER3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TSTRING4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTABLE5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TFUNCTION6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TUSERDATA7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTHREAD8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_NUMTYPES9</span></span><br></pre></td></tr></table></figure><p>其中-1代表无效类型，0~8是9种基本类型的标识（其中字符串是4），<code>LUA_NUMTYPES</code>是指基本类型的数量有9个</p><p>在字符串核心源码脚本 <code>lstring.c</code> 中，并没有用到<code>LUA_TSTRING</code>，而是使用 <code>LUA_VSHRSTR</code> 和<code>LUA_VLNGSTR</code>两个变种类型，以此来对长短字符串作区分以实现不同的内部处理，长短字符串的类型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lobject.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* add variant bits to a type */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> makevariant(t,v)((t) | ((v) &lt;&lt; 4))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Variant tags for strings */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_VSHRSTRmakevariant(LUA_TSTRING, 0)  <span class="comment">/* short strings */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_VLNGSTRmakevariant(LUA_TSTRING, 1)  <span class="comment">/* long strings */</span></span></span><br></pre></td></tr></table></figure><p><code>makevariant</code>仅对类型作左移4位的操作，由此让Lua内部支持对类型进行细分，比如<code>nil</code> 内部可以分为<code>nil</code>、<code>empty</code>、<code>abstkey</code>，<code>number</code>内部被分为浮点数和整型等。</p><h2id="长短字符如何界定存储方式有何差异">1.长短字符如何界定？存储方式有何差异？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// llimits.h</span><br><span class="line"></span><br><span class="line">// 注释翻译：短字符串（即内部化的字符串）的最大长度。</span><br><span class="line">//（不能小于元方法的保留字或标记，因为这些字符串必须内部化）</span><br><span class="line">/*</span><br><span class="line">** Maximum length for short strings, that is, strings that are</span><br><span class="line">** internalized. (Cannot be smaller than reserved words or tags for</span><br><span class="line">** metamethods, as these strings must be internalized;</span><br><span class="line">** #(&quot;function&quot;) = 8, #(&quot;__newindex&quot;) = 10.)</span><br><span class="line">*/</span><br><span class="line">#if !defined(LUAI_MAXSHORTLEN)</span><br><span class="line">#define LUAI_MAXSHORTLEN40</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意 <code>内部化</code> 的含义，内部化的意思是指，在同一个<code>Lua State</code>中，相同的字符串只会存在一份，合并相同的字符串可以大量减少内存占用，并且可以缩短比较时间，因为只需要比较内存地址是否相同即可，而不需要逐字节比较。Lua内部的保留字和标记也理所应当需要被内部化，其中最长的保留字是<code>__newindex</code> 长度是10个字符，因此<code>LUAI_MAXSHORTLEN</code> 不可以被设置小于10</p></blockquote><p>这个值可以由用户自行决定，但Lua给出的默认界定值是40，超过40的字符串被认为是长字符串。</p><p>存储方式的差异：</p><ul><li>短字符串存储在 <code>全局字符串哈希表</code> 中，即<code>global_State</code> 中的 <code>strt</code>字段，这个哈希表内部采用链地址法的方式，实现方式比较简单</li><li>长字符串则直接存储在字符串内部的字段中，在原文的Lua版本中，长字符串甚至不存储在<code>TString</code> 的内存块内，而是紧跟着存储在 <code>TString</code>的内存块后面</li></ul><h2 id="字符串类型的实现结构">2.字符串类型的实现结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lobject.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Header for a string value.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte extra;  <span class="comment">/* reserved words for short strings; &quot;has hash&quot; for longs */</span></span><br><span class="line">  lu_byte shrlen;  <span class="comment">/* length for short strings */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> hash;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> lnglen;  <span class="comment">/* length for long strings */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> *<span class="title">hnext</span>;</span>  <span class="comment">/* linked list for hash table */</span></span><br><span class="line">  &#125; u;</span><br><span class="line">  <span class="type">char</span> contents[<span class="number">1</span>];</span><br><span class="line">&#125; TString;</span><br></pre></td></tr></table></figure><h3 id="commonheader">2.1 CommonHeader</h3><p>我们先看第一个宏 <code>CommonHeader</code>，它的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Common Header for all collectable objects (in macro form, to be</span></span><br><span class="line"><span class="comment">** included in other objects)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CommonHeaderstruct GCObject *next; lu_byte tt; lu_byte marked</span></span><br></pre></td></tr></table></figure><p><code>CommonHeader</code>并不是字符串专属，Lua对一切需要被垃圾收集器管理的对象，均会插入这个宏。它会在垃圾回收的章节中细讲，这里不赘述。我们这里关注一个域：<code>tt</code></p><p>让我们回想上面的内容，字符串在基本类型中的定义是<code>LUA_TSTRING</code>，并且在内部还细分为了 <code>LUA_VSHRSTR</code>和 <code>LUA_VLNGSTR</code>，这里怎么又有一个 <code>TString</code>类型，到底哪个才是字符串类型？</p><p>要回答这个问题，就需要了解 <code>tt</code>的设计，Lua为了清楚地知道每一个对象的实际类型，需要对每一个参与垃圾收集的对象做类型标记（typetag，简写为tt），也就是花了一个域的空间来存储这个对象的类型，因此<code>tt</code> 也可以理解为 <code>类型的类型</code> 或者<code>类型的值</code>。</p><p>所以 <code>LUA_TSTRING</code> 、<code>LUA_VSHRSTR</code> 和<code>LUA_VLNGSTR</code>并不是字符串的类型定义，它们仅仅标记当前这个字符串的内部类型，真正定义一个字符串结构的是<code>TString</code></p><h3 id="extra">2.2 extra</h3><p>这个域的作用和注释解释的一样：</p><ul><li>对短字符串来说，它用来标记当前字符串是否是保留字，这会用于词法分析</li><li>对长字符串来说，它表示是否计算了hash，这用于惰性求哈希值<ul><li>惰性：在取Hash值时才判断是否已经计算，已经计算则返回计算好的结果，否则当场计算</li><li>从外部压入一个长字符串时，没有立刻计算其hash值，只是简单地复制一遍字符串内容，然后标记一下extra域，标记为没有hash。直到需要对字符串做键匹配时，才惰性计算hash值，加快之后的键比较过程</li></ul></li></ul><h3 id="shrlen">2.3 shrlen</h3><p>如果当前字符串是短字符串，存储短字符串的长度</p><h3 id="hash">2.4 hash</h3><p>当前字符串的哈希值，由于短字符串存储在</p><h3 id="lnglenhnext以及u的设计">2.5 lnglen、hnext以及u的设计</h3><p>首先我们看 <code>lnglen</code> 和 <code>hnext</code>的含义，再来看为何要结合两者形成 <code>u</code></p><p><code>lnglen</code> 存储长字符串的长度，区别于 <code>shrlen</code>只有一个 <code>lu_byte (unsigned char))</code> 的大小，它给了一个<code>size_t (unsigned int64)</code> 的大小给的很充足</p><p><code>hnext</code>则与长字符串无关，由于采用链表寻址，短字符串存储在全局字符哈希表中的单个哈希桶中，该指针指向哈希桶的下一个链表节点，也就是哈希冲突的下一个元素。这个指针的作用是在删除当前短字符串，或者全局哈希表触发了<code>rehash</code> 操作的时候，亦或是新建字符串触发 <code>内部化</code>查询的时候，帮助Lua内部更高效地处理哈希表</p><p><code>Union</code>是一种共用体，允许多个成员共用同一段内存，而不是分别占用内存。像<code>lnglen</code> 和 <code>hnext</code> 特别使用<code>Union</code>，因为它们的应用场景是互斥的，只可能有两者之一被使用，这样一来节省了字符串字段的内存占用。其实这里<code>lnglen</code> 和 <code>shrlen</code> 也是互斥的，但是这里明显使用<code>hnext</code>更优，毕竟指针最少占用4字节（64位操作系统就是64÷8=8个字节），将两个占用大的声明在一起更节省，这种细节设计也是比较精彩的</p><h3 id="contents">2.6 contents</h3><p>长字符串存储实际字符串内容的数组，从一个 <code>TString</code>类型的对象中取实际字符串内容的API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Get the actual string (array of bytes) from a &#x27;TString&#x27;.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> getstr(ts)  ((ts)-&gt;contents)</span></span><br></pre></td></tr></table></figure><h1 id="hash-dos">Hash DoS</h1><p>在Lua5.2.0及之前，字符串不管长短一律内部化后存放在字符串表中，当时字符串哈希值的计算代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">luaS_hash</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> l)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> h = cast(<span class="type">unsigned</span> <span class="type">int</span>, l);</span><br><span class="line">  <span class="type">size_t</span> step = (<span class="number">1</span>&gt;&gt;<span class="number">5</span>)+<span class="number">1</span>;</span><br><span class="line">  <span class="type">size_t</span> l1;</span><br><span class="line">  <span class="keyword">for</span> (l1=l; l1&gt;=step; l1-=step)</span><br><span class="line">    h = h ^ ((h&lt;&lt;<span class="number">5</span>)+(h&gt;&gt;<span class="number">2</span>)+cast(<span class="type">unsigned</span> <span class="type">char</span>, str[l1-l]));</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原文：Lua5.2.0发布不久，有人在邮件列表中提出，Lua的这个设计有可能对其给于Hash Dos攻击的机会。攻击者可以轻易构造出上千万拥有相同哈希值的不同字符串，以此数十倍的降低Lua从外部压入字符串进入内部字符串表的效率。当Lua用于大量依赖字符串处理的诸如HTTP服务的处理时，输入的字符串不可控制，很容易被人恶意利用</p></blockquote><p>从Lua5.2.1开始，为了解决这个问题做了如下改动：</p><ul><li>长字符串独立出来，不再通过内部化进入全局字符串表</li><li>使用一个随机种子用于哈希值的计算，使攻击者无法轻易构造出拥有相同哈希值的不同字符串</li></ul><p>这里我们看下5.4.4版本的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lstring.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">luaS_hash</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> l, <span class="type">unsigned</span> <span class="type">int</span> seed)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> h = seed ^ cast_uint(l);</span><br><span class="line">  <span class="keyword">for</span> (; l &gt; <span class="number">0</span>; l--)</span><br><span class="line">    h ^= ((h&lt;&lt;<span class="number">5</span>) + (h&gt;&gt;<span class="number">2</span>) + cast_byte(str[l - <span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个随机种子 <code>seed</code> 在默认情况下是在<code>Lua State</code>创建时放在全局表中的，它利用了构造状态机的内存地址随机性，以及用户可配置的一个随机量（默认是使用time函数获取时间构造种子）同时决定，如下是相关代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lstate.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Compute an initial seed with some level of randomness.</span></span><br><span class="line"><span class="comment">** Rely on Address Space Layout Randomization (if present) and</span></span><br><span class="line"><span class="comment">** current time.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> addbuff(b,p,e) \</span></span><br><span class="line"><span class="meta">  &#123; size_t t = cast_sizet(e); \</span></span><br><span class="line"><span class="meta">    memcpy(b + p, &amp;t, sizeof(t)); p += sizeof(t); &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">luai_makeseed</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  <span class="type">char</span> buff[<span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="type">size_t</span>)];</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> h = cast_uint(time(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  addbuff(buff, p, L);  <span class="comment">/* heap variable */</span></span><br><span class="line">  addbuff(buff, p, &amp;h);  <span class="comment">/* local variable */</span></span><br><span class="line">  addbuff(buff, p, &amp;lua_newstate);  <span class="comment">/* public function */</span></span><br><span class="line">  lua_assert(p == <span class="keyword">sizeof</span>(buff));</span><br><span class="line">  <span class="keyword">return</span> luaS_hash(buff, p, h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>种子的存放和使用，相关代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lstate.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建状态机时存放在全局状态机种 */</span></span><br><span class="line">LUA_API lua_State *<span class="title function_">lua_newstate</span> <span class="params">(lua_Alloc f, <span class="type">void</span> *ud)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  g-&gt;seed = luai_makeseed(L);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回或者构建短字符串 */</span></span><br><span class="line"><span class="type">static</span> TString *<span class="title function_">internshrstr</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> l)</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> h = luaS_hash(str, l, g-&gt;seed);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构建长字符串 */</span></span><br><span class="line">TString *<span class="title function_">luaS_createlngstrobj</span> <span class="params">(lua_State *L, <span class="type">size_t</span> l)</span> &#123;</span><br><span class="line">  TString *ts = createstrobj(L, l, LUA_VLNGSTR, G(L)-&gt;seed);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本设计&quot;&gt;基本设计&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;由任意的8位字符组合形成字符串&lt;/li&gt;
&lt;li&gt;存储形式是带长度的内存块，也就是存内容的同时，也有额外空间保存长度&lt;/li&gt;
&lt;li&gt;为了兼容C库函数，Lua的字符串也在其内容的末尾添加
&lt;code&gt;&#92;</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    <category term="源码阅读" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="03-字符串" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/03-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="Lua" scheme="https://peiyuzou.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>2.1 全局状态机及内存管理</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/02-%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E6%9C%BA%E5%8F%8A%E5%86%85%E5%AD%98/2.1-%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E6%9C%BA%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/02-%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E6%9C%BA%E5%8F%8A%E5%86%85%E5%AD%98/2.1-%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E6%9C%BA%E5%8F%8A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2024-12-05T09:05:55.000Z</published>
    <updated>2024-12-09T06:21:02.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lual_newstate">luaL_newstate</h1><p>从创建Lua虚拟机的函数 <code>luaL_newstate</code>入手，这个函数可能是外部最常见的函数之一，它无需参数，返回一个指向lua_State 类型内存地址的指针，在xLua中，它对应如下接口声明：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LuaDLL.cs</span></span><br><span class="line"></span><br><span class="line">[<span class="meta">DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> IntPtr <span class="title">luaL_newstate</span>()</span>;</span><br></pre></td></tr></table></figure><p><code>luaL_newstate</code>的源码片段如下，注意它的函数签名，和C#中声明动态链接库时的签名是一致的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* lauxlib.c */</span></span><br><span class="line"></span><br><span class="line">LUALIB_API lua_State *<span class="title function_">luaL_newstate</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  lua_State *L = lua_newstate(l_alloc, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">if</span> (l_likely(L)) &#123;</span><br><span class="line">    lua_atpanic(L, &amp;panic);</span><br><span class="line">    lua_setwarnf(L, warnfoff, L);  <span class="comment">/* default is warnings off */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析这段源码：</p><h2 id="lualib_api是什么">1、LUALIB_API是什么？</h2><p>跳转到定义，可以发现Lua对API的封装分为了以下三个等级：</p><ul><li>LUA_API：核心API</li><li>LUALIB_API：辅助库函数</li><li>LUAMOD_API：标准库开放函数</li></ul><p>但实际的定义，后两者都同LUA_API（More often than not the libs gotogether with the core. 很多时候，库与核心结合在一起。）</p><p>在编译为动态链接库（DLL）时，可以通过宏定义决定该标记的函数是从DLL中导出还是从其他DLL中导入，非DLL的情况下，表示该符号标记的函数是外部的（<code>extern</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* luaconf.h */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">@@ LUA_API is a mark for all core API functions.</span></span><br><span class="line"><span class="comment">@@ LUALIB_API is a mark for all auxiliary library functions.</span></span><br><span class="line"><span class="comment">@@ LUAMOD_API is a mark for all standard library opening functions.</span></span><br><span class="line"><span class="comment">** CHANGE them if you need to define those functions in some special way.</span></span><br><span class="line"><span class="comment">** For instance, if you want to create one Windows DLL with the core and</span></span><br><span class="line"><span class="comment">** the libraries, you may want to use the following definition (define</span></span><br><span class="line"><span class="comment">** LUA_BUILD_AS_DLL to get it).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(LUA_BUILD_AS_DLL)<span class="comment">/* &#123; */</span>    <span class="comment">// 编译为动态链接库</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(LUA_CORE) || defined(LUA_LIB)<span class="comment">/* &#123; */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_API __declspec(dllexport)      <span class="comment">// 从DLL中导出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span><span class="comment">/* &#125;&#123; */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_API __declspec(dllimport)      <span class="comment">// 从其他DLL中导入</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/* &#125; */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span><span class="comment">/* &#125;&#123; */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_APIextern                 <span class="comment">// 非DLL的情况，等效于extern</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">/* &#125; */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** More often than not the libs go together with the core.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUALIB_APILUA_API</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUAMOD_APILUA_API</span></span><br></pre></td></tr></table></figure><h2 id="从-lua_state-l-lua_newstatel_alloc-null-得到的信息">2、从<code>lua_State *L = lua_newstate(l_alloc, NULL);</code>得到的信息？</h2><p>lua_newstate是核心库提供的函数，提供给外部创建一个虚拟机的接口，也就是说<code>luaL_newstate</code> 本质上就是对 <code>lua_newstate</code>做了一次封装，提供了一个更加方便和常用的版本。lua_newstate在本文后面会单独作一次分析，这里不赘述。</p><p>此外，<code>lua_newstate</code>要求传入一个内存管理函数，这里使用的内部定义好的 <code>l_alloc</code>函数，同样下文具体分析，先跳过。</p><h2 id="l_likely-是何含义">3、<code>l_likely</code> 是何含义？</h2><p>跳到定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* luaconf.h */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** macros to improve jump prediction, used mostly for error handling</span></span><br><span class="line"><span class="comment">** and debug facilities. (Some macros in the Lua API use these macros.</span></span><br><span class="line"><span class="comment">** Define LUA_NOBUILTIN if you do not want &#x27;__builtin_expect&#x27; in your</span></span><br><span class="line"><span class="comment">** code.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(luai_likely)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__GNUC__) &amp;&amp; !defined(LUA_NOBUILTIN)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> luai_likely(x)(__builtin_expect(((x) != 0), 1))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> luai_unlikely(x)(__builtin_expect(((x) != 0), 0))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> luai_likely(x)(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> luai_unlikely(x)(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(LUA_CORE) || defined(LUA_LIB)</span></span><br><span class="line"><span class="comment">/* shorter names for Lua&#x27;s own use */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l_likely(x)luai_likely(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> l_unlikely(x)luai_unlikely(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在编译时，<code>l_likely</code>代表该条件分支的结果大概率为真，<code>l_unlikely</code>代表大概率为假，类似于断言，但又不一样，这俩的本质是<code>__builtin_expect</code>, 代表了一种逻辑期望。</p><p>使用它们的目的是帮助编译器进行分支预测优化，从而提高程序的执行效率。通过告知编译器哪些分支更可能被执行，或者哪些分支较少被执行，编译器可以更有效地安排指令的执行，减少因错误预测而导致的性能损失。</p><h2 id="lua_atpanic-和-lua_setwarnf">4、<code>lua_atpanic</code> 和<code>lua_setwarnf</code></h2><p><code>lua_atpanic</code> 对新的虚拟机注册一个函数，在 Lua遇到致命错误时（如内存分配失败或其他无法恢复的错误）调用这个函数</p><p><code>lua_setwarnf</code> 对新的虚拟机注册一个警告函数，当 Lua执行时产生警告时，这个回调函数就会被调用。</p><h1 id="内置的内存管理函数l_alloc">内置的内存管理函数（l_alloc）</h1><p>先来看函数签名：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lua.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> * (*lua_Alloc) (<span class="type">void</span> *ud, <span class="type">void</span> *ptr, <span class="type">size_t</span> osize, <span class="type">size_t</span> nsize);</span><br></pre></td></tr></table></figure><ul><li>ud：指 userdata，代表一些lua无法定义的外部结构或者类型</li><li>ptr：指向当前要更改的内存起始地址的指针</li><li>osize：指 old size，当前指针指向的内存块的原始大小</li><li>nsize：指 new size，当前指针指向的内存块的新大小</li></ul><p>相比C标准库中的内存分配函数，Lua的内存管理函数会额外给出osize（内存块的原始大小），这对定制一个高效的自定义内存管理函数来说非常重要，可以帮助我们更加精准地设计和节省内存。（C标准库的内存分配函数仅包含一个内存地址指针和需要分配的大小，要做到精准定制，一般需要在内存块的前面加了一个cookie，把内存块尺寸存放在里面）</p><p>ud是一个额外的指针，允许我们带入额外的处理逻辑。比如让内存管理模块工作在不同的堆上。恰当的定制内存管理器，就可以回避线程安全问题。不考虑线程安全的因素，我们可以让内存管理工作更为高效。</p><p>从Lua5.2开始，当 ptr 传入 NULL时，osize的含义是对象的类型，这样做让我们知道当前是在分配一个什么类型的对象，便于统计和优化</p><p>然后我们再来看看内置的内存管理函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lauxlib.c</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">l_alloc</span> <span class="params">(<span class="type">void</span> *ud, <span class="type">void</span> *ptr, <span class="type">size_t</span> osize, <span class="type">size_t</span> nsize)</span> &#123;</span><br><span class="line">  (<span class="type">void</span>)ud; (<span class="type">void</span>)osize;  <span class="comment">/* not used */</span></span><br><span class="line">  <span class="keyword">if</span> (nsize == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr); <span class="comment">// C标准库的内存释放函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">realloc</span>(ptr, nsize); <span class="comment">// C标准库的内存分配函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的逻辑比较简单，当nsize指定为0时，释放当前指针指向的内存。否则，分配一个nsize大小的内存块</p><h1 id="lua内存管理">Lua内存管理</h1><p>Lua使用了一组宏来管理不同类别的内存：单个对象、数组、可变长数组等。这组宏定义在lmem.h 中。</p><p>这组宏的核心是一个内部API：<code>luaM_realloc_</code></p><p>它的实现本质是调用 <code>global_State</code>中注册的内存分配器（也就是我们之前了解的l_alloc或者我们自己定义的内存管理函数），我们在创建一个新的虚拟机时，传入的内存管理函数其实就是注册给了全局状态机</p><blockquote><p>原文对这里的说明：这些工作不仅仅是分配新的内存，释放不用的内存，扩展不够用的内存。Lua也会通过<code>realloc</code>试图释放掉预申请过大的内存的后半部分，当然，这取决于用户提供的内存管理器能不能缩小内存块了</p></blockquote><p>还有一个需要注意的细节， <code>luaM_realloc_</code>并不能直接调用，Lua在这里围绕它定义了很多宏，应对不同类型和调用场景。这其实是一种优化思路，因为很多调用的传入参数都是常数，直接用宏定义，可以让常量计算在编译时就完成，节省运行时的计算和开销。（Lua有很多这样精致的设计思路，这也是它的源码被盛赞的原因之一）</p><p>以下是它的具体代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Generic allocation routine.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">luaM_realloc_</span> <span class="params">(lua_State *L, <span class="type">void</span> *block, <span class="type">size_t</span> osize, <span class="type">size_t</span> nsize)</span> &#123;</span><br><span class="line">  <span class="type">void</span> *newblock;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  lua_assert((osize == <span class="number">0</span>) == (block == <span class="literal">NULL</span>));</span><br><span class="line">  newblock = firsttry(g, block, osize, nsize);</span><br><span class="line">  <span class="keyword">if</span> (l_unlikely(newblock == <span class="literal">NULL</span> &amp;&amp; nsize &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">    newblock = tryagain(L, block, osize, nsize);</span><br><span class="line">    <span class="keyword">if</span> (newblock == <span class="literal">NULL</span>)  <span class="comment">/* still no memory? */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">/* do not update &#x27;GCdebt&#x27; */</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_assert((nsize == <span class="number">0</span>) == (newblock == <span class="literal">NULL</span>));</span><br><span class="line">  g-&gt;GCdebt = (g-&gt;GCdebt + nsize) - osize;</span><br><span class="line">  <span class="keyword">return</span> newblock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个代码逻辑可以分为三个部分：</p><p>第一部分是利用全局状态机分配一块新的内存<code>newblock</code>，这里要细看firsttry的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lmem.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> firsttry(g,block,os,ns)    ((*g-&gt;frealloc)(g-&gt;ud, block, os, ns))</span></span><br></pre></td></tr></table></figure><p>firsttry其实就是调用全局状态机frealloc指针指向的方法，这个就是创建虚拟机时传入的内存管理函数</p><p>第二部分是出现可能性很小的分配失败的情况，这里执行了<code>tryagain</code>，实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lmem.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** In case of allocation fail, this function will do an emergency</span></span><br><span class="line"><span class="comment">** collection to free some memory and then try the allocation again.</span></span><br><span class="line"><span class="comment">** The GC should not be called while state is not fully built, as the</span></span><br><span class="line"><span class="comment">** collector is not yet fully initialized. Also, it should not be called</span></span><br><span class="line"><span class="comment">** when &#x27;gcstopem&#x27; is true, because then the interpreter is in the</span></span><br><span class="line"><span class="comment">** middle of a collection step.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">tryagain</span> <span class="params">(lua_State *L, <span class="type">void</span> *block, <span class="type">size_t</span> osize, <span class="type">size_t</span> nsize)</span> &#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  <span class="keyword">if</span> (completestate(g) &amp;&amp; !g-&gt;gcstopem) &#123;</span><br><span class="line">    luaC_fullgc(L, <span class="number">1</span>);  <span class="comment">/* try to free some memory... */</span></span><br><span class="line">    <span class="keyword">return</span> (*g-&gt;frealloc)(g-&gt;ud, block, osize, nsize);  <span class="comment">/* try again */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">/* cannot free any memory without a full state */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释的解释：</p><ul><li>如果分配失败，此函数将执行紧急收集以释放一些内存，然后再次尝试分配。</li><li>在虚拟机未完全构建时不应调用GC，因为收集器尚未完全初始化。此外，当“gcstopem”为真时不应调用它，因为解释器正处于收集步骤的中间。</li></ul><p>总结就是在GC收集器完成时，会进行一次 FullGC，尝试释放掉一些内存，并再次分配</p><p>第三部分是将新分配的大小更新到<code>GCdebt</code>，这用于内部感知内存大小，在内存不够时会主动尝试GC操作</p><blockquote><p>原书中还提到了<code>luaM_growaux_</code>，这个API用于管理可变长数组，其策略是当数组空间不够时，扩大为原来的2倍。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lmem.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Minimum size for arrays during parsing, to avoid overhead of</span></span><br><span class="line"><span class="comment">** reallocating to size 1, then 2, and then 4. All these arrays</span></span><br><span class="line"><span class="comment">** will be reallocated to exact sizes or erased when parsing ends.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZEARRAY4</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">luaM_growaux_</span> <span class="params">(lua_State *L, <span class="type">void</span> *block, <span class="type">int</span> nelems, <span class="type">int</span> *psize,</span></span><br><span class="line"><span class="params">                     <span class="type">int</span> size_elems, <span class="type">int</span> limit, <span class="type">const</span> <span class="type">char</span> *what)</span> &#123;</span><br><span class="line">  <span class="type">void</span> *newblock;</span><br><span class="line">  <span class="type">int</span> size = *psize;</span><br><span class="line">  <span class="keyword">if</span> (nelems + <span class="number">1</span> &lt;= size)  <span class="comment">/* does one extra element still fit? */</span></span><br><span class="line">    <span class="keyword">return</span> block;  <span class="comment">/* nothing to be done */</span></span><br><span class="line">  <span class="keyword">if</span> (size &gt;= limit / <span class="number">2</span>) &#123;  <span class="comment">/* cannot double it? */</span></span><br><span class="line">    <span class="keyword">if</span> (l_unlikely(size &gt;= limit))  <span class="comment">/* cannot grow even a little? */</span></span><br><span class="line">      luaG_runerror(L, <span class="string">&quot;too many %s (limit is %d)&quot;</span>, what, limit);</span><br><span class="line">    size = limit;  <span class="comment">/* still have at least one free place */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    size *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; MINSIZEARRAY)</span><br><span class="line">      size = MINSIZEARRAY;  <span class="comment">/* minimum size */</span></span><br><span class="line">  &#125;</span><br><span class="line">  lua_assert(nelems + <span class="number">1</span> &lt;= size &amp;&amp; size &lt;= limit);</span><br><span class="line">  <span class="comment">/* &#x27;limit&#x27; ensures that multiplication will not overflow */</span></span><br><span class="line">  newblock = luaM_saferealloc_(L, block, cast_sizet(*psize) * size_elems,</span><br><span class="line">                                         cast_sizet(size) * size_elems);</span><br><span class="line">  *psize = size;  <span class="comment">/* update only when everything else is OK */</span></span><br><span class="line">  <span class="keyword">return</span> newblock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="全局状态机">全局状态机</h1><h2id="全局状态机作用创建虚拟机时如何被引用">1、全局状态机作用？创建虚拟机时如何被引用？</h2><p>对于Lua使用者而言，<code>global_State</code>即全局状态机，是不可见的，我们也不需要引用它，但是仍然需要了解它。</p><p>全局状态机的作用：</p><ul><li>有对主线程（创建新的虚拟机时分配的<code>lua_State</code>）的引用</li><li>有注册表管理所有全局数据，有全局字符串表</li><li>内存管理函数</li><li>GC需要的信息</li><li>一切工作内存</li></ul><p>通过 <code>lua_newstate</code>创建一个新的Lua虚拟机时，会申请一块内存存放一个LG类型的结构，其中保存了主线程和全局状态机，代码和示意图如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lstate.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** thread state + extra space</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LX</span> &#123;</span></span><br><span class="line">  lu_byte extra_[LUA_EXTRASPACE];</span><br><span class="line">  lua_State l;</span><br><span class="line">&#125; LX;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Main thread combines a thread state and the global state</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LG</span> &#123;</span></span><br><span class="line">  LX l;</span><br><span class="line">  global_State g;</span><br><span class="line">&#125; LG;</span><br></pre></td></tr></table></figure><p><img src="202412071401.png" alt="LG的结构" /><br /></p><p>释义：</p><ul><li>LG：包含主线程 <code>lua_State</code> 和全局状态机<code>global_State</code> 的结构体，取首字母组成了“LG”</li><li>LX：对主线程的一次封装，只是额外多了一块预定义大小的内存块。<ul><li>extra_：据源码注释解释，这个称为主线程的原始内存大小，访问速度非常快，如果需要不同大小，可以自行更改，但没有给出明确的使用，估计是可以根据用户需要去自定义用途。</li><li>lua_State：主线程</li></ul></li><li>global_State：全局状态机</li></ul><h2 id="原文中提到的内存布局的细节">2、原文中提到的内存布局的细节</h2><blockquote><p>这里，主线程必须定义在结构的前面，否则关闭虚拟机的时候（如下代码）就无法正确的释放内存。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*g-&gt;frealloc)(g-&gt;ud, fromstate(L), <span class="keyword">sizeof</span>(LG), <span class="number">0</span>);  <span class="comment">/* free main block */</span></span><br></pre></td></tr></table></figure><p>这里其实就是搞懂fromstate到底做了啥</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lstate.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fromstate(L)(cast(LX *, cast(lu_byte *, (L)) - offsetof(LX, l)))</span></span><br></pre></td></tr></table></figure><p>释义：</p><ul><li><code>cast(lu_byte *, (L))</code>：将 <code>L</code> 从<code>lua_State *</code> 类型转换为 <code>lu_byte *</code>类型的指针。也就是转为字节级指针，方便进行字节偏移</li><li><code>offsetof(LX, l)</code>：这部分的意思是取 <code>l</code>这个字段在 <code>LX</code> 这个结构体中的偏移量</li><li>第一步中的主线程的字节指针减去自身在 <code>LX</code>结构体中的偏移量，实际就是取存储自身的 <code>LX</code> 的内存地址</li><li>最后将类型转换为 <code>LX *</code>，得到一个指向 <code>LX</code>结构体的指针，即得到主线程外包装的 <code>LX</code></li></ul><p>回过头，原文所描述的内存布局顺序，确实会影响内存的释放。因为要从LG的内存起始位置释放，也就是LX定义在前才不会出错</p><h2 id="初步阅读-lua_newstate-的内容">3、初步阅读 Lua_newstate的内容</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lstate.c</span></span><br><span class="line"></span><br><span class="line">LUA_API lua_State *<span class="title function_">lua_newstate</span> <span class="params">(lua_Alloc f, <span class="type">void</span> *ud)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  lua_State *L;</span><br><span class="line">  global_State *g;</span><br><span class="line">  LG *l = cast(LG *, (*f)(ud, <span class="literal">NULL</span>, LUA_TTHREAD, <span class="keyword">sizeof</span>(LG)));</span><br><span class="line">  <span class="keyword">if</span> (l == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  L = &amp;l-&gt;l.l;</span><br><span class="line">  g = &amp;l-&gt;g;</span><br><span class="line">  L-&gt;tt = LUA_VTHREAD;</span><br><span class="line">  g-&gt;currentwhite = bitmask(WHITE0BIT);</span><br><span class="line">  L-&gt;marked = luaC_white(g);</span><br><span class="line">  preinit_thread(L, g);</span><br><span class="line">  g-&gt;allgc = obj2gco(L);  <span class="comment">/* by now, only object is the main thread */</span></span><br><span class="line">  L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  incnny(L);  <span class="comment">/* main thread is always non yieldable */</span></span><br><span class="line">  g-&gt;frealloc = f;</span><br><span class="line">  g-&gt;ud = ud;</span><br><span class="line">  g-&gt;warnf = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;ud_warn = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;mainthread = L;</span><br><span class="line">  g-&gt;seed = luai_makeseed(L);</span><br><span class="line">  g-&gt;gcstp = GCSTPGC;  <span class="comment">/* no GC while building state */</span></span><br><span class="line">  g-&gt;strt.size = g-&gt;strt.nuse = <span class="number">0</span>;</span><br><span class="line">  g-&gt;strt.hash = <span class="literal">NULL</span>;</span><br><span class="line">  setnilvalue(&amp;g-&gt;l_registry);</span><br><span class="line">  g-&gt;panic = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;gcstate = GCSpause;</span><br><span class="line">  g-&gt;gckind = KGC_INC;</span><br><span class="line">  g-&gt;gcstopem = <span class="number">0</span>;</span><br><span class="line">  g-&gt;gcemergency = <span class="number">0</span>;</span><br><span class="line">  g-&gt;finobj = g-&gt;tobefnz = g-&gt;fixedgc = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;firstold1 = g-&gt;survival = g-&gt;old1 = g-&gt;reallyold = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;finobjsur = g-&gt;finobjold1 = g-&gt;finobjrold = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;sweepgc = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;gray = g-&gt;grayagain = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;weak = g-&gt;ephemeron = g-&gt;allweak = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;twups = <span class="literal">NULL</span>;</span><br><span class="line">  g-&gt;totalbytes = <span class="keyword">sizeof</span>(LG);</span><br><span class="line">  g-&gt;GCdebt = <span class="number">0</span>;</span><br><span class="line">  g-&gt;lastatomic = <span class="number">0</span>;</span><br><span class="line">  setivalue(&amp;g-&gt;nilvalue, <span class="number">0</span>);  <span class="comment">/* to signal that state is not yet built */</span></span><br><span class="line">  setgcparam(g-&gt;gcpause, LUAI_GCPAUSE);</span><br><span class="line">  setgcparam(g-&gt;gcstepmul, LUAI_GCMUL);</span><br><span class="line">  g-&gt;gcstepsize = LUAI_GCSTEPSIZE;</span><br><span class="line">  setgcparam(g-&gt;genmajormul, LUAI_GENMAJORMUL);</span><br><span class="line">  g-&gt;genminormul = LUAI_GENMINORMUL;</span><br><span class="line">  <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; LUA_NUMTAGS; i++) g-&gt;mt[i] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">if</span> (luaD_rawrunprotected(L, f_luaopen, <span class="literal">NULL</span>) != LUA_OK) &#123;</span><br><span class="line">    <span class="comment">/* memory allocation error: free partial state */</span></span><br><span class="line">    close_state(L);</span><br><span class="line">    L = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** open parts of the state that may cause memory-allocation errors.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f_luaopen</span> <span class="params">(lua_State *L, <span class="type">void</span> *ud)</span> &#123;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  UNUSED(ud);</span><br><span class="line">  stack_init(L, L);  <span class="comment">/* init stack */</span>  <span class="comment">//初始化主线程的数据栈</span></span><br><span class="line">  init_registry(L, g); <span class="comment">//初始化注册表</span></span><br><span class="line">  luaS_init(L); <span class="comment">//初始化字符串池</span></span><br><span class="line">  luaT_init(L); <span class="comment">//初始化元表用的字符串</span></span><br><span class="line">  luaX_init(L); <span class="comment">//初始化词法分析用的token串</span></span><br><span class="line">  g-&gt;gcstp = <span class="number">0</span>;  <span class="comment">/* allow gc */</span></span><br><span class="line">  setnilvalue(&amp;g-&gt;nilvalue);  <span class="comment">/* now state is complete */</span></span><br><span class="line">  luai_userstateopen(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我使用的Lua5.4.4版本作为参考，和原文中的有些不一致，但总体实现大差不差</p><p>函数实现中包含了诸如GC、字符串、内存管理等等相关的逻辑，在之后的章节会仔细分析。</p><p>这里我们着重看下最后一个条件分支的逻辑：如果Lua调用<code>f_luaopen</code>检查我们虚拟机的主线程，如果未通过检查，则会释放掉它。另外一个点是，虚拟机初始化的过程分两步：第一步是<code>f_luaopen</code>之前的逻辑，这一堆逻辑没有额外分配内存。真正会引起内存分配的初始化逻辑其实在<code>f_luaopen</code> 中。第二步则是执行 <code>f_luaopen</code>来初始化虚拟机</p><p>结合以上两点，其实可以看出Lua对创建虚拟机的处理非常小心。内存管理函数可能是外部传入的，也就有可能引起错误的内存分配。这里的思路是先初始化不需要额外内存分配的部分，把异常处理机制先建立起来。然后去调用可能引起内存分配失败的初始化代码，这里的容错机制设计是很精妙的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lual_newstate&quot;&gt;luaL_newstate&lt;/h1&gt;
&lt;p&gt;从创建Lua虚拟机的函数 &lt;code&gt;luaL_newstate&lt;/code&gt;
入手，这个函数可能是外部最常见的函数之一，它无需参数，返回一个指向
lua_State 类型内存地址的指</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    <category term="源码阅读" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="02-全局状态机及内存" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/02-%E5%85%A8%E5%B1%80%E7%8A%B6%E6%80%81%E6%9C%BA%E5%8F%8A%E5%86%85%E5%AD%98/"/>
    
    
    <category term="Lua" scheme="https://peiyuzou.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>1.1 概览</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/01-%E6%A6%82%E8%A7%88/1.1-%E6%A6%82%E8%A7%88/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/01-%E6%A6%82%E8%A7%88/1.1-%E6%A6%82%E8%A7%88/</id>
    <published>2024-12-05T09:02:48.000Z</published>
    <updated>2024-12-09T06:21:05.603Z</updated>
    
    <content type="html"><![CDATA[<p>参考：云风的《Lua源码欣赏》</p><p>他在书中将源码分为四个部分：</p><ul><li>核心</li><li>代码翻译及预编译字节码</li><li>内嵌库</li><li>独立解析器及字节码编译器</li></ul><p>并提供了一个建议阅读顺序（来自LuaJIT的作者Mike Pall）：</p><ul><li>阅读外围的库是如何实现功能扩展的</li><li>阅读 API 的具体实现</li><li>了解 Lua VM 的实现</li><li>分别理解函数调用、返回，string 、table 、metatable 等如何实现</li><li>debug 模块</li><li>parser 等等编译相关的部分</li><li>垃圾收集</li></ul><p>与原文中的5.2版本不同，本文是基于Lua5.4.4版本，结合了个人理解写成，仅供参考</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考：云风的《Lua源码欣赏》&lt;/p&gt;
&lt;p&gt;他在书中将源码分为四个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心&lt;/li&gt;
&lt;li&gt;代码翻译及预编译字节码&lt;/li&gt;
&lt;li&gt;内嵌库&lt;/li&gt;
&lt;li&gt;独立解析器及字节码编译器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并提供了一</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    <category term="源码阅读" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="01-概览" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/01-%E6%A6%82%E8%A7%88/"/>
    
    
    <category term="Lua" scheme="https://peiyuzou.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>01.总览</title>
    <link href="https://peiyuzou.github.io/wiki/03-%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E6%80%BB%E8%A7%88/"/>
    <id>https://peiyuzou.github.io/wiki/03-%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.%E6%80%BB%E8%A7%88/</id>
    <published>2024-08-06T11:33:10.000Z</published>
    <updated>2024-12-09T03:20:45.361Z</updated>
    
    <content type="html"><![CDATA[<p>这个章节的绝大部分内容来自对Robert Nystrom的《Game ProgrammingPatterns》一书的个人提炼。</p><p>和原书一致，将全部内容分为三个部分：</p><ul><li>第一个部分是对设计模式的客观评价、它并不是百利无害的。在游戏领域中，它对架构、性能会造成多种影响，这些影响有正面的也有负面的</li><li>第二个部分是对GoF合著的《设计模式：可复用面向对象软件要素》一书的经典设计模式的解读</li><li>第三个部分被分为四类，共十三种有用的设计模式（对游戏开发而言至少是有用）<ul><li>序列模式</li><li>行为模式</li><li>解耦模式</li><li>优化模式</li></ul></li></ul><blockquote><p>GoF：四人组的英文简写，《Design Patterns: Elements of ReusableObject-Oriented Software》（即后述《设计模式》一书），由 ErichGamma、Richard Helm、Ralph Johnson 和 John Vlissides合著（Addison-Wesley，1995）。这几位作者常被称为四人组（Gang ofFour）。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这个章节的绝大部分内容来自对Robert Nystrom的《Game Programming
Patterns》一书的个人提炼。&lt;/p&gt;
&lt;p&gt;和原书一致，将全部内容分为三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个部分是对设计模式的客观评价、它并不是百利无害的。在游</summary>
      
    
    
    
    <category term="03-开发设计" scheme="https://peiyuzou.github.io/categories/03-%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="游戏编程设计模式" scheme="https://peiyuzou.github.io/categories/03-%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="游戏编程设计模式" scheme="https://peiyuzou.github.io/tags/%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>List源码浅析</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/List%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/List%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90/</id>
    <published>2024-04-13T01:06:41.000Z</published>
    <updated>2024-12-09T03:20:45.130Z</updated>
    
    <content type="html"><![CDATA[<p>基础知识虽然枯燥但十分重要，反复打磨基础才能有新的启发。</p><p>List作为C#最常用的容器，有必要对它深入了解，最直接的就是读源码。下面是它的源码网址：</p><blockquote><p>https://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs</p></blockquote><p>本篇是记录个人对它的一些常用方法源码的理解剖析</p><h2 id="继承构造基础成员字段">继承、构造、基础成员字段</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt; : <span class="title">IList</span>&lt;<span class="title">T</span>&gt;, <span class="title">System.Collections.IList</span>, <span class="title">IReadOnlyList</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="built_in">int</span> _defaultCapacity = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T[] _items;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _size;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> _version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">readonly</span> T[]  _emptyArray = <span class="keyword">new</span> T[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructs a List. The list is initially empty and has a capacity</span></span><br><span class="line">    <span class="comment">// of zero. Upon adding the first element to the list the capacity is</span></span><br><span class="line">    <span class="comment">// increased to 16, and then increased in multiples of two as required.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List</span>()</span> &#123;</span><br><span class="line">        _items = _emptyArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructs a List with a given initial capacity. The list is</span></span><br><span class="line">    <span class="comment">// initially empty, but will have room for the given number of elements</span></span><br><span class="line">    <span class="comment">// before any reallocations are required.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">List</span>(<span class="params"><span class="built_in">int</span> capacity</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>)</span><br><span class="line">            ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);</span><br><span class="line">        Contract.EndContractBlock();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (capacity == <span class="number">0</span>)</span><br><span class="line">            _items = _emptyArray;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            _items = <span class="keyword">new</span> T[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承接口">继承接口</h3><p>继承IList，提供主要接口：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CONTRACTS_FULL</span></span><br><span class="line">    [<span class="meta">ContractClass(typeof(IListContract&lt;&gt;))</span>]</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> // CONTRACTS_FULL</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IList</span>&lt;<span class="title">T</span>&gt; : <span class="title">ICollection</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The Item property provides methods to read and edit entries in the List.</span></span><br><span class="line">        T <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123;</span><br><span class="line">            <span class="keyword">get</span>;</span><br><span class="line">            <span class="keyword">set</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Returns the index of a particular item, if it is in the list.</span></span><br><span class="line">        <span class="comment">// Returns -1 if the item isn&#x27;t in the list.</span></span><br><span class="line">        <span class="function"><span class="built_in">int</span> <span class="title">IndexOf</span>(<span class="params">T item</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Inserts value into the list at position index.</span></span><br><span class="line">        <span class="comment">// index must be non-negative and less than or equal to the</span></span><br><span class="line">        <span class="comment">// number of elements in the list.  If index equals the number</span></span><br><span class="line">        <span class="comment">// of items in the list, then value is appended to the end.</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Insert</span>(<span class="params"><span class="built_in">int</span> index, T item</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Removes the item at position index.</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">RemoveAt</span>(<span class="params"><span class="built_in">int</span> index</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONTRACTS_FULL</span></span><br><span class="line">    [<span class="meta">ContractClassFor(typeof(IList&lt;&gt;))</span>]</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">IListContract</span>&lt;<span class="title">T</span>&gt; : <span class="title">IList</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        T IList&lt;T&gt;.<span class="keyword">this</span>[<span class="built_in">int</span> index] &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123;</span><br><span class="line">                <span class="comment">//Contract.Requires(index &gt;= 0);</span></span><br><span class="line">                <span class="comment">//Contract.Requires(index &lt; ((ICollection&lt;T&gt;)this).Count);</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">default</span>(T);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123;</span><br><span class="line">                <span class="comment">//Contract.Requires(index &gt;= 0);</span></span><br><span class="line">                <span class="comment">//Contract.Requires(index &lt; ((ICollection&lt;T&gt;)this).Count);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IEnumerator System.Collections.IEnumerable.GetEnumerator()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">default</span>(IEnumerator);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">IEnumerator</span>&lt;<span class="title">T</span>&gt; <span class="title">IEnumerable</span>&lt;<span class="title">T</span>&gt;.<span class="title">GetEnumerator</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">default</span>(IEnumerator&lt;T&gt;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="meta">Pure</span>]</span><br><span class="line">        <span class="function"><span class="built_in">int</span> <span class="title">IList</span>&lt;<span class="title">T</span>&gt;.<span class="title">IndexOf</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Contract.Ensures(Contract.Result&lt;<span class="built_in">int</span>&gt;() &gt;= <span class="number">-1</span>);</span><br><span class="line">            Contract.Ensures(Contract.Result&lt;<span class="built_in">int</span>&gt;() &lt; ((ICollection&lt;T&gt;)<span class="keyword">this</span>).Count);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">default</span>(<span class="built_in">int</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> IList&lt;T&gt;.Insert(<span class="built_in">int</span> index, T <span class="keyword">value</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Contract.Requires(index &gt;= 0);</span></span><br><span class="line">            <span class="comment">//Contract.Requires(index &lt;= ((ICollection&lt;T&gt;)this).Count);  // For inserting immediately after the end.</span></span><br><span class="line">            <span class="comment">//Contract.Ensures(((ICollection&lt;T&gt;)this).Count == Contract.OldValue(((ICollection&lt;T&gt;)this).Count) + 1);  // Not threadsafe</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> IList&lt;T&gt;.RemoveAt(<span class="built_in">int</span> index)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Contract.Requires(index &gt;= 0);</span></span><br><span class="line">            <span class="comment">//Contract.Requires(index &lt; ((ICollection&lt;T&gt;)this).Count);</span></span><br><span class="line">            <span class="comment">//Contract.Ensures(((ICollection&lt;T&gt;)this).Count == Contract.OldValue(((ICollection&lt;T&gt;)this).Count) - 1);  // Not threadsafe</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">region</span> ICollection&lt;T&gt; Members</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> ICollection&lt;T&gt;.Add(T <span class="keyword">value</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Contract.Ensures(((ICollection&lt;T&gt;)this).Count == Contract.OldValue(((ICollection&lt;T&gt;)this).Count) + 1);  // Not threadsafe</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> ICollection&lt;T&gt;.IsReadOnly &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="literal">default</span>(<span class="built_in">bool</span>); &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> ICollection&lt;T&gt;.Count &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">default</span>(<span class="built_in">int</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> ICollection&lt;T&gt;.Clear()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// For fixed-sized collections like arrays, Clear will not change the Count property.</span></span><br><span class="line">            <span class="comment">// But we can&#x27;t express that in a contract because we have no IsFixedSize property on</span></span><br><span class="line">            <span class="comment">// our generic collection interfaces.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> ICollection&lt;T&gt;.Contains(T <span class="keyword">value</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">default</span>(<span class="built_in">bool</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> ICollection&lt;T&gt;.CopyTo(T[] array, <span class="built_in">int</span> startIndex)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Contract.Requires(array != null);</span></span><br><span class="line">            <span class="comment">//Contract.Requires(startIndex &gt;= 0);</span></span><br><span class="line">            <span class="comment">//Contract.Requires(startIndex + ((ICollection&lt;T&gt;)this).Count &lt;= array.Length);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bool</span> ICollection&lt;T&gt;.Remove(T <span class="keyword">value</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// No information if removal fails.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">default</span>(<span class="built_in">bool</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">#<span class="keyword">endregion</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> // CONTRACTS_FULL</span></span><br></pre></td></tr></table></figure><p>继承IReadOnlyList，则是提供泛型迭代器和Count属性等接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CONTRACTS_FULL</span></span><br><span class="line">    [<span class="meta">ContractClass(typeof(IReadOnlyListContract&lt;&gt;))</span>]</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">// If we ever implement more interfaces on IReadOnlyList, we should also update RuntimeTypeCache.PopulateInterfaces() in rttype.cs</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IReadOnlyList</span>&lt;<span class="keyword">out</span> <span class="title">T</span>&gt; : <span class="title">IReadOnlyCollection</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        T <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONTRACTS_FULL</span></span><br><span class="line">    [<span class="meta">ContractClassFor(typeof(IReadOnlyList&lt;&gt;))</span>]</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">IReadOnlyListContract</span>&lt;<span class="title">T</span>&gt; : <span class="title">IReadOnlyList</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        T IReadOnlyList&lt;T&gt;.<span class="keyword">this</span>[<span class="built_in">int</span> index] &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123;</span><br><span class="line">                <span class="comment">//Contract.Requires(index &gt;= 0);</span></span><br><span class="line">                <span class="comment">//Contract.Requires(index &lt; ((ICollection&lt;T&gt;)this).Count);</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">default</span>(T);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> IReadOnlyCollection&lt;T&gt;.Count &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">default</span>(<span class="built_in">int</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">default</span>(IEnumerator&lt;T&gt;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        IEnumerator IEnumerable.GetEnumerator()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">default</span>(IEnumerator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="构造函数">构造函数</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constructs a List. The list is initially empty and has a capacity</span></span><br><span class="line"><span class="comment">// of zero. Upon adding the first element to the list the capacity is</span></span><br><span class="line"><span class="comment">// increased to 16, and then increased in multiples of two as required.</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">List</span>()</span> &#123;</span><br><span class="line">    _items = _emptyArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constructs a List with a given initial capacity. The list is</span></span><br><span class="line"><span class="comment">// initially empty, but will have room for the given number of elements</span></span><br><span class="line"><span class="comment">// before any reallocations are required.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">List</span>(<span class="params"><span class="built_in">int</span> capacity</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.capacity, ExceptionResource.ArgumentOutOfRange_NeedNonNegNum);</span><br><span class="line">    Contract.EndContractBlock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (capacity == <span class="number">0</span>)</span><br><span class="line">        _items = _emptyArray;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _items = <span class="keyword">new</span> T[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造函数得出，List内部也是由数组实现，并且支持在一开始就指定容量；无参构造函数的注释中，说明了数组一开始容量是0，一旦添加了一个元素，容量会增长至16，这个说法其实不对，真实是增长到4，也就是默认的容量（_defaultCapacity），后面关于Add的内容会看到算法和测试的结果；容量每次扩大都是上一次的两倍（也就是容量4再增长即是8，再扩容就是16，以此类推）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基础知识虽然枯燥但十分重要，反复打磨基础才能有新的启发。&lt;/p&gt;
&lt;p&gt;List作为C#最常用的容器，有必要对它深入了解，最直接的就是读源码。下面是它的源码网址：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;https://referencesource.microsof</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="CSharp" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/"/>
    
    
    <category term="C#" scheme="https://peiyuzou.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>组件使用</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/0.1%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/0.1%E7%BB%84%E4%BB%B6%E4%BD%BF%E7%94%A8/</id>
    <published>2023-07-09T07:23:32.000Z</published>
    <updated>2024-12-09T03:20:47.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一主模块">一、主模块</h2><p><img src="2023-07-09T152604.png" alt="2023-07-09T152604" /><br /></p><ul><li>Duration：不勾循环的情况下，粒子发射器的发射持续时间，单位秒</li><li>Looping：是否循环发射粒子</li><li>Prewarm：开启该选项的粒子系统在场景中实例化或者由Deactive转为active时，会立即执行一次完整的模拟。以“火焰”为例，Prewarm开启时，加载后第一帧即能看到“大火”，而不是从“火苗”开始逐渐变大</li><li>StartDelay：粒子发射器初始化发射的延迟时间，单位秒，如果勾选了Prewarm，则该选项失效</li><li>StartLifetime：粒子本身的生命周期，单位秒，指一个粒子被发射后，经过多少时间消失</li><li>Start Speed：粒子开始时的初始速度</li><li>3D StartSize：勾选的话，则可以在xyz三个轴上调整粒子的尺寸，当然在布告板模式下，z轴的调节没有意义</li><li>Start Size：同步设置xyz轴的尺寸</li><li>3D Start Rotation：粒子可以绕着xyz三个设定不同的角度</li><li>Start Rotation：只设置ｚ轴方向旋转角度</li><li>Flip Rotation：反跳旋转，设置一个[0, 1]闭区间的值，假设StartRotation值为10，0代表旋转值不变即10，1代表方向完全取反即-10。0<sub>1中间的值代表权重，将以该权重从10</sub>10之间随机</li><li>Start Color：粒子初始颜色</li><li>Gravity Modifier：粒子施加一个向下的力，负值是向上的</li><li>Simulation Space：粒子的运动所使用的空间坐标<ul><li>Local：使用自身粒子系统的游戏物体的坐标</li><li>World：使用世界坐标，就是场景坐标</li><li>Custom：使用另一个物体的坐标。当这个物体坐标变化时，粒子也会跟着变化的，比如物体的位移会带动粒子位移</li></ul></li><li>SimulationSpeed：整体改变粒子的运动快慢，注意不只是粒子的速度。而是粒子总体属性，在空间位置中的变化，整体放慢或加快</li><li>Delta Time：粒子系统推进的方式<ul><li>Scaled：该粒子系统按照时间推进（不同刷新率的的设备有相同表现）</li><li>Unscaled：完全按照帧来推进</li></ul></li><li>Scaling Mode：缩放模式<ul><li>Hierarchy：根据其Transform及其所有父级进行缩放</li><li>Local：仅粒子系统自身节点应用缩放，忽略任何父级</li><li>Shape：将缩放应用于粒子起始位置，但不影响粒子大小</li></ul></li><li>Play on Awake：如果启用此属性，则粒子系统会在创建对象时自动启动</li><li>EmitterVelocity：选择粒子系统如何计算继承速度和发射模块使用的速度。系统可以使用Rigidbody 组件（如果存在）或通过跟踪 Transform组件的运动来计算速度。如果不存在 Rigidbody 组件，系统默认使用其Transform 组件</li><li>MaxParticles：系统中同时允许的最多粒子数。如果达到限制，则移除一些粒子</li><li>Auto RandomSeed：如果启用此属性，则每次播放时粒子系统看起来都会不同。设置为 false时，每次播放时系统都完全相同</li><li>Random Seed：禁用自动随机种子时，此值用于创建唯一的可重复效果</li><li>StopAction：当属于系统的所有粒子都已完成时，可使系统执行某种操作。当一个系统的所有粒子都已死亡，并且系统存活时间已超过Duration设定的值时，判定该系统已停止。对于循环系统，只有在通过脚本停止系统时才会发生这种情况<ul><li>None：什么都不做</li><li>Disable：禁用游戏对象</li><li>Destroy：销毁游戏对象。</li><li>Callback：将 OnParticleSystemStopped回调发送给附加到游戏对象的任何脚本</li></ul></li><li>Culling Mode：粒子在屏幕外时如何处理模拟<ul><li>Automatic：自动，Looping使用Pause，而所有其他使用AlwaysSimulate</li><li>Pause AndCatch-up：系统在屏幕外时停止模拟。当重新进入视图时，模拟会执行一大步以到达在不暂停的情况下可实现的程度。在复杂系统中，此选项可能会导致性能尖峰</li><li>Pause：系统在屏幕外时停止模拟</li><li>Always Simulate：无论是否在屏幕上，系统始终处理每个帧的模拟</li></ul></li><li>Ring Buffer Mode：保持粒子存活直到它们达到 Max Particles计数，此时新粒子会取代最早的粒子，而不是在它们的寿命终结时才删除粒子<ul><li>Disabled：禁用 Ring BufferMode，以便系统在粒子生命周期终结时删除粒子</li><li>Pause Until Replaced：在粒子生命周期结束时暂停旧粒子，直至达到 MaxParticle限制，此时系统会进行粒子再循环，因此旧粒子会重新显示为新粒子</li><li>Loop UntilReplaced：在粒子生命周期结束时，粒子将倒回到其生命周期的指定比例，直至达到Max Particle限制，此时系统会进行粒子再循环，因此旧粒子会重新显示为新粒子</li></ul></li></ul><h2 id="二emission发射器">二、Emission（发射器）</h2><p><img src="2023-07-09T181215.png" alt="2023-07-09T181215" /><br /></p><ul><li>Rate over Time（按时间频率发射）：每经过1秒发射的数量</li><li>Rate overDistance（按距离频率发射）：每移动1个单位距离发射的数量</li><li>Bursts（迸发）：从第几（Time）秒开始，发射多少个（Count），这次发射循环几次（Cycles），每次循环间隔多久（Interval）</li></ul><h2 id="三shape发射器形状">三、Shape（发射器形状）</h2><p><img src="2023-07-09T181604.png" alt="2023-07-09T181604" /><br /></p><ul><li>Shape：发射器的基本形状，默认是Cone（锥体）<ul><li>Sphere：球体</li><li>Hemisphere：半球体</li><li>Cone：锥体</li><li>Donut：甜甜圈</li><li>Box：正方体</li><li>Mesh：网格</li><li>Mesh Renderer：网格渲染</li><li>Skinned MeshRenderer：骨骼网格渲染（特效随骨骼运动发射时用这个）</li><li>Sprite：精灵</li><li>Sprite Renderer：精灵渲染</li><li>Circle：圆形</li><li>Edge：一条线</li><li>Rectangle：矩形</li></ul></li></ul><p>这里以默认的Cone为例：</p><ul><li>Angle：锥体角度</li><li>Radius：锥体半径</li><li>Radius Thickness：锥体体积，0~1的值</li><li>Arc：锥体发射的弧度范围<ul><li>Mode：锥体发射模式<ul><li>Random：整个锥体区域随机发射</li><li>Loop：正俯视视角下，调整锥体体积变成一个圆环，这样的视角下比较明显。Loop模式是一个在锥体底部的圆上的一个点，按照顺时针方向旋转并且发射</li><li>Ping Pong：和Loop一样，不过在点触碰X正轴时回弹</li><li>BurstSpread（迸发散布）：这个要联合Emission（发射器）折叠菜单中的Bursts（迸发）选项来看，此选项定义了迸发的形状。可以把RateOver Time指定为0，专心看迸发的形状<ul><li>Spread：散布值（0~1的值）。这个值是指将有效发射区域按照分为多少份。比如Arc指定弧度范围为360度，如果想平均分成5份，那么此值填0.2，最终效果迸发将均匀分为5份发射出来</li></ul></li></ul></li></ul></li><li>Emit from（发射来自）:<ul><li>Base：基础。只有一个底部发射粒子</li><li>Volume：体积。形成一个真正的圆锥体发射粒子</li></ul></li><li>Length：在Emit from指定Volume时，指定锥体的高度</li><li>Texture：设置一张图片在发射器上，根据这图片的颜色和透明区域，可影响粒子的颜色和透明度</li><li>Clip Channel：选择纹理中用于丢弃粒子的通道，要配合ClipThreshold使用</li><li>ClipThreshold：将粒子映射到纹理上的位置时，丢弃像素颜色低于此阈值的所有粒子</li><li>Color affects Particles：粒子颜色受纹理颜色影响</li><li>Alpha affects Particles：粒子Alpha受纹理Alpha影响</li><li>BilinearFiltering：在读取纹理时，进行双线性过滤插值（无论纹理尺寸如何，均组合4个相邻样本以获得更平滑的粒子颜色变化）</li></ul><p>类似这个效果 <img src="2023-07-09T202845.png"alt="2023-07-09T202845" /><br /><img src="2023-07-09T202908.png" alt="2023-07-09T202908" /><br /></p><ul><li>Position、Rotation、Scale：类似发射器的Transform</li><li>Align to Direction：让粒子朝向和发射方向对齐</li><li>Randomize Direction：粒子发射方向随机权重</li><li>Spherize Direction：将粒子方向朝球面方向混合</li><li>Randomize position：随机发射位置，这个值是一个允许的距离偏移</li></ul><h2 id="四velocity-over-lifetime生命周期内的速度">四、Velocity overLifetime（生命周期内的速度）</h2><p><img src="2023-07-09T205113.png" alt="2023-07-09T205113" /><br /></p><ul><li><p>Linear：给粒子一个线性的速率向量</p></li><li><p>Space：速率向量作用的空间坐标系</p></li><li><p>Orbital（轨道）：可以使粒子绕着某个轴自行旋转</p></li><li><p>Offset（偏移）：在Orbital旋转的过程中在施加一个轴方向的速度</p></li><li><p>Radial（半径）：绕轴旋转形成的螺旋线半径</p></li><li><p>Speed Modifier：增加粒子整体运动速度</p></li></ul><h2 id="五limit-velocity-over-lifetime生命周期内限制速度">五、LimitVelocity over Lifetime（生命周期内限制速度）</h2><p><img src="2023-07-09T205128.png" alt="2023-07-09T205128" /><br /></p><ul><li><p>Speed（速度）：限制后的速度。时间轴是duration时间。</p></li><li><p>Dampen（抑制）：抑制的含义是在粒子生命期间的速度由初始速度改为当前设置的速度，值越小抑制的越晚。值越大抑制的越早。值0是整个粒子生命时间内没有抑制。1是整个时间内完全抑制。抑制速度不会大于初始速度</p></li><li><p>Drag：指定在粒子的整个生命周期内施加给粒子的反方向拉拽速度的数量</p></li><li><p>Multiply bySize：拉拽速度的大小根据粒子大小关联，粒子越大拉拽力越大</p></li><li><p>Multiply byvelocity：拉拽速度的大小根据粒子速度关联，粒子速度越大拉拽力越大</p></li><li><p>Separate Axes：限制后的速度分别在xyz轴上定义</p></li></ul><h2 id="六inherit-velocity继承速率">六、InheritVelocity（继承速率）</h2><p><img src="2023-07-09T205859.png" alt="2023-07-09T205859" /><br /></p><p>继承速度的含义是粒子继承了粒子系统这个物体位移速度。前提是粒子使用的空间坐标是world才行</p><ul><li>Mode（模式）：提供了两种initial（初始）current（当前的）</li><li>Multiplier（乘值）：是速度要乘的数，速度是粒子系统在（世界）空间坐标中的速度，<ul><li>initial（初始）：计算粒子出生时的粒子系统速度。1就是原始速度，2，就是2倍速度。小数，速度会变慢。</li><li>current（当前的）：计算的是实时的粒子系统速度。粒子系统愈快，粒子的运行速度就越快。但值为1的时候，粒子移动速度和粒子系统速度一致，所以视觉上看不出粒子的位移，大于1或小于1时才有意义</li></ul></li></ul><h2 id="七force-over-lifetime生命周期内受到的力">七、Force overLifetime（生命周期内受到的力）</h2><p><img src="2023-07-09T210525.png" alt="2023-07-09T210525" /><br /></p><ul><li>X、Y、Z：在三个轴上施加的力</li><li>Space：选择是在局部空间还是在世界空间中施力</li><li>Randomize：使用 Two Constants 或 Two Curves模式时，此属性会导致在每个帧上在定义的范围内选择新的作用力方向。因此会产生更动荡、更不稳定的运动</li></ul><h2 id="八color-over-lifetime生命周期内使用的颜色值">八、Color overLifetime（生命周期内使用的颜色值）</h2><p><img src="2023-07-09T211022.png" alt="2023-07-09T211022" /><br /></p><p>这个就是调整颜色的</p><h2 id="九color-by-speed颜色受速度影响">九、Color bySpeed（颜色受速度影响）</h2><p><img src="2023-07-09T211353.png" alt="2023-07-09T211353" /><br /></p><ul><li>Speed Range（速度范围）：设定受到颜色影响最小速度和最大速度</li></ul><h2 id="十size-over-lifetime生命周期内的大小">十、Size OverLifetime（生命周期内的大小）</h2><p><img src="2023-07-09T211533.png" alt="2023-07-09T211533" /><br /></p><ul><li>Size：曲线指定粒子大小的变化</li></ul><h2 id="十一size-by-speed大小随速度变化">十一、Size bySpeed（大小随速度变化）</h2><p><img src="2023-07-09T212009.png" alt="2023-07-09T212009" /><br /></p><ul><li>Speed Range：指定曲线x轴的开始和结束速度</li></ul><h2 id="十二rotation-over-lifetime生命周期内的旋转">十二、Rotation overLifetime（生命周期内的旋转）</h2><p><img src="2023-07-09T212136.png" alt="2023-07-09T212136" /><br /></p><h2 id="十三rotation-by-speed旋转受到速度影响">十三、Rotation byspeed（旋转受到速度影响）</h2><p><img src="2023-07-09T212255.png" alt="2023-07-09T212255" /><br /></p><h2 id="十四external-forces受外部力影响">十四、ExternalForces（受外部力影响）</h2><p><img src="2023-07-09T212724.png" alt="2023-07-09T212724" /><br /></p><ul><li>Multiplier：受到的外力影响的倍率</li></ul><h2id="十五noise为粒子添加噪波影响">十五、Noise（为粒子添加噪波影响）</h2><p><img src="2023-07-09T212925.png" alt="2023-07-09T212925" /><br /></p><ul><li><p>Strength：噪波影响强度</p></li><li><p>Frequency：影响频率</p></li><li><p>Scroll Speed：噪声图滚动的速度</p></li><li><p>Damping（减震）：当噪波强度和频率都很大时效果明显，可以将强度与频率匹配，从而达到一个较稳定的噪声表现</p></li><li><p>Octaves：噪波叠加的层数</p></li><li><p>Octavesmultiplier（分层乘值）：就是和原始图的混合程度，0是没有混合，1是完全和原始图一致</p></li><li><p>Octavesscale（分层尺寸）：值1是和原始图一样大。值越越大细节越小</p></li><li><p>Quality（质量）：就是提供了1D的噪波、2D的噪波和3D选择的地方</p></li><li><p>Remap（重置图）：重新调节噪波图的黑白。类似于曲线的功能。可以从新定义粒子收到的影响</p></li><li><p>Position Amount：粒子受到的位移影响</p></li><li><p>rotation Amount：粒子受到的旋转影响</p></li><li><p>Size Amount：粒子受到的缩放影响</p></li></ul><h2 id="十六collision碰撞">十六、collision（碰撞）</h2><p><img src="2023-07-10T220009.png" alt="2023-07-10T220009" /><br /></p><ul><li>Type（类型）：提供了两种plan和world类型。World主要针对场景中有collider组件的物体（包含terrain）会产生碰撞。Plan是指定一个的物体的transform，作为一个面产生碰撞</li><li>Planes（面）：指定物体的transform为面。这个物体可以是场景中的也可以是资源中的。主要是用他的变换值。一版是和场景中的物体互动是有意义的，如果只是想得到一个碰撞可以使用空物体，会剩一点</li><li>Visualization（形象）：有Grid（网格）和Solid（固体）两种。只是便于查看的显示方式</li><li>ScalePlane（缩放片）:就是缩放Visualization这个片，还是为了便于观察</li><li>Dampen（抑制力）：碰撞后，粒子的速度被抑制多少，1是抑制到速度为0，粒子会停留在片上，0是没有抑制</li><li>Bounce（弹力）：碰撞后弹起的情况。1跟初始速度一样的速度反弹。0是不反弹，粒子会朝平面方向运动</li><li>LifetimeLoss（生命损耗）：碰撞后，粒子生命所短的数量。1是缩短到最大。碰撞后粒子生命结束。0是没有损耗</li><li>Min KillSpeed（速度小于值消灭粒子）：碰撞后的粒子速度小于这个值被摧毁</li><li>Max KillSpeed（速度大于值消灭粒子）：碰撞后的粒子速度大于这个值被摧毁</li><li>RadiusScale（半径的尺寸）：其实粒子的碰撞是和场景中其他碰撞是一个原理的，每个粒子都有一个圆的碰撞组件。计算碰撞就是计算这个组件和其他物体的碰撞的。这里调节半径尺寸是调的每个粒子碰撞大小</li><li>Send CollisionMessages（发送碰撞信息）：程序相关，程序会得到相关信息作出处理</li><li>Visualize Bounds（显示界限）：就是显示出碰撞框</li></ul><h2 id="十七triggers触发">十七、Triggers（触发）</h2><p><img src="2023-07-10T220039.png" alt="2023-07-10T220039" /><br /></p><p>设置了Inside（内部）Outside（外部）Enter（进入）Exit（出去）四种状态的Ignore（忽略）、kill（消灭）、callback（回调）三种情况。回调的含义是给程序返回一个内容。Colliders（碰撞的物体）：应该是个模型才有意义。真正起作用的是物体上面的collider组件。Radius Scale（半径的尺寸）和Visualize Bounds（显示界限）碰撞功能一样</p><h2 id="十八sub-emitters子发射器">十八、Sub Emitters（子发射器）</h2><p><img src="2023-07-10T220141.png" alt="2023-07-10T220141" /><br /></p><p>指定什么时候触发一个子粒子系统，这个子粒子系统会继承哪些属性，并且有多少概率触发</p><h2 id="十九texture-sheet-animation纹理片动画">十九、Texture SheetAnimation（纹理片动画）</h2><p><img src="2023-07-10T220246.png" alt="2023-07-10T220246" /><br /></p><p>分为两种模式：Grid和Sprites</p><ul><li>Tiles（平铺数）：一张图标被切割的数量。x是横轴的数量，y是纵轴数量。</li><li>Animation（动画）：有两种形式，<ul><li>WholeSheet（全部小片）：从左至右、从上至下播放整个图片里的小方框。</li><li>Single Row（单排）：只播一横排，因为可能会有很多排。当勾选了RandomRow（随机行）时，随机选中一行播放。不够时，有一个Row值供手选使用哪一行。</li></ul></li><li>Frame overTime（时间内的帧数）：通常设置曲线是有意义的，设置数值只会显示固定的一帧（并非是帧，而是第几个小图）。注意的是小图片的第一张的序号是0。</li><li>Start Frame（开始帧）：从第几帧开始播放，仍会完整读取序列。</li><li>Cycles（循环）：正常图片的整个循环是在粒子的生命时间内循环一次。这里可以改变循环几次</li></ul><h2 id="二十light光照">二十、Light（光照）</h2><p><img src="2023-07-10T220559.png" alt="2023-07-10T220559" /><br /></p><ul><li>Light（灯）：设置一盏灯，使粒子出生时同时有实时光照的效果，实质上就一个粒子一盏灯。Ratio（比率）：产生的粒子会有多大比例有灯照，0是一个也没有，1是全部粒子都有。</li><li>RandomDistribution（随机分布）：当Ratio不是1时，设置产生灯照的粒子的分布情况，随机就是随机分布，勾掉则会根据粒子情况每隔多少秒出现一个灯照。</li><li>Use Particle Color（使用粒子颜色）：灯照颜色使用粒子的颜色。</li><li>Size AffectRange（尺寸作用与范围）：粒子的尺寸会影响灯照的范围。</li><li>Alpha AffectIntensity（透明度作用于亮度）：粒子的透明度会影响灯照的亮度，调整粒子的生命颜色时就可以实现控制灯照的亮度了。</li><li>Range multiplier（范围乘值）：增大灯照的范围。</li><li>Intensity Multiplier（亮度乘值）：增大灯照的亮度。</li><li>MaximumLights（最大灯数）：因为是实时光照。灯的数量可能会根据粒子数量产生非常多，消耗会非常巨大。这里的值控制最多可以有多少个灯照被创建</li></ul><h2 id="二十一trails拖尾">二十一、Trails（拖尾）</h2><p><img src="2023-07-10T220717.png" alt="2023-07-10T220717" /><br /></p><ul><li>Particle（粒子）：使用这个模式使粒子产生一个拖尾。</li><li>Ratio（比例）：粒子会产生拖尾的比例。1是全部粒子都会有拖尾。</li><li>Lifetime（生命）：拖尾的生命值。就是拖尾开始消失的时间。1是和粒子生命一样长。注意的是，默认Diewithparticle勾上时，粒子消失后拖尾也会消失，这个消失跟拖尾的Lifetime没有关系，只是被摧毁了。拖尾的生命时间就是开始消失的时间。</li><li>Minimum VertexDistance(最小顶点距离)：mesh的两个顶点的距离。也就是细节程度，值越小，效果越好。实质上是产生一次mesh的时间。当然时间越小整个生命里产生的网格越多了。早先版本trail的产生是按每多少帧产生mesh的数量算的，所以会造成一旦卡了，trail就完全没法看了，这里是按时间算的，不用担心掉帧了。</li><li>WorldSpace（世界空间）：勾上时，这个拖尾会受到空间位移的影响。不勾是，只会相对于自身粒子系统进行拖尾。</li><li>Die withparticle（跟随粒子消亡）：勾上时，粒子消失后，拖尾一起消失。</li><li>Texture Mode(图片模式)：<ul><li>Stretch(拉伸):在整个mesh上拉伸整张图的U</li><li>Tile（平铺）：U不会被拉伸，超出部分是重复平铺</li><li>Distribute PerSegment（每段都分配）：和Stretch效果差不多，但计算的切入点不一样，Stretch是先计算出trail的长度，在拉伸图片。这个是先计算又多少个网格，每个网格上应该分配多少图片的信息。理论上应该更精细</li><li>Repeat Per Segment（每段重复）：每一个网格上分配一个图片</li></ul></li></ul><p><img src="2023-07-10T220838.png" alt="2023-07-10T220838" /><br /></p><p><img src="2023-07-10T220845.png" alt="2023-07-10T220845" /><br /></p><p><img src="2023-07-10T220900.png" alt="2023-07-10T220900" /><br /></p><p><img src="2023-07-10T220909.png" alt="2023-07-10T220909" /><br /></p><ul><li><p>Size affectswidth（尺寸影响宽度）：勾上时，默认宽度和粒子大小一致。而且宽度也随粒子大小变化了。</p></li><li><p>Size affectslifetime（尺寸影响寿命）：勾上时，生命时间（也就是开始消失的时间）会受到尺寸的影响。当粒子变的巨大和很小时，智能的缩减拖尾时间很有必要。</p></li><li><p>Inherit particlecolor（继承粒子颜色）：勾上时，拖尾颜色会受到粒子颜色的影响。</p></li><li><p>Color overlifetime（生命期内颜色）：拖尾生命时间内的颜色情况，是时间层面的，使用Gradient模式可以设置随时间变化颜色，开始是什么色，后面是什么色。跟粒子生命时间内颜色类似。</p></li><li><p>Color overtrail（拖尾颜色的情况）：拖尾自身的颜色变化情况。是空间层面。使用Gradient模式可以设前段是什么色，后段是什么色。注意和Colorover lifetime区别。</p></li><li><p>Width overtrail（拖尾的宽度情况）：重要调节，来真正影响拖尾的宽度的值。曲线模式下可调节拖尾的前后宽度，横轴是整体长度，竖轴是宽度。</p></li><li><p>Generate LightingData（生成光照信息）：让trail可以收到光照</p></li><li><p>Ribbon（丝带）：让产生的粒子链接起来。目前来说功能很匮乏，效果很尴尬。</p></li><li><p>Ribboncount（丝带数量）：就是使用几条丝带来将所有粒子链接起来。1就是只有一条。当丝带数大于场景中的粒子数时，就不在会产生粒子。多说下粒子系的事情，每个粒子系统的粒子都是有序号的，假设一个序号为1的粒子2秒后消失，内存上说但他并不是真的消失了，它会从新回到发射器原点，模拟一个新的粒子出生，拥有新的生命和速度大小等。而这里的丝带链接目标是和序号有紧密关系的（坑深不挖）。所以当你看到条带数是粒子数的一半时，是两两链接的。</p></li><li><p>Split Sub EmitterRibbons（分离子发射器的丝带）：就是如果当期粒子系统是一个子发射器。让每个粒子产生的新的发射器和其他产生的发射器不关联</p></li></ul><h2 id="二十二renderer渲染器">二十二、Renderer（渲染器）</h2><p><img src="2023-07-10T221508.png" alt="2023-07-10T221508" /><br /></p><ul><li>NormalDirection（法线方向）：改变粒子片的法线方向。当粒子受到光照时（关键是shader要支持），将一个片模拟成一个受光照的体积</li><li>Material（材质）：粒子的材质。图片通过shader生成一个材质。</li><li>Trail Material（拖尾材质）：拖尾材质。</li><li>SortMode（排序模式）：给粒子排列先后顺序，它是针对粒子系统自身发出的粒子进行排序。而且粒子材质球是可排序的才有意义。就是材质要是透明材质才行。<ul><li>None（无）：不排序，混乱的。</li><li>ByDistance（依据距离）：根据粒子距离摄像机的远近排序。比较常用。</li><li>Oldest inFront（最早在前）：谁先出生排列在前，后出生排列早后。平面上可能有用。</li><li>Youngest inFront（最新的在前）：谁后出生排列在前、后出生排列在后。</li></ul></li><li>SortingFudge（排序欺骗）：作者的意思大概是说这是一个欺骗性的排序，它让粒子假装往前或者往后移动的多少距离。负值是原理镜头、正值是靠近镜头，靠近镜头的肯定会在前面。当然材质球也必须是可排序的材质球才行。例如相加、相乘、透明混合等。</li><li>Min particleSize（最小粒子尺寸）：简单说小于这个值的粒子都会被放大到这个值这么大。这个值是屏幕大小，值1就是一个平面那么大。做屏幕特效时有用，不必去把粒子设的很大，用这个就能准确设定大小</li><li>Max particleSize（最大粒子尺寸）：这个值同样只屏幕大小。当粒子显示大于这个值时，会被缩小。避免细小的粒子冲向摄像机时变的巨大。</li><li>Render Alignment（显示队列）：指定粒子朝向方向，也就是z轴朝向。<ul><li>View（视野）：粒子片z轴朝向你观察的方向。</li><li>World（时间）：粒子片z轴朝向世界的z轴。</li><li>Local（自身）：粒子片z轴朝向粒子系统自身的z轴。这时就可以旋转它了，就是真实粒子片的状态。</li><li>Facing（面朝）：粒子片z轴朝向摄像机位置。和view效果很像，但是却不并不一样。这里朝向时，会去掉透视关系，只是拿z这个面朝向你。Mesh状态下能看的更清楚。</li><li>Velocity（速率）：粒子片z轴朝向自身运动的方向</li></ul></li><li>Pivot（中心点）：设置了三个方向可以调节中心点。在StretchedBillboard会有大用</li><li>Visualizepivot（可视化中心点）：使粒子的中心点显示出来。粒子真正的运行位置，调节pivot时有用</li><li>Masking（遮挡）：是关于sprite遮挡的功能。简而言之，sprite有个组件可以把图片做成一个遮照放到场景中。处理超出这个遮照范围外就会消失，或者只在范围外显示。通常用于平面类型特效上面</li><li>No Masking（无遮挡）：不会有遮挡<ul><li>Visible Inside Mask（遮照内部可见）：只在SpriteMask内部显示粒子。超出不显示</li><li>Visible Outside Mask（遮照外部可见）：只在SpriteMask外部显示粒子。内部不显示</li></ul></li><li>Custom VertexStreams（自定义顶点流）：程序相关，脚本调用。主要处理顶点色。</li><li>CastShadows（投射阴影）：可以投射阴影。但材质必须是不透明类型的。Off（关）On（开）TwoSided（双面）shadows Only（只有阴影。-）</li><li>ReceiveShadow（接收阴影）：公共版模式下意义不大因为是一个片接收到阴影并不舒服，建议mesh模型下使用。</li><li>MotionVectors（移动向量）：和摄像机的运动向量有关。不太明白意义是什么。可以确定的是和特效制作没关系了。</li><li>SortingLayer（排序层）：设置一个层处理前后关系，越早创建的层越靠后，越新创建的层越靠前。</li><li>Order in Layer（层中排序）：在这里可以在同一个SortingLayer层里设置前后关系。值越大越靠前。 要注意这两个功能和SortingFudge是有区别的。SortingFudge是假设他在场景中的位置，负值是离镜头较远、正值是离镜头较近。近的肯定是会覆盖掉远的，从而调节先后关系。而这里是真正更改渲染顺序的。在unity中整个排序是这样的，先计算shader上面的顺序，然后是Sortinglayer的前后，然后是Order in layer大小，最后才是SortingFudge的影响。</li><li>Light Probes（光照探针）：</li><li>Reflection Probes（反射探针）：这两项和其拓展出的功能都和灯光探测有关，坑深不挖。特效制作基本不用</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一主模块&quot;&gt;一、主模块&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;2023-07-09T152604.png&quot; alt=&quot;2023-07-09T152604&quot; /&gt;&lt;br /&gt;
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Duration：不勾循环的情况下，粒子发射器的发射持续</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"/>
    
    <category term="粒子系统" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Unity" scheme="https://peiyuzou.github.io/tags/Unity/"/>
    
  </entry>
  
</feed>
