<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Back Number</title>
  
  
  <link href="https://peiyuzou.github.io/atom.xml" rel="self"/>
  
  <link href="https://peiyuzou.github.io/"/>
  <updated>2025-07-15T03:06:16.909Z</updated>
  <id>https://peiyuzou.github.io/</id>
  
  <author>
    <name>Z.P.Y</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>3.3 数字编码</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.3-%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.3-%E6%95%B0%E5%AD%97%E7%BC%96%E7%A0%81/</id>
    <published>2025-07-15T02:25:59.000Z</published>
    <updated>2025-07-15T03:06:16.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原码反码和补码">原码、反码和补码</h1><p>在上一节的表格中我们发现，所有整数类型能够表示的负数都比正数多一个，例如byte 的取值范围是 <span class="math inline">\([-128, 127]\)</span>。这个现象比较反直觉，我们需要先了解原码、反码和补码：</p><ul><li>原码：我们将数字的二进制表示的最高位视为符号位，其中 0 表示正数， 1表示负数，其余位表示数字的值。</li><li>反码：正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反。</li><li>补码：正数的补码与其原码相同，负数的补码是在其反码的基础上加 1。</li></ul><p><img src="num_encode_0.png"alt="原码、反码与补码之间的相互转换" /><br /></p><p><strong>在计算机中，数字是以“补码”的形式存储的</strong>，这一点非常重要，但为什么不用原码呢？</p><p>原码虽然最直观，但存在一些局限性。一方面，负数的原码不能直接用于运算。例如在原码下计算<span class="math inline">\(1 + (-2)\)</span> ，得到的结果是 <spanclass="math inline">\(-3\)</span> ，这显然是不对的。</p><p><span class="math display">\[\begin{align}1 + (-2) &amp;= 0000\,0001 + 1000\,0010 \\    &amp;= 1000\,0011 \\    &amp;= -3\end{align}\]</span></p><p>为了解决此问题，计算机引入了反码：</p><p><span class="math display">\[\begin{align}1 + (-2) &amp;= 0000\,0001(原码) + 1000\,0010(原码) \\    &amp;= 0000\,0001(反码) + 1111\,1101(反码) \\    &amp;= 1111\,1110(反码) \\    &amp;= 1000\,0001(原码) \\    &amp;= -1\end{align}\]</span></p><p>另一方面，数字零的原码有 <span class="math inline">\(-0\)</span> 和<span class="math inline">\(+0\)</span>两种表示方式。如果是这样，计算机要处理零相关的判断需要同时处理这两个，降低运行效率。为了统一正负零，计算机引入了补码：</p><p><span class="math display">\[\begin{align}-0 &amp;= 1000\,0000(原码) \\    &amp;= 1111\,1111(反码) \\    &amp;= 1\,0000\,0001(补码)\end{align}\]</span></p><p>在负零的反码基础上加 1 会产生进位，但 byte 类型的长度只有 8位，因此溢出到第 9 位的 1会被舍弃。因此得到的补码中，正负零都是同一个值了。</p><p>然而，补码 <span class="math inline">\(1000\,0000\)</span>是一个例外，它并没有对应的原码。根据转换方法，我们得到该补码的原码为<span class="math inline">\(0000\,0000\)</span>。这显然是矛盾的，因为该原码表示数字 <spanclass="math inline">\(0\)</span>，它的补码应该是自身。计算机规定这个特殊的补码 <spanclass="math inline">\(1000\,0000\)</span> 代表 <spanclass="math inline">\(-128\)</span> 。实际上，<spanclass="math inline">\((-1) + (-127)\)</span> 在补码下的计算结果就是<span class="math inline">\((-128)\)</span> 。</p><p><span class="math display">\[\begin{align}(-127) + (-1) &amp;= 1111\,1111(原码) + 1000\,0001(原码) \\    &amp;= 1000\,0000(反码) + 1111\,1110(反码) \\    &amp;= 1000\,0001(补码) + 1111\,1111(补码) \\    &amp;= 1000\,0000(补码) \\    &amp;= -128\end{align}\]</span></p><p>你可能已经发现了，上述所有计算都是加法运算。这暗示着一个重要事实：<strong>计算机内部的硬件电路主要是基于加法运算设计的</strong>。这是因为加法运算相对于其他运算（比如乘法、除法和减法）来说，硬件实现起来更简单，更容易进行并行化处理，运算速度更快。</p><p>通过将加法与一些基本逻辑运算结合，计算机能够实现各种其他的数学运算。例如，计算减法<span class="math inline">\(a - b\)</span> 可以转换为计算加法 <spanclass="math inline">\(a + (-b)\)</span>；计算乘法和除法可以转换为计算多次加法或减法。</p><h1 id="浮点数编码">浮点数编码</h1><p><img src="num_encode_1.png"alt="IEEE 754 标准下的 float 的计算示例" /><br /></p><p>我们这里所说的浮点数以 float 为准，double 是同理的</p><p>float 相较于 int 而言，两者都是 32 位的长度，但是 float表示的值范围要大得多，但副作用是牺牲了精度：由于指数位的存在，浮点数float 的数值越大，相邻两个数字之间的差值就会趋向越大。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原码反码和补码&quot;&gt;原码、反码和补码&lt;/h1&gt;
&lt;p&gt;在上一节的表格中我们发现，所有整数类型能够表示的负数都比正数多一个，例如
byte 的取值范围是 &lt;span class=&quot;math inline&quot;&gt;&#92;([-128, 127]&#92;)&lt;/span&gt;
。这个现象</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="03-数据结构" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>3.2 基本数据类型</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.2-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.2-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-07-15T01:54:14.000Z</published>
    <updated>2025-07-15T02:13:07.861Z</updated>
    
    <content type="html"><![CDATA[<p>基本数据类型是 CPU可以直接进行运算的类型。基本数据类型以二进制的形式存储在计算机中。一个二进制位即为1 比特。在绝大多数现代操作系统中，1 字节（byte）由 8比特（bit）组成。</p><p>以下是 C# 中的基本数据类型</p><table><colgroup><col style="width: 11%" /><col style="width: 13%" /><col style="width: 11%" /><col style="width: 25%" /><col style="width: 26%" /><col style="width: 11%" /></colgroup><thead><tr><th>类型分类</th><th>符号</th><th>占用空间</th><th>最小值</th><th>最大值</th><th>默认值</th></tr></thead><tbody><tr><td>整数</td><td><code>sbyte</code></td><td>1 字节</td><td><span class="math inline">\(-2^7\)</span></td><td><span class="math inline">\(2^7 - 1\)</span></td><td>0</td></tr><tr><td>整数</td><td><code>byte</code></td><td>1 字节</td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(2^8 - 1\)</span></td><td>0</td></tr><tr><td>整数</td><td><code>short</code></td><td>2 字节</td><td><span class="math inline">\(-2^{15}\)</span></td><td><span class="math inline">\(2^{15} - 1\)</span></td><td>0</td></tr><tr><td>整数</td><td><code>ushort</code></td><td>2 字节</td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(2^{16} - 1\)</span></td><td>0</td></tr><tr><td>整数</td><td><code>int</code></td><td>4 字节</td><td><span class="math inline">\(-2^{31}\)</span></td><td><span class="math inline">\(2^{31} - 1\)</span></td><td>0</td></tr><tr><td>整数</td><td><code>uint</code></td><td>4 字节</td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(2^{32} - 1\)</span></td><td>0</td></tr><tr><td>整数</td><td><code>long</code></td><td>8 字节</td><td><span class="math inline">\(-2^{63}\)</span></td><td><span class="math inline">\(2^{63} - 1\)</span></td><td>0</td></tr><tr><td>整数</td><td><code>ulong</code></td><td>8 字节</td><td><span class="math inline">\(0\)</span></td><td><span class="math inline">\(2^{64} - 1\)</span></td><td>0</td></tr><tr><td>浮点数</td><td><code>float</code></td><td>4 字节</td><td><span class="math inline">\(\approx -3.4 \times10^{38}\)</span></td><td><span class="math inline">\(\approx 3.4 \times 10^{38}\)</span></td><td>0.0f</td></tr><tr><td>浮点数</td><td><code>double</code></td><td>8 字节</td><td><span class="math inline">\(\approx -1.8 \times10^{308}\)</span></td><td><span class="math inline">\(\approx 1.8 \times10^{308}\)</span></td><td>0.0d</td></tr><tr><td>字符</td><td><code>char</code></td><td>2 字节</td><td><code>U+0000</code></td><td><code>U+FFFF</code></td><td><code>\0</code></td></tr><tr><td>布尔</td><td><code>bool</code></td><td>1 字节</td><td><code>false</code></td><td><code>true</code></td><td>false</td></tr></tbody></table><p>需要注意：</p><ul><li>字符 char 的大小在 C 和 C++ 中为 1字节，在大多数编程语言中取决于特定的字符编码方法。</li><li>即使表示布尔量仅需 1 位（0 或 1），它在内存中通常也存储为 1字节。这是因为现代计算机 CPU 通常将 1 字节作为最小寻址内存单元。</li></ul><p>基本数据类型提供了数据的 “内容类型” ，而数据结构提供了数据的“组织方式”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;基本数据类型是 CPU
可以直接进行运算的类型。基本数据类型以二进制的形式存储在计算机中。一个二进制位即为
1 比特。在绝大多数现代操作系统中，1 字节（byte）由 8
比特（bit）组成。&lt;/p&gt;
&lt;p&gt;以下是 C# 中的基本数据类型&lt;/p&gt;
&lt;table&gt;</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="03-数据结构" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>3.1 数据结构的分类</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%86%E7%B1%BB/</id>
    <published>2025-07-15T01:41:15.000Z</published>
    <updated>2025-07-15T01:51:43.910Z</updated>
    
    <content type="html"><![CDATA[<p>常见的数据结构包括：数组、链表、栈、队列、哈希表、树、堆、图</p><p>数据结构的分类，按照逻辑结构分：</p><ul><li>线性</li><li>非线性</li></ul><p>按照物理结构分：</p><ul><li>连续</li><li>分散</li></ul><h1 id="线性和非线性">线性和非线性</h1><ul><li>线性数据结构：元素之间是一对一的顺序关系，比如数组、链表、栈、队列、哈希表</li><li>非线性数据结构：元素之间是一对多或者多对多的关系<ul><li>树形结构（一对多）：树、堆、哈希表</li><li>网状结构（多对多）：图</li></ul></li></ul><p><img src="data_struct_0.png"alt="线性数据结构与非线性数据结构" /><br /></p><h1 id="连续与分散">连续与分散</h1><p>当算法程序运行时，正在处理的数据主要存储在内存中。系统通过内存地址来访问目标位置的数据。</p><p><img src="data_struct_1.png"alt="内存条、内存空间、内存地址" /><br /></p><p>在数据结构与算法的设计中，内存资源是一个重要的考虑因素。算法所占用的内存峰值不应超过系统剩余空闲内存；如果缺少连续大块的内存空间，那么所选用的数据结构必须能够存储在分散的内存空间内。</p><p><img src="data_struct_2.png"alt="连续空间存储与分散空间存储" /><br /></p><p>值得说明的是，所有数据结构都是基于数组、链表或二者的组合实现的。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。</p><ul><li>基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 <spanclass="math inline">\(\ge3\)</span> 的数组）等。</li><li>基于链表可实现：栈、队列、哈希表、树、堆、图等。</li></ul><p>链表在初始化后，仍可以在程序运行过程中对其长度进行调整，因此也称“动态数据结构”。数组在初始化后长度不可变，因此也称“静态数据结构”。值得注意的是，数组可通过重新分配内存实现长度变化，从而具备一定的“动态性”。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;常见的数据结构包括：数组、链表、栈、队列、哈希表、树、堆、图&lt;/p&gt;
&lt;p&gt;数据结构的分类，按照逻辑结构分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性&lt;/li&gt;
&lt;li&gt;非线性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按照物理结构分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连续&lt;/li&gt;
</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="03-数据结构" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/03-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>01.方法和函数</title>
    <link href="https://peiyuzou.github.io/wiki/98-%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9/01.%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/"/>
    <id>https://peiyuzou.github.io/wiki/98-%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9/01.%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/</id>
    <published>2025-07-15T01:34:16.000Z</published>
    <updated>2025-07-15T01:37:37.646Z</updated>
    
    <content type="html"><![CDATA[<p>函数（function）可以被独立执行，所有参数都以显式传递。方法（method）与一个对象关联，被隐式传递给调用它的对象，能够对类的实例中包含的数据进行操作。</p><p>下面以几种常见的编程语言为例来说明：</p><ul><li>C语言是过程式编程语言，没有面向对象的概念，所以只有函数。但我们可以通过创建结构体（struct）来模拟面向对象编程，与结构体相关联的函数就相当于其他编程语言中的方法。</li><li>Java 和 C#是面向对象的编程语言，代码块（方法）通常作为某个类的一部分。静态方法的行为类似于函数，因为它被绑定在类上，不能访问特定的实例变量。</li><li>C++ 和 Python既支持过程式编程（函数），也支持面向对象编程（方法）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;函数（function）可以被独立执行，所有参数都以显式传递。方法（method）与一个对象关联，被隐式传递给调用它的对象，能够对类的实例中包含的数据进行操作。&lt;/p&gt;
&lt;p&gt;下面以几种常见的编程语言为例来说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C
语言是过程式编程语言，</summary>
      
    
    
    
    <category term="98-易混淆点" scheme="https://peiyuzou.github.io/categories/98-%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9/"/>
    
    
    <category term="易混淆点" scheme="https://peiyuzou.github.io/tags/%E6%98%93%E6%B7%B7%E6%B7%86%E7%82%B9/"/>
    
  </entry>
  
  <entry>
    <title>03.中央处理器</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/03.%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/03.%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/</id>
    <published>2025-07-14T13:56:30.000Z</published>
    <updated>2025-07-15T01:25:14.263Z</updated>
    
    <content type="html"><![CDATA[<p>中央处理器，常称 CPU（Central ProcessingUnit），我们本篇从一个高层次视角去了解 CPU的组成，每一个根线不是指代真正的数据线，而是一组完善电路的抽象，代表这里有某种连接，这种高层次视角称“微体系架构” （MicroArchitecture）</p><h1 id="cpu-组成">CPU 组成</h1><p>首先，我们要准备一个 RAM ，但注意<strong>内存不是 CPU的组成部分</strong>，这里是为了演示 CPU如何和内存打交道，进而解释它每个组成部分在其中发挥的作用。</p><p>为了简单，我们假设有一个只有 16 个地址的RAM（如下图所示），因此它的地址可以用 4 位值表示（0 ~ 15），这 16个地址中存储了若干的指令或者数据。对于数据来说，其中的 8位都是值。对于指令来说，高 4 位代表操作码，低 4位代表目标数据在内存或者寄存器中的地址。（这里只是举例，在实际的内存中可能和这个设计不一样，也可能更复杂）</p><p><img src="cpu_0.png" alt="内存" /><br /></p><h2 id="设立寄存器">设立寄存器</h2><p>为了操作数据和存储临时数据，我们需要给 CPU 安排 4 个寄存器：</p><p><img src="cpu_1.png" alt="临时存储和操作数据的寄存器" /><br /></p><p>我们给 CPU 支持的所有指令分配一个操作码，对应上面指令中的高 4位，比如下图：</p><p><img src="cpu_2.png" alt="指令表" /><br /></p><p>我们还需要另外两个寄存器：</p><ul><li>指令地址寄存器：用于追踪当前程序运行到哪里，存储的是指令在内存中的地址</li><li>指令寄存器：用于存储当前指令，方便 CPU 解码这个指令</li></ul><p><img src="cpu_3.png" alt="指令地址寄存器 和 指令寄存器" /><br /></p><p>计算机开始运行，所有寄存器被初始化为 0 ：</p><p><img src="cpu_4.png" alt="初始化寄存器" /><br /></p><h2 id="取指令">取指令</h2><p>计算机从内存中取指令，然后一条一条执行，首先指令地址寄存器访问内存的第一个地址，并且将第一个地址的内容（一条指令）放入指令寄存器中：</p><p><img src="cpu_5.png" alt="取指令阶段" /><br /></p><h2 id="解释并执行指令">解释并执行指令</h2><p>得到了一条指令后，计算机需要将这条指令解释。它的高 4位的值对应指令表中的第一条，即将指定内存地址的值放入寄存器 A 中：</p><p><img src="cpu_6.png" alt="解释并执行" /><br /></p><h2 id="继续取指令解释执行">继续取指令、解释、执行</h2><p>执行完一条指令后，指令地址寄存器指向的内存地址 + 1，继续读取下一条指令，然后解释执行。</p><h1 id="控制单元">控制单元</h1><p>由指令地址寄存器、指令寄存器、解码电路等部分组成了一个控制单元（ControlUnit），我们可以将它抽象出来：</p><p><img src="cpu_7.png" alt="控制单元" /><br /></p><h1 id="继续执行">继续执行</h1><h2 id="第二条指令">第二条指令</h2><p>CPU 继续取下一条指令并执行，第二条指令将内存地址 15 的值放在了寄存器B 中：</p><p><img src="cpu_8.png" alt="第二条指令的执行结果" /><br /></p><h2 id="第三条指令">第三条指令</h2><p>第三条指令比较特殊，它代表将两个寄存器的值相加，并将结果放在指定的第二个寄存器中，这里寄存器A 的地址为 00 ，寄存器 B 的地址为 01 ，因此是要将 B 中的值与 A中的值相加，结果放入 A 中：</p><p><img src="cpu_9.png" alt="第三条指令的解释阶段" /><br /></p><p>为了对两个值做算数运算，我们需要继续设立一个 ALU进来，控制单元会将两个寄存器的值作为 ALU 的两个输入，然后传递 ALU当前的操作码，计算得到的值并不会马上写入寄存器，而是放在一个临时的寄存器中（图中没有），当关闭ALU 之后再写入寄存器 A ，防止 ALU 的值错误：</p><p><img src="cpu_10.png" alt="第三条指令的执行阶段" /><br /></p><h2 id="最后一条指令">最后一条指令</h2><p>最后一条指令，将寄存器 A 中的值写入内存中：</p><p><img src="cpu_11.png" alt="第四条指令的执行结果" /><br /></p><h1 id="时钟">时钟</h1><p>时钟（Clock）用来管理 CPU 的执行节奏。</p><p><img src="cpu_12.png" alt="时钟" /><br /></p><p>它以精确的间隔来触发电信号，控制单元根据这个电信号去推动 CPU的内部操作。这频率不能太快，因为电的传输也需要时间（很少很少）。</p><p>CPU 执行一次 “取指令-解码-执行” 的速度叫做 “时钟速度”，它的单位是赫兹（Hz），现代 CPU 的主频已经达到了 GHz级别，我们常说的超频就是允许 CPU以更快的速度执行，但会增大用电量，并且可能损坏 CPU ，同样，许多 CPU也有降频功能，在闲置的时间段内降频可以降低耗电量，这些都是通过改变时钟速度实现的。</p><h1 id="对-cpu-做一次抽象">对 CPU 做一次抽象</h1><p>现在我们得到了一个简单的 CPU ，可以对它进行一次抽象：</p><p><img src="cpu_13.png" alt="CPU" /><br /></p><p>从这里也可以看出来，RAM 不是 CPU 的组成部分，但它们息息相关</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;中央处理器，常称 CPU（Central Processing
Unit），我们本篇从一个高层次视角去了解 CPU
的组成，每一个根线不是指代真正的数据线，而是一组完善电路的抽象，代表这里有某种连接，这种高层次视角称
“微体系架构” （MicroArchitectur</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CrashCourse" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/"/>
    
    
    <category term="CS-101" scheme="https://peiyuzou.github.io/tags/CS-101/"/>
    
  </entry>
  
  <entry>
    <title>2.4 空间复杂度</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.4-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.4-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2025-07-14T09:45:37.000Z</published>
    <updated>2025-07-14T10:01:27.976Z</updated>
    
    <content type="html"><![CDATA[<p>空间复杂度（spacecomplexity）用于衡量算法占用内存空间随着数据量变大时的增长趋势。</p><h1 id="算法相关空间">算法相关空间</h1><p>算法在运行过程中使用的内存空间主要包括以下几种。</p><ul><li>输入空间：用于存储算法的输入数据</li><li>暂存空间：用于存储算法在运行过程中的变量、对象、函数上下文等数据<ul><li>暂存数据：用于保存算法运行过程中的各种常量、变量、对象等</li><li>栈帧空间：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放</li><li>指令空间：用于保存编译后的程序指令，在实际统计中通常忽略不计</li></ul></li><li>输出空间：用于存储算法的输出数据</li></ul><p>一般情况下，空间复杂度的统计范围是 “暂存空间” 加上 “输出空间” ：</p><p><img src="space_complex_0.png" alt="算法使用的相关空间" /><br /></p><p>代码举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 结构体 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node *next;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行某些操作...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;        <span class="comment">// 输入数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>;          <span class="comment">// 暂存数据（常量）</span></span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;                <span class="comment">// 暂存数据（变量）</span></span><br><span class="line">    Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">0</span>); <span class="comment">// 暂存数据（对象）</span></span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">func</span>();           <span class="comment">// 栈帧空间（调用函数）</span></span><br><span class="line">    <span class="keyword">return</span> a + b + c;         <span class="comment">// 输出数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="推算方法">推算方法</h1><p><strong>我们通常只关注最差空间复杂度</strong>。因为内存空间是一项硬性要求，我们必须确保在所有输入数据下都有足够的内存空间预留：</p><ul><li>以最差输入数据为准</li><li>以算法运行中的峰值内存为准</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Algorithm</span>(<span class="params"><span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">int</span> a = <span class="number">0</span>;                   <span class="comment">// O(1)</span></span><br><span class="line">    <span class="built_in">int</span>[] b = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10000</span>];    <span class="comment">// O(1)</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = <span class="keyword">new</span> <span class="built_in">int</span>[n]; <span class="comment">// O(n)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个例子，最差空间复杂度为 <spanclass="math inline">\(O(n)\)</span></p><p>在递归函数中，需要注意统计栈帧空间：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Function</span>()</span> &#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 循环的空间复杂度为 O(1) */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Loop</span>(<span class="params"><span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Function();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 递归的空间复杂度为 O(n) */</span></span><br><span class="line"><span class="function"><span class="built_in">int</span> <span class="title">Recur</span>(<span class="params"><span class="built_in">int</span> n</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Recur(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="常见类型">常见类型</h1><p><img src="space_complex_1.png" alt="常见的空间复杂度类型" /><br /></p><h2 id="常数阶-o1">常数阶 <span class="math inline">\(O(1)\)</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 执行某些操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 常数阶 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Constant</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 常量、变量、对象占用 O(1) 空间</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10000</span>];</span><br><span class="line">    ListNode node = <span class="built_in">new</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 循环中的变量占用 O(1) 空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环中的函数占用 O(1) 空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">Function</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性阶-on">线性阶 <span class="math inline">\(O(n)\)</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性阶 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Linear</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 长度为 n 的数组占用 O(n) 空间</span></span><br><span class="line">    <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="comment">// 长度为 n 的列表占用 O(n) 空间</span></span><br><span class="line">    List&lt;ListNode&gt; nodes = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nodes.<span class="built_in">Add</span>(<span class="keyword">new</span> <span class="built_in">ListNode</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 长度为 n 的哈希表占用 O(n) 空间</span></span><br><span class="line">    Dictionary&lt;<span class="type">int</span>, string&gt; map = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        map.<span class="built_in">Add</span>(i, i.<span class="built_in">ToString</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平方阶-on2">平方阶 <spanclass="math inline">\(O(n^2)\)</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 平方阶 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Quadratic</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 矩阵占用 O(n^2) 空间</span></span><br><span class="line">    <span class="type">int</span>[,] numMatrix = <span class="keyword">new</span> <span class="type">int</span>[n, n];</span><br><span class="line">    <span class="comment">// 二维列表占用 O(n^2) 空间</span></span><br><span class="line">    List&lt;List&lt;<span class="type">int</span>&gt;&gt; numList = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        List&lt;<span class="type">int</span>&gt; tmp = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            tmp.<span class="built_in">Add</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        numList.<span class="built_in">Add</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指数阶-o2n">指数阶 <spanclass="math inline">\(O(2^n)\)</span></h2><p>指数阶常见于二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指数阶（建立满二叉树） */</span></span><br><span class="line">TreeNode? <span class="built_in">BuildTree</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> null;</span><br><span class="line">    TreeNode root = <span class="built_in">new</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        left = <span class="built_in">BuildTree</span>(n - <span class="number">1</span>),</span><br><span class="line">        right = <span class="built_in">BuildTree</span>(n - <span class="number">1</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对数阶-olog-n">对数阶 <span class="math inline">\(O(logn)\)</span></h2><p>对数阶常见于分治算法。例如归并排序，输入长度为 n的数组，每轮递归将数组从中点处划分为两半，形成高度为 <spanclass="math inline">\(log_{2}n\)</span> 的递归树，使用 <spanclass="math inline">\(O(log_{2}n)\)</span> 栈帧空间。</p><h1 id="权衡时间与空间">权衡时间与空间</h1><p><strong>降低时间复杂度通常需要以提升空间复杂度为代价，反之亦然</strong>。我们将牺牲内存空间来提升算法运行速度的思路称为“以空间换时间” ；反之，则称为 “以时间换空间” 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;空间复杂度（space
complexity）用于衡量算法占用内存空间随着数据量变大时的增长趋势。&lt;/p&gt;
&lt;h1 id=&quot;算法相关空间&quot;&gt;算法相关空间&lt;/h1&gt;
&lt;p&gt;算法在运行过程中使用的内存空间主要包括以下几种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;输入空间：用于存储</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="02-复杂度分析" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2.3 时间复杂度</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.3-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.3-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</id>
    <published>2025-07-14T07:58:59.000Z</published>
    <updated>2025-07-14T09:46:12.527Z</updated>
    
    <content type="html"><![CDATA[<p>时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势</p><h1 id="统计时间增长趋势">统计时间增长趋势</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算法 A 的时间复杂度：常数阶</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm_A</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 算法 B 的时间复杂度：线性阶</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm_B</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 算法 C 的时间复杂度：常数阶</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm_C</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析这个例子：</p><ul><li>算法 A 运行时间不随 n 的增大而增长，它的时间复杂度为 “常数阶”</li><li>算法 B 运行时间随着 n 增大呈线性增长。此算法的时间复杂度被称为“线性阶”</li><li>算法 C 虽然运行时间很长，但它与输入数据大小与 n 无关，因此也是“常数阶”</li></ul><h1 id="时间复杂度推算方法">时间复杂度推算方法</h1><h2 id="第一步统计操作数量">第一步：统计操作数量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    a = a + n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> * n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码如果精确地统计它的操作数量，应该是这样：</p><p><span class="math display">\[ T(n) = 2n(n + 1) + 5(n + 1) + 2 = 2n^2+ 7n + 3 \]</span></p><p>它的时间复杂度为 <span class="math inline">\(O(n^2)\)</span>（时间复杂度由 <span class="math inline">\(T(n)\)</span>中最高阶的项来决定），但我们可以通过技巧来快速推断：</p><ul><li>舍掉常数和系数，因为它们不会影响最终的计算</li><li>循环嵌套时使用乘法</li></ul><p>所以上述代码，我们可以直接得到操作数量：</p><p><span class="math display">\[ T(n) = n^2 + n \]</span></p><p>转为时间复杂度为 <span class="math inline">\(O(n^2)\)</span></p><h1 id="常见类型">常见类型</h1><p><img src="time_complex_0.png" alt="常见的时间复杂度类型" /><br /></p><p>以下分别用 C++ 代码举例：</p><h2 id="常数阶-o1">常数阶 <span class="math inline">\(O(1)\)</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 常数阶 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">constant</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性阶-on">线性阶 <span class="math inline">\(O(n)\)</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性阶 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">linear</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        count++;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="平方阶-on2">平方阶 <spanclass="math inline">\(O(n^2)\)</span></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 平方阶 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">quadratic</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环次数与数据大小 n 成平方关系</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指数阶-o2n">指数阶 <spanclass="math inline">\(O(2^n)\)</span></h2><p>以 “细胞分裂” 为例，每轮是上一次的两倍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指数阶（循环实现） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exponential</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>, base = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 细胞每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; base; j++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        base *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对数阶-olog-n">对数阶 <span class="math inline">\(O(logn)\)</span></h2><p>与指数阶相反，对数阶反映了“每轮缩减到一半”的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对数阶（循环实现） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">logarithmic</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        n = n / <span class="number">2</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性对数阶-on-log-n">线性对数阶 <span class="math inline">\(O(nlog n)\)</span></h2><p>线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 <spanclass="math inline">\(O(n)\)</span> 和 <span class="math inline">\(O(logn)\)</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 线性对数阶 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">linearLogRecur</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">linearLogRecur</span>(n / <span class="number">2</span>) + <span class="built_in">linearLogRecur</span>(n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阶乘阶-on">阶乘阶 <spanclass="math inline">\(O(n!)\)</span></h2><p>阶乘阶对应数学上的 “全排列” 问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 阶乘阶（递归实现） */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorialRecur</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从 1 个分裂出 n 个</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count += <span class="built_in">factorialRecur</span>(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最差最佳平均时间复杂度">最差、最佳、平均时间复杂度</h1><p>算法的时间效率往往不是固定的，而是与输入数据的分布有关。因此我们的算法的时间复杂度可能会变化。</p><p>我们在实际中很少使用最佳时间复杂度，因为通常只有在很小概率下才能达到，可能会带来一定的误导性。而最差时间复杂度更为实用，因为它给出了一个效率安全值，让我们可以放心地使用算法。</p><p>平均时间复杂度则是体现算法在随机输入数据下的运行效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势&lt;/p&gt;
&lt;h1 id=&quot;统计时间增长趋势&quot;&gt;统计时间增长趋势&lt;/h1&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="02-复杂度分析" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2.2 迭代和递归</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.2-%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.2-%E8%BF%AD%E4%BB%A3%E5%92%8C%E9%80%92%E5%BD%92/</id>
    <published>2025-07-14T07:36:59.000Z</published>
    <updated>2025-07-14T08:13:42.586Z</updated>
    
    <content type="html"><![CDATA[<p>在算法中，重复执行某个任务是很常见的，它与复杂度分析息息相关。常见的重复执行有迭代和递归，这两者也经常被搞混</p><h1 id="迭代">迭代</h1><p>迭代是在满足一定的条件下重复执行某段代码，直到这个条件不再满足，一般有以下几种：</p><ul><li>for 循环</li><li>while 循环</li><li>嵌套循环</li></ul><h1 id="递归">递归</h1><p>递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。</p><ul><li>递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li><li>归：触发 “终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li></ul><p>而从实现的角度看，递归代码主要包含三个要素。</p><ul><li>终止条件：用于决定什么时候由 “递” 转 “归”。</li><li>递归调用：对应 “递”，函数调用自身，通常输入更小或更简化的参数。</li><li>返回结果：对应 “归”，将当前递归层级的结果返回至上一层。</li></ul><p><img src="recursion_sum.png" alt="求和函数的递归过程" /><br /></p><h2 id="调用栈">调用栈</h2><p>递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果：</p><ul><li>函数的上下文数据都存储在称为 “栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，递归通常比迭代更加耗费内存空间。</li><li>递归调用函数会产生额外的开销。因此递归通常比循环的时间效率更低。</li></ul><p>在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出错误。</p><h2 id="尾递归">尾递归</h2><p>如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tailrecursion）。</p><p>为什么尾递归可以优化？因为尾递归中，递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。</p><h2 id="递归树">递归树</h2><p>当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。</p><p>思考实现一个斐波那契数列的计算，数列中的每个数字是前两个数字的和，即<span class="math inline">\(f(n) = f(n - 1) + f(n - 2)\)</span> ，C++函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 斐波那契数列：递归 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件 f(1) = 0, f(2) = 1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 递归调用 f(n) = f(n-1) + f(n-2)</span></span><br><span class="line">    <span class="type">int</span> res = <span class="built_in">fib</span>(n - <span class="number">1</span>) + <span class="built_in">fib</span>(n - <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 返回结果 f(n)</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在函数内递归调用了两个函数，这意味着从一个调用产生了两个调用分支。这样不断递归调用下去，最终将产生一棵层数为n 的递归树（recursion tree）。</p><p><img src="recursion_tree.png" alt="斐波那契数列的递归树" /><br /></p><p>从本质上看，递归体现了 “将问题分解为更小子问题”的思维范式，这种分治策略至关重要。</p><ul><li>从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。</li><li>从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。</li></ul><h1 id="两者对比">两者对比</h1><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr><th></th><th>迭代</th><th>递归</th></tr></thead><tbody><tr><td>实现方式</td><td>循环结构</td><td>函数调用自身</td></tr><tr><td>时间效率</td><td>效率通常较高，无函数调用开销</td><td>每次函数调用都会产生开销</td></tr><tr><td>内存使用</td><td>通常使用固定大小的内存空间</td><td>累积函数调用可能使用大量的栈帧空间</td></tr><tr><td>适用问题</td><td>适用于简单循环任务，代码直观、可读性好</td><td>适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在算法中，重复执行某个任务是很常见的，它与复杂度分析息息相关。常见的重复执行有迭代和递归，这两者也经常被搞混&lt;/p&gt;
&lt;h1 id=&quot;迭代&quot;&gt;迭代&lt;/h1&gt;
&lt;p&gt;迭代是在满足一定的条件下重复执行某段代码，直到这个条件不再满足，一般有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="02-复杂度分析" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2.1 数据结构和算法概览</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.1-%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E8%AF%84%E4%BC%B0/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/2.1-%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E8%AF%84%E4%BC%B0/</id>
    <published>2025-07-14T07:16:59.000Z</published>
    <updated>2025-07-14T07:32:48.803Z</updated>
    
    <content type="html"><![CDATA[<p>算法的目标：</p><ul><li>找到问题解法</li><li>寻找最优解法</li></ul><p>所以<strong>算法效率</strong>是评价算法优劣的指标，包含两个维度：</p><ul><li>时间效率</li><li>空间效率</li></ul><p>效率评估的方法主要分：实际测试、理论估算</p><h1 id="实际测试">实际测试</h1><p>对比两个算法最直接的方式是用一台计算机直接运行然后对比它们的运行时间和内存占用情况，但是这种方式也存在很大的局限性：</p><ul><li>难以排除测试环境的干扰因素。测试机器的硬件会影响我们的测试，比如一个算法的并行度较高，那么它就更适合在多核CPU上运行，一个算法的内存操作密集，那么它在高性能内存上的表现就会更好。但我们不可能在大量机器上做测试对比。</li><li>展开完整测试非常耗费资源。随着输入数据量的变化，算法会表现出不同的效率。但我们的测试输入样例是有限的。</li></ul><h1 id="理论估算">理论估算</h1><p>由于实际测试具有较大的局限性，所以一般我们使用<strong>复杂度分析</strong>来评估算法，它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;算法的目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找到问题解法&lt;/li&gt;
&lt;li&gt;寻找最优解法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以&lt;strong&gt;算法效率&lt;/strong&gt;是评价算法优劣的指标，包含两个维度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间效率&lt;/li&gt;
&lt;li&gt;空间效</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="02-复杂度分析" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/02-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>1.1 数据结构和算法概览</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/01-%E6%A6%82%E8%A7%88/1.1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/01-%E6%A6%82%E8%A7%88/1.1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E6%A6%82%E8%A7%88/</id>
    <published>2025-07-14T07:02:48.000Z</published>
    <updated>2025-07-14T07:16:52.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法定义">算法定义</h1><p>算法（algorithm）是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性。</p><ul><li>问题是明确的，包含清晰的输入和输出定义。</li><li>具有可行性，能够在有限步骤、时间和内存空间下完成。</li><li>各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。</li></ul><h1 id="数据结构定义">数据结构定义</h1><p>数据结构（datastructure）是组织和存储数据的方式，涵盖数据内容、数据之间关系和数据操作方法，它具有以下设计目标。</p><ul><li>空间占用尽量少，以节省计算机内存。</li><li>数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。</li><li>提供简洁的数据表示和逻辑信息，以便算法高效运行。</li></ul><p>数据结构设计是一个充满权衡的过程。如果想在某方面取得提升，往往需要在另一方面作出妥协。下面举两个例子。</p><ul><li>链表相较于数组，在数据添加和删除操作上更加便捷，但牺牲了数据访问速度。</li><li>图相较于链表，提供了更丰富的逻辑信息，但需要占用更大的内存空间。</li></ul><h1 id="数据结构与算法的关系">数据结构与算法的关系</h1><ul><li>数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。</li><li>算法为数据结构注入生命力。数据结构本身仅存储数据信息，结合算法才能解决特定问题。</li><li>算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法定义&quot;&gt;算法定义&lt;/h1&gt;
&lt;p&gt;算法（algorithm）是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;问题是明确的，包含清晰的输入和输出定义。&lt;/li&gt;
&lt;li&gt;具有可行性，能够在有限步骤、时间和内存空</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    <category term="01-概览" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/01-%E6%A6%82%E8%A7%88/"/>
    
    
    <category term="数据结构和算法" scheme="https://peiyuzou.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>02.寄存器和内存</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/02.%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/02.%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98/</id>
    <published>2025-07-12T14:37:30.000Z</published>
    <updated>2025-07-15T01:25:14.188Z</updated>
    
    <content type="html"><![CDATA[<p>计算机的存储分为随机访问存储（RAM）和持久存储，这一节讨论的是前者，即：计算机在通电的状态下，如何存储数据</p><h1 id="如何存储-1-bit-的数据">如何存储 1 bit 的数据</h1><p>计算机通电后的电流都是单向流动的，所以要在通电时存储电信号，工程师对逻辑电路做了处理，让输出电信号回流到其中一个输出：</p><p><img src="latch_0.png" alt="可以存储 1 和 0 的电路" /><br /></p><p>上面的两个电路分别可以存储 1 和0，但是这还不够，毕竟它们的存储都是不可改变的，为此，逻辑电路被组合了起来：</p><p><img src="latch_1.png" alt="AND-OR 锁存器" /><br /></p><p>这个电路被称为锁存器（AND-ORLatch），是因为它锁住了一个位的值，这样就真正意义上存储了 1 bit的值！</p><p>但是使用 <code>设置</code> 和 <code>复位</code>两条线来输入比较难以理解，易用的结构应该是下面这样的：</p><p><img src="latch_2.png"alt="更易用的设计：一条输入线和一条允许写入线" /><br /></p><p>所以又有了这样的电路，我们称之为门锁（Gate Latch）：</p><p><img src="latch_3.png" alt="门锁的电路实现" /><br /></p><p>之所以称为门锁，是因为它可以打开和关上，我们不必过于关心它的实现细节，所以再次抽象：</p><p><img src="latch_4.png" alt="门锁" /><br /></p><p>这样，我们拥有了一个真正意义上可以存储 1 bit 数据的锁存器</p><h1 id="寄存器register">寄存器（Register）</h1><p>我们把 8 个锁存器并成一排形成一组，这样我们就得到了一个寄存器。</p><p>寄存器能够存储一个数字，寄存器有多少位，就叫<code>位宽</code>。早期的计算机使用 8 位宽的寄存器，后面 16 位、32位、直到如今的 64 位。</p><p>想象一下，如果我们要往一个寄存器里面写值，那么我们至少需要 8根输入线和 8 根输出线，但 “允许写入线” 可以只用一根，将 8个锁存器全部连通。这样，当寄存器要写入数据时，把 “允许写入线” 置 1，八根输入线写入数据后，再将 “允许写入线” 置 0 即可。</p><h1 id="内存">内存</h1><p>现在我们的存储规模再次提升，超过单个寄存器，存储 256位数据，线的数量就会来到 64 + 64 + 1 = 129 根！</p><p>于是矩阵式的电路设计出现了。锁存器不再是单纯并排排布，而是网格排布，下图是存256 位的 16x16的锁存器布局，当我们要写入某个锁存器时，只需要同时启用对应的行线和列线：</p><p><img src="latch_5.png" alt="16x16 的网格布局" /><br /></p><p>这样，我们需要的线就变成了：</p><ul><li>1 根数据线</li><li>1 根 “允许写入线”</li><li>16 行和 16 列的线用于选择锁存器</li></ul><p>129 根线被优化为 1 + 1 + 16 + 16 = 34 根线，即使加上 “允许读取线”，也才 35 根线</p><h2 id="多路复用器">多路复用器</h2><p>采用矩阵式电路设计后，我们用可以用行数加列数来表示一个锁存器的地址，比如第12 行 8 列的锁存器地址是 <code>11001000</code> 。行和列分别占 4 bit，如何把这个 4位的值转换到电路上，就要用到<strong>多路复用器（Multiplexer）</strong></p><p><img src="latch_6.png" alt="行和列都需要一个多路复用器" /><br /></p><p>两个多路复用器，分别用来转换行和列的地址</p><h2 id="对内存抽象">对内存抽象</h2><p>以上的结构做一次抽象，得到下面的 256 bit 的内存：</p><p><img src="latch_7.png" alt="单个 256 bit 内存的抽象" /><br /></p><p>它使用 8 位地址（4 位行和 4位列），一条数据线，一条写入线和一条读取线</p><p>我们将 8 个 256 bit 内存并排排布，用 8 根线串联控制地址，用 2根线串联分别控制写入和读取，再对每个内存单独用 1 根数据线（共 8根数据线），可以实现<strong>在指定 8 位地址存储一个 8位数字</strong>：</p><p><img src="latch_8.png" alt="RAM 的电路设计" /><br /></p><p>对这个电路再次做抽象，我们就得到了一个可寻址的内存，由于地址最多有256 个，所以我们最多可以存储 256 个 8 位值：</p><p><img src="latch_9.png" alt="RAM" /><br /></p><p>由于可以随时访问任意位置，这样的内存被叫做 RAM (Random AccessMemory，随机访问存储器)。现代的内存条可以达到几十 GB容量，归根结底就是排布了大量类似这样的内存电路。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计算机的存储分为随机访问存储（RAM）和持久存储，这一节讨论的是前者，即：计算机在通电的状态下，如何存储数据&lt;/p&gt;
&lt;h1 id=&quot;如何存储-1-bit-的数据&quot;&gt;如何存储 1 bit 的数据&lt;/h1&gt;
&lt;p&gt;计算机通电后的电流都是单向流动的，所以要在通电时存储电信号</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CrashCourse" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/"/>
    
    
    <category term="CS-101" scheme="https://peiyuzou.github.io/tags/CS-101/"/>
    
  </entry>
  
  <entry>
    <title>01.算数逻辑单元</title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/01.%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/01.%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83/</id>
    <published>2025-07-12T13:28:47.000Z</published>
    <updated>2025-07-14T01:39:24.734Z</updated>
    
    <content type="html"><![CDATA[<p>算数逻辑单元，通常叫做 ALU（Arithmetic &amp; LogicUnit），它包含两个单元：算数单元和逻辑单元</p><h1 id="算数单元">算数单元</h1><p>算数单元负责了计算机的所有算数计算，了解它需要先理解<strong>半加器</strong>和<strong>全加器</strong></p><h2 id="半加器">半加器</h2><p>思考我们在单个 <code>bit（位）</code> 上做二进制加法：</p><p><img src="half_adder_0.png" alt="二进制相加表格" /><br /></p><p>加法非常简单，但是结果无法用单个位存储，因为 <code>1 + 1</code>的结果带有进位（Carry），所以我们需要有两个输出值：</p><p><img src="half_adder_1.png" alt="半加器表格" /><br /></p><p>因此，我们可以抽象出一个 <code>半加器（half adder）</code>：</p><p><img src="half_adder_2.png" alt="半加器" /><br /></p><h2 id="全加器">全加器</h2><p>如果我们要实现多位数的相加，那么除了最低位，其余位都要处理这个进位，所以输入的值会变成三个：</p><p><img src="full_adder_0.png" alt="全加器表格" /><br /></p><p>所以我们又抽象出了一个 <code>全加器（full adder）</code>：</p><p><img src="full_adder_1.png" alt="全加器" /><br /></p><h2 id="制作-8-位加法器">制作 8 位加法器</h2><p>通过半加器和全加器，我们可以对多位表示的数进行加法运算，由于最低位不计算进位，所以使用半加器去处理，剩余的位使用全加器：</p><p><img src="full_adder_2.png" alt="8 位行波进位加法器" /><br /></p><p>由此我们得到了一个 8 位行波进位加法器（8-bit ripple carry adder）</p><p>注意最高位仍然有一个进位，当这个进位为1，代表两个数字之和太大，发生了溢出</p><h2 id="alu-的其他算数能力">ALU 的其他算数能力</h2><p>包含上面部分说的加法，ALU 一般还可以做以下的运算：</p><ul><li>加法</li><li>带进位的加法</li><li>减法</li><li>带借位的减法</li><li>正负取反</li><li>自增</li><li>自减</li><li>数字无改变，通过（All bits of A are passed through unmodified）</li></ul><p>对于简单的 ALU来说，它们没有能直接处理乘法和除法的算数单元，但是可以通过多次简单的运算来达到目的，比如<code>12 x 5</code> 变为<code>12 + 12 + 12 + 12 + 12</code>，而现代计算的 CPU比较先进，它们具备了专门做乘除法的算数单元</p><h1 id="逻辑单元">逻辑单元</h1><p>逻辑单元用来处理一些逻辑运算，比如<code>AND</code>、<code>OR</code>、<code>NOT</code>、<code>XOR</code>等，也可以用于做一些简单的数值测试，比如检查 ALU 的输出是否为 0</p><p><img src="logic_unit_0.png"alt="检查 ALU 输出是否为 0 的电路" /><br /></p><h1 id="alu-的抽象">ALU 的抽象</h1><p>一般工程师使用下图的 “V” 型图标表示一个 ALU ：</p><p><img src="alu_0.png" alt="ALU" /><br /></p><p>ALU 要求有两个 8 位的输入值，另外还要 4位的操作码，以此来确定怎么处理两个函数的计算（比如 1000代表相加），最终输出一个 8 位的值，另外还有一些标记位（单个bit），比如图中的三个：</p><ul><li>Overflow：运算是否发生了溢出</li><li>Zero：运算结果是否为零，判断两个数值是否相等的时候很有用</li><li>Negative：运算结果是否为负，判断大小时有用</li></ul><p>一些高级的 ALU 还会有其他的 Flags，但是这三个是比较通用的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;算数逻辑单元，通常叫做 ALU（Arithmetic &amp;amp; Logic
Unit），它包含两个单元：算数单元和逻辑单元&lt;/p&gt;
&lt;h1 id=&quot;算数单元&quot;&gt;算数单元&lt;/h1&gt;
&lt;p&gt;算数单元负责了计算机的所有算数计算，了解它需要先理解&lt;strong&gt;半加器&lt;/s</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    <category term="CrashCourse" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/CrashCourse/"/>
    
    
    <category term="CS-101" scheme="https://peiyuzou.github.io/tags/CS-101/"/>
    
  </entry>
  
  <entry>
    <title>01.Lz4压缩</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/01.Lz4/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/01.Lz4/</id>
    <published>2025-07-10T11:06:13.000Z</published>
    <updated>2025-07-11T01:43:50.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>LZ4 是一种无损压缩算法，提供每核 &gt; 500 MB/s的压缩速度，并可通过多核 CPU进行扩展。它具有极快的解码器，每核速度可达数 GB/s，通常会达到多核系统的RAM 速度极限。</p><p>作为 Unity AssetBundle 主推的压缩算法，它相比 Lzma拥有更快的速度（大约是 Lzma 的十倍以上）。并且是基于块压缩的（ChunkBased），可以按需选择加载部分块，而不用将整个文件全部加载，这对于内存来说是更友好的。唯一相较于Lzma 的劣势是压缩率，大约比 Lzma 高出 30%</p><h1 id="lz4-的原理">Lz4 的原理</h1><p>Lz4压缩后的文件由块组成，每一个压缩块则由若干序列组成，它的核心原理简单概括就是找出重复的字节序列，按照固定规则以更省空间的形式存储。先来看它的序列示意图：</p><p><img src="Lz4_Sequence.png" alt="Lz4的序列" /><br /></p><p>首先，开头的一个字节称为一个标记（Token），这个标记由两个 4位组成（因此值的范围从 0 到 15）</p><p>高 4位用于存储字面量（Literal）的长度，字面量是指压缩过程中无法被压缩的原始字节。由于4 位能表示的值范围有限，因此图中 Literal length+（图中黄色区域）用于支持更大的长度值的存储，这是一个可选的区域。如果 4位之内足够存储字面量的长度，这个区域就不存在，Token 之后会紧跟Literals（字面量）。如果该 4 位存储的值为 0，则代表没有字面量。如果为15（4 位全 1），则增加一个 Literal length+ 区域，其代表的值为 0 -255（一个字节的大小），此时字面量的长度 = 15 +这个字节的值。如果这个字节的值仍然满了（255），则继续增加一个新的字节，直到可以表示字面量的长度为止。（因此图中写的是0-n bytes）</p><p>这两个区域之后，则是字面量的存储区域，字面量是未压缩的字节，按原样复制。</p><p>紧接着是偏移量（Offset），这是一个两个字节的值（0-65535），它表示要从中复制匹配的位置。请注意，0是无效值，不会被使用。1 表示“当前位置 - 1字节”，另外需要注意，这个值使用小端格式存储（低位在前，高位在后）。通过偏移量，我们可以得到重复字节的起始位置</p><p>我们使用重复字节的起始位置加上匹配长度的值，就可以得到重复位置从哪个位置开始到哪个位置结束。匹配长度是指从在Token 的低 4位值存储，如果不够，再启用后面的可选区域，可选区域的规则和字面量长度的规则一致，但这里有一点细小的差异，匹配长度要求最小值为4，也就是说至少要 4个重复的字节才可以压缩，这应该是为了压缩率至少不能超过 1而设计的，毕竟压缩后变大了是不行的。这里存储的值如果为 0，代表匹配长度为4 个字节，如果值为 15，代表匹配长度为 19+个字节（可能启用了可选区域）</p><h1 id="进行一次计算">进行一次计算</h1><p><img src="Lz4_Exp.drawio.png" alt="原始字节序列" /><br /></p><p>假设我们有上面这个字节序列，其中每个字节编号一个索引，最大值是F（11111111），现在开始对它进行模拟压缩，步骤如下：</p><p><img src="Lz4.drawio.png" alt="模拟压缩步骤" /><br /></p><h2 id="压缩计算">压缩计算</h2><p>现在我们得到：</p><ul><li>字面量为[C, C, C, A, B, C, D, E, F, B, B, B]，长度为12。</li><li>偏移量为9</li><li>匹配长度为6</li></ul><p>首先第一个序列用来存储字面量：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Token：</span><br><span class="line">- 高 4 位：12（字面量长度，小于 15 无需额外字节）</span><br><span class="line">- 低 4 位：0（不存储匹配）</span><br><span class="line">Literals：[C, C, C, A, B, C, D, E, F, B, B, B]</span><br><span class="line">Offset：由于该序列仅表示字面量，因此不存储Offset</span><br></pre></td></tr></table></figure><p>第二个序列用来存储匹配数据：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">匹配信息:</span><br><span class="line">- 偏移量: 9</span><br><span class="line">- 匹配长度: 6</span><br><span class="line">Token:</span><br><span class="line">- 高4位: 0 (没有字面量)</span><br><span class="line">- 低4位: 2 (匹配长度 = 6-4 = 2)</span><br><span class="line">Token = 0x02</span><br><span class="line">偏移量编码: 0x0009 → 小端序 [0x09][0x00]</span><br></pre></td></tr></table></figure><p>得到最终压缩结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0xC0][C][C][C][A][B][C][D][E][F][B][B][B][0x02][0x09][0x00]</span><br><span class="line"></span><br><span class="line">原始数据: 18字节</span><br><span class="line">压缩数据: 16字节</span><br><span class="line">压缩率: 16/18 ≈ 88.9%</span><br><span class="line">节省: 2字节 (11.1%)</span><br></pre></td></tr></table></figure><h2 id="解压计算">解压计算</h2><p>解压Token1 (0xC0)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字面量长度: 12</span><br><span class="line">匹配长度: 0</span><br><span class="line">操作: 复制12个字面量</span><br><span class="line">输出: C C C A B C D E F B B B</span><br></pre></td></tr></table></figure><p>解压Token2 (0x02)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字面量长度: 0</span><br><span class="line">匹配长度: 2+4 = 6</span><br><span class="line">偏移量: 9</span><br><span class="line">操作: 从位置3开始复制6个字节</span><br><span class="line">输出: A B C D E F (复制位置3-8)</span><br></pre></td></tr></table></figure><p>最终结果与原数据一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C C C A B C D E F B B B A B C D E F</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;LZ4 是一种无损压缩算法，提供每核 &amp;gt; 500 MB/s
的压缩速度，并可通过多核 CPU
进行扩展。它具有极快的解码器，每核速度可达数 GB/s，通常会达到多核系统的
RAM 速度极限。&lt;/p&gt;
&lt;p&gt;作为 Uni</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="压缩算法" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Compression" scheme="https://peiyuzou.github.io/tags/Compression/"/>
    
  </entry>
  
  <entry>
    <title>05.Unity内存优化最佳实践</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/05.Unity%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/05.Unity%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2025-07-10T08:30:30.000Z</published>
    <updated>2025-07-10T08:30:39.063Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"/>
    
    <category term="Unity内存管理" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Unity" scheme="https://peiyuzou.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>04.Unity Managed Memory</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/04.Unity%20Managed%20Memory/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/04.Unity%20Managed%20Memory/</id>
    <published>2025-07-10T05:43:59.000Z</published>
    <updated>2025-07-10T08:18:00.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览">概览</h1><ul><li>VM 内存池<ul><li>VM 返回内存给操作系统的条件</li></ul></li><li>GC 机制<ul><li>GC 机制考量<ul><li>Throughput（回收能力）</li><li>Pause Times（暂停时长）</li><li>Fragmentation（碎片化）</li><li>Mutator overhead（额外消耗）</li><li>Scalability（可扩展性）</li><li>Portability（可移植性）</li></ul></li><li>使用的 GC<ul><li>Boehm<ul><li>Non-generaional</li><li>Non-compacting</li></ul></li><li>Incremental GC（渐进式GC）</li></ul></li><li>Memory fragmentation（内存碎片化）</li><li>Zombie Memory（僵尸内存）<ul><li>无用内存</li><li>没有释放</li><li>通过代码管理和性能工具分析</li></ul></li></ul></li></ul><h2 id="vm-内存池">VM 内存池</h2><p>Unity 编辑器进程自身使用 MonoVM，打包后的实际游戏进程根据脚本后端选择不同，使用 IL2Cpp Runtime 或者Mono VM。注意这里说的 VM 是指实际游戏进程使用的 VM。</p><p>Mono VM 的内存池，内存以 Block 的形式管理，当一个 Block 连续 6 次 GC没有被访问到，这块内存会被返回给系统，条件苛刻，比较难触发。</p><p>IL2CPP 更容易触发，因为它的内存管理更像一个传统 C++程序的内存管理模式。</p><blockquote><p>注意，GC 本身是不会把内存返还给操作系统的，它是回收给虚拟机。</p></blockquote><h2 id="unity-的-gc">Unity 的 GC</h2><h3 id="gc-机制的考量">1. GC 机制的考量</h3><ul><li>Throughput（回收能力）：一次GC能收回多少内存</li><li>Pause times（暂停时长）：GC时对主线程的影响会多大（卡顿）</li><li>Fragmentation（碎片化）：对整体内存池的碎片化影响多少</li><li>Mutatoroverhead（额外消耗）：GC时的消耗，GC时需要做很多的统计会产生消耗</li><li>Scalability（可拓展性）：拓展到多核多线程会不会有什么bug</li><li>Portability（可移植性）：在不同的平台上是否可以使用</li></ul><h3 id="boehm-gc-和-incremental-gc">2. Boehm GC 和 Incremental GC</h3><p>Unity 用的 Boehm GC，简单粗暴，不分代。它有以下特点：</p><ul><li>Non-generational（非分代式），即全都堆在一起，因为这样会很快。分代的话就是例如大内存，小内存，超小内存分在不同的内存区域来进行管理（SGenGC的设计思想）。</li><li>Non-Compacting（非压缩式），即当有内存被释放的时候，这块区域就空着。而压缩式的会重新排布，填充空白区域，使内存紧密排布。</li></ul><p>但目前 Unity 在 Mono 上已经使用 SGen GC （Scalable GenerationalGC，分代垃圾回收器）了，而 IL2CPP 则是嵌入了一个定制化后的 Boehm</p><p>结论如下表：</p><table><thead><tr><th>Unity后端</th><th>使用的GC</th><th>是否 Boehm</th><th>是否支持分代</th></tr></thead><tbody><tr><td>Mono（编辑器）</td><td>Mono SGen GC</td><td>非 Boehm</td><td>是</td></tr><tr><td>IL2CPP</td><td>Boehm GC（定制版）</td><td>是</td><td>否</td></tr><tr><td>DOTS/Burst</td><td>无托管堆</td><td>无GC</td><td>N/A</td></tr></tbody></table><p>Unity 另外实装了 IncrementalGC，主要解决主线程卡顿的问题，现在进行一次GC主线程被迫要停下来，遍历所有的Memory Island，决定哪些要被 GC掉，会造成一定时间的主线程卡顿。Incremental GC把前面暂停主线程的事分帧做了，这样主线程不会出现峰值。</p><h3 id="内存碎片化">3. 内存碎片化</h3><p>非压缩式的内存虽然快（避免了内存重新排布的时间消耗），但是容易造成内存碎片化。内存的碎片化容易间接内存异常上涨，比如内存总用量下降了，但是还在继续分配新的空间。例如，内存中有一些空白的内存区域时，分配了一块较大内存时，却没有任何的一个空间放得下（即使整体的空间足够），导致内存扩充很多。</p><p>因此建议在需要连续分配内存的情况下，先操作大内存，然后操作小内存，可以一定程度上减轻碎片化。</p><h3 id="僵尸内存">4. 僵尸内存</h3><p>这个和内存泄漏常被人搞混在一起。僵尸内存是指碎片化内存之间空出的内存，这部分内存可能成为僵尸内存。这种情况实际上并不是内存泄露，因为这些内存并没有被泄露，泄露指这块内存没有任何人可以访问和管理，但实际上这块内存一直在内存池里。</p><h1 id="managed-memory-最佳实践">Managed Memory 最佳实践</h1><h2 id="dont-null-it-destroy-it">1. Don’t Null it, Destroy it</h2><p>用 Destroy，别用 null，显示的调用 Destroy 才能真正的销毁掉。</p><h2 id="class-和-struct-不要混用">2. Class 和 Struct 不要混用</h2><p>这个不赘述</p><h2 id="pool-in-pool">3. Pool In Pool</h2><p>高频使用的部分自己建一个内存池去重用</p><h2 id="closures-and-anonymous-methods闭包和匿名函数">4. Closures andanonymous methods（闭包和匿名函数）</h2><p>所有的匿名函数和闭包在 C# 编 IL 代码时都会被 new 成一个Class（匿名class），所以在里面所有变量以及new的东西，都是要占内存的。</p><h2 id="coroutines协程">5. Coroutines（协程）</h2><p>协程属于闭包和匿名函数的特例，游戏开始启动一个协程直到游戏结束才释放，是错误的做法。因为协程只要没被释放，里面的所有变量，即使是局部变量（包括值类型），也都会在内存里。建议用的时候才生产一个协程，不用的时候就丢掉。</p><h2 id="configurations配置表">6. Configurations（配置表）</h2><p>全部配置表一下全部进内存也是不明智的，可以考虑分关加载等策略。</p><h2 id="singleton单例">7. Singleton（单例）</h2><p>慎用单例，不要什么都往里放，因为里面的变量会一直占用内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概览&quot;&gt;概览&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;VM 内存池
&lt;ul&gt;
&lt;li&gt;VM 返回内存给操作系统的条件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;GC 机制
&lt;ul&gt;
&lt;li&gt;GC 机制考量
&lt;ul&gt;
&lt;li&gt;Throughput（回收能力）&lt;</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"/>
    
    <category term="Unity内存管理" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Unity" scheme="https://peiyuzou.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>03.Unity Native Memory</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/03.Unity%20Native%20Memory/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/03.Unity%20Native%20Memory/</id>
    <published>2025-07-10T02:19:51.000Z</published>
    <updated>2025-07-10T05:43:16.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览">概览</h1><ul><li>Native Memory 介绍<ul><li>Allocator与Memory Label</li><li>GetRuntimeMemory</li><li>NewAsRoot</li><li>会即时返还给操作系统</li></ul></li><li>Native Memory 最佳实践<ul><li>Scene</li><li>Audio<ul><li>DSP buffer</li><li>Force to mono</li><li>Format</li><li>Compression Format</li></ul></li><li>Code Size</li><li>AssetBundle<ul><li>TypeTree</li><li>Lz4 &amp; Lzma</li><li>Size &amp; Count</li></ul></li><li>Resources<ul><li>R-B Tree</li></ul></li><li>Texture<ul><li>upload buffer</li><li>r/w</li><li>Mip Maps</li></ul></li><li>Mesh<ul><li>r/w</li><li>Compression</li></ul></li><li>Assets</li></ul></li></ul><h1 id="native-memory-介绍">Native Memory 介绍</h1><h2 id="allocator与memory-label">1. Allocator与Memory Label</h2><p>Unity 在里面重载了 C++ 的所有分配内存的操作符，例如 alloc，new等。每个操作符在被使用的时候要求有一个额外的参数就是 Memory Label，在Memory Profiler （Windows/Analysis/Memory Profiler）中查看 MemoryDetails 里的 Name 很多就是 MemoryLabel。它指的就是当前的这一块内存内存要分配到哪个类型池里。</p><h2 id="getruntimememory">2. GetRuntimeMemory</h2><p>Unity 在底层会用 Allocator，使用重载过的分配符分配内存的时候，会根据Memory Label 分配到不同的 Allocator池 里面。每个 Allocator池，单独做自己的跟踪。当要在 Runtime 去 Get 一个 Memory Label下面池的时候，可以从对应的 Allocator中取，可以从中知道有什么东西，有多少兆。</p><h2 id="newasroot">3. NewAsRoot</h2><p>前面提到的 Allocator 的生成是使用 NewAsRoot，生成一个所谓的 MemoryIsland，它下面会有很多的子内存。例如一个 Shader，当加载一个 shader进内存的时候，首先会生成一个 shader 的 Root，也就是 Memory Island。然后Shader 底下的数据，例如 Subshader，Pass，Parameters 等，会作为该 Root底下的成员，依次的分配。所以最后统计 Runtime 的内存时，统计这些 Root即可。</p><h2 id="返还操作系统">4. 返还操作系统</h2><p>因为是 C++ 的，所以当 delete 或 free一个内存的时候，会立刻返回给系统。这和托管内存不一样，托管内存需要 GC后才返回。</p><h1 id="native-memory-最佳实践">Native Memory 最佳实践</h1><p>在使用Unity的时候，如果某些方面使用不当，会造成 Native Memory的增长，所以这部分也是可以优化调整的。</p><h2 id="scene">1. Scene</h2><p>首当其冲，最常见的导致 Native Memory 增长的原因，就是Scene。因为Unity 是 C++ 引擎，所有的实体最终都会反映在 C++上，而不会反映在托管堆上。所以当 Scene 构建一个 GameObject的时候，实际上在 Unity 的底层会构建一个或多个 Object 来存储这一个GameObject 的信息（Component信息等）。所以当一个 Scene 里面有过多的GameObject 存在的时候，Native Memory就会显著的上升，甚至可能导致内存溢出。</p><blockquote><p>所以这里有一个经验之谈：当发现 Native Memory大量上升时，首先去着重检查你的 Scene</p></blockquote><h2 id="audio">2. Audio</h2><h3 id="dsp-buffer">2.1 DSP buffer</h3><p>指一个声音的缓冲，当一个声音要播放的时候，需要向 CPU去发送指令。如果声音的数据量非常的小，会造成频繁的向 CPU 发指令，造成 IO压力。在 Unity 的 FMOD 声音引擎里面，一般会有一个 Buffer，当 Buffer填充满了才会去向 CPU 发送一次播放声音的指令。所以 DSPBuffer大小的设置非常考究，一般会导致两种问题：</p><ul><li>设置的值过大，会导致声音的延迟，因为填充满需要很多的声音数据，当我们声音数据不大的时候，就会产生延时。</li><li>设置的值过小，会导致 CPU 负担上升，因为会频繁的发送。</li></ul><h3 id="audio-import-settings">2.2 Audio Import Settings</h3><p><strong>Force ToMono</strong>：​这个选项作用是强制单声道，很多声音为了追求质量会设置成双声道，导致声音在包体和内存中，占用的空间加倍，但是95%以上的声音，两个声道是完全一样的数据。因此对声音不是很敏感的项目建议勾选此项，来降低内存的占用。<strong>CompressionFormat</strong>：不同的平台有不同的声音格式的支持，iOS 对 MP3有硬件支持，Android 暂时没有硬件支持。建议 iOS 使用 ADPCM 和 MP3格式，Android 使用 Vorbis 格式。 <strong>LoadType</strong>：决定声音在内存中的存在形态： - Decompress OnLoad：当audio clip被加载时，解压声音数据，适用于小型音频文件（&lt;200kb） - Compressed InMemory：声音数据将以压缩的形式保存在内存当中，适用于中型音频文件（&gt;=200kb） -Streaming：从磁盘读取声音数据，适用于大型音频文件，例如背景音</p><blockquote><p>注：<br> - Decompress On Load，要求文件必须小于200kb，因为内部内存管理的问题，如果是大于 200kb的文件，那么也还是只会被分配到不足 200kb 的内存。<br> -Bitrate：可以对音频文件本身进行压缩，降低文件的比特率（bitrate），前提音频品质不会被破坏太严重。</p></blockquote><h2 id="code-size">3. Code Size</h2><p>代码文件也是占内存的，需要加载进内存执行。一个典型的例子是模板泛型的滥用，例如一个模板函数有四五个不同的泛型参数，类型也不尽相同（float，int，double等），最后展开得到的一个cpp 文件可能会很大。因为实际上 C++ 编译的时候用的所有的 Class，所有的Template最终都会被展开成静态类型。因此当模板函数有很多排列组合时，最后编译会得到所有的排列组合代码，导致文件很大。</p><p>这不光会影响到最终代码文件的大小，导致 Native Memory间接增长，同时也会影响IL2CPP编译速度，接触过 C++ 编译应该知道，单一一个cpp文件编译的话是没办法并行的，只能单核处理，所以也间接地导致打包慢。</p><h2 id="assetbundle">4. AssetBundle</h2><h3 id="typetree">4.1 TypeTree</h3><p>这个东西存在是为了做这件事：Unity前后有很多的版本，不同的版本中很多的类型可能会有数据结构的改变，为了做数据结构的兼容，会在生成数据类型序列化的时候，顺便生成一个叫TypeTree的东西。就是当前这个版本用到了哪些变量，它们对应的数据类型是什么，当进行反序列化的时候，根据TypeTree 去做反序列化。如果上一个版本的类型在这个版本没有，那 TypeTree里就没有它，所以不会去碰到它。如果有新的TypeTree，但是在当前版本不存在的话，那要用它的默认值来序列化。从而保证了在不同版本之间不会序列化出错。</p><p>在构建 AssetBundle 的时候，可以通过以下代码关掉 TypeTree 的生成：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BuildAssetBundleOptions.DisableWriteTypeTree</span><br></pre></td></tr></table></figure><p>什么时候可以关呢？当你可以保证构建 AssetBundle 的 Unity版本和使用它的Unity的版本是一模一样的时候（对兼容性不会有影响），就可以关闭。这样有三个好处：一、可以减少内存；二、AssetBundle包大小会减少；三、build 和 Runtime 会变快，因为不会去序列化和反序列化TypeTree（如果开了 TypeTree，序列化会做两步，首先去序列化TypeTree，然后再去序列化实际的东西，反序列化也一样）</p><h3 id="压缩方式lz4-和-lzma">4.2 压缩方式（Lz4 和 Lzma）</h3><p>Unity 目前主推Lz4（也就是ChunkBased，BuildAssetBundleOptions.ChunkBasedCompression），Lz4非常快，大概是 Lzma 的十倍以上的速度，但平均压缩比例比 Lzma 差 30%左右，即包体更大。但 Lzma 基本可以不用了，因为 Lzma解压和读取速度都非常慢，并且内存占比高，因为它的读取不是基于ChunkBased，而是 Stream，也就是一次全解压出来。ChunkBased可以逐块解压，每次解压可以重用之前的内存，减少内存的峰值。</p><blockquote><p>Lz4目前是开源的，可以了解下它的原理：https://github.com/lz4/lz4</p></blockquote><h3 id="大小和数量">4.3 大小和数量</h3><p>AssetBundle分两部分，一部分是头（用于索引），一部分是实际的打包的数据部分。如果每个Asset 都单独打成一个AssetBundle，那么可能所有问题加起来头的部分比数据还大。所以这个大小不适合太大也不能太小，官方建议一个AssetBundle在1-2M，但是现在进入 5g 时代的话，可以适当加大，因为网络带宽更大了。</p><h2 id="resources">5. Resources</h2><p>如果使用 Resources 模式打包，Resources文件夹里的内容被打进包的时候会做一个红黑树（R-BTree）用做索引，即检索资源到底在什么位置。所以Resource越大，红黑树越大，它不可卸载，并在刚刚加载游戏的时候就会被一直加在内存里，极大的拖慢游戏的启动时间，因为红黑树没有分析和加载完，游戏是不会启动的，并造成持续的内存压力。所以建议不要使用Resource，使用AssetBundle。</p><h2 id="texture">6. Texture</h2><ul><li>Upload Buffer：和声音的Buffer类似，填满后向 GPU push 一次</li><li>Read/Write：没必要的话就关闭，正常情况，Texture 读进内存解析完了搁到Upload Buffer 里之后，内存里那部分就会 delete掉。除非开了Read/Write，那就不会 delete了，会在显存和内存里各一份。前面说过手机内存显存通用的，所以内存里会有两份。</li><li>​Mip Maps：例如 UI元素这类相对于相机Z轴的值不会有任何变化的纹理，关闭该选项。</li><li>Alpha Source：对于不透明纹理，关闭其alpha通道。 ​​- MaxSize：根据平台不同，纹理的Max Size设成该平台最小值。</li><li>POT：纹理的大小尽量为2的幂次方（POT），因为有些压缩格式可能不支持非2的幂次方的。</li><li>压缩格式：<ul><li>Android<ul><li>支持 OpenGL ES 3.0 的使用 ETC2，RGB 压缩为 RGB Compressed ETC24bits，RGBA 压缩为 RGBA Compressed ETC2 8bits</li><li>需要兼容 OpenGL ES 2.0 的使用 ETC，RGB 压缩为 RGB Compressed ETC4bits，RGBA 压缩为 RGBA 16bits。（压缩大小不能接受的情况下，压缩为 2 张RGB Compressed ETC 4bits）</li><li>目前主流正在从 ETC2 向 ASTC转变，后者的压缩质量和大小上都有优势。它支持 OpenGL ES 3.1 和部分 OpenGLES 3.0 的设备。目前市面上绝大多数安卓设备都支持，已经可以普及使用</li></ul></li><li>iOS<ul><li>支持 OpenGL ES 3.0 的使用ASTC，RGB 压缩为RGB CompressedASTC 6x6block，RGBA 压缩为 RGBA Compressed ASTC 4x4 block。</li><li>对于法线贴图的压缩精度较高可以选择 RGB CompressedASTC 5x5block。</li><li>需要兼容OpenGLES 2.0 的使用 PVRTC，RGB 压缩为PVRTC 4bits，RGBA压缩为RGBA 16bits。（压缩大小不能接受的情况下，压缩为 2 张 RGB CompressedPVRTC 4bits）</li><li>截止目前 ASTC 合并了 RGB 和 RGBA格式，压缩格式的选择上面更加方便了</li></ul></li></ul></li></ul><h2 id="mesh">7. Mesh</h2><ul><li>Read/Write：同Texture，若开启，Unity会存储两份Mesh，导致运行时的内存用量变成两倍。</li><li>Compression：Mesh Compression是使用压缩算法将Mesh数据进行压缩，结果是会减少占用硬盘的空间，但是在Runtime的时候会被解压为原始精度的数据，因此内存占用并不会减少。需要注意的是有些版本开了，实际解压之后内存占用大小会更严重。</li><li>Rig：如果没有使用动画，请关闭Rig，例如房子，石头这些。</li><li>​​Blendshapes：如果没有用到Blendshapes，也关闭。</li><li>Material设置：如果Material没有用到法向量和切线信息，关闭可以减少额外信息。</li></ul><h2 id="assets">8. Assets</h2><p>和整个的 Asset 管理有关系，Unity官网上有关于资源管理的文章，找到再补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概览&quot;&gt;概览&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Native Memory 介绍
&lt;ul&gt;
&lt;li&gt;Allocator与Memory Label&lt;/li&gt;
&lt;li&gt;GetRuntimeMemory&lt;/li&gt;
&lt;li&gt;NewAsRoot&lt;/li&gt;
&lt;li&gt;会</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"/>
    
    <category term="Unity内存管理" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Unity" scheme="https://peiyuzou.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>02.Unity内存管理</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/02.Unity%E5%86%85%E5%AD%98%E7%AE%80%E4%BB%8B/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/02.Unity%E5%86%85%E5%AD%98%E7%AE%80%E4%BB%8B/</id>
    <published>2025-07-09T15:39:20.000Z</published>
    <updated>2025-07-10T02:03:41.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览">概览</h1><ul><li>Unity 是一个 C++ 引擎<ul><li>底层代码完全由 C++ 实现</li><li>通过 Wrapper 提供给用户 API</li><li>用户代码会转换为 Cpp 代码（IL2CPP）</li><li>VM 仍然存在（解决跨平台问题）</li></ul></li><li>Unity 的内存<ul><li>按照分配方式分为：<ul><li>Native Memory</li><li>Managed Memory</li><li>Editor &amp; Runtime 是不同的</li></ul></li><li>按照管理方式分为：<ul><li>引擎管理的内存</li><li>用户管理的内存</li></ul></li><li>Unity 监测不到的内存<ul><li>用户的 Native 代码</li><li>Lua</li></ul></li></ul></li></ul><h1 id="unity-引擎概述">Unity 引擎概述</h1><p>Unity 是一个 C++ 引擎，并不是 C# 引擎，底层代码全部是由 C++写的，除了一些 Editor 里面的 Services 可能会用到 NodeJS这些网络的语言，Runtime 里面用到的每行 Unity 底层代码都是 C++ 的。</p><p>Unity 实际上分为三层：</p><ul><li>最底层是 Runtime，全是 Native C++ 代码。</li><li>最上层是 C#，Unity 本身也有一些 C#，例如 Unity 的 Editor 是用 C#写的，还有些 Package 也是 C# 写的。</li><li>中间还有一层叫 Binding，可以看见很多的 .bindings.cs 文件（基于 C# 的binding 语言，一开始是 Unity 自定义的一种语言），这些文件的作用就是把C++ 和 C# 联系在一起，为 C# 层提供所有的 API。因此使用 Unity 时看见的 C#API，都是在 Binding 层中自定义的。这些文件底层运行的时候还是 C++，只是个Wrapper（封装）。</li></ul><p>最早用户代码是运行在 C# 上，是 MonoRuntime。现在可以通过 IL2CPP将其转成 C++ 代码，所以现在几乎没有纯正的 C# 在运行了。</p><p>Unity 的 VM（虚拟机：VirtualMachine）依旧还是存在，主要用于跨平台，有了一层 VM抽象后，跨平台的工作会容易很多，IL2CPP 本质也是 VM。</p><h1 id="unity-的内存">Unity 的内存</h1><p>Unity的内存，可以从以下几个层面去理解</p><h2 id="按照分配方式划分">1. 按照分配方式划分</h2><p>按照分配方式分为：Native Memory（原生内存）和ManagedMemory（托管内存）。Native Memory并不会被系统自动管理，需要手动去释放。而 Managed Memory的内存管理是自动的，会通过 GC 来释放。</p><p>此外 Unity 在 Editor 和 Runtime下，内存的管理方式是不同的，除了内存大小不同，内存的分配时机以及分配方式也不同。例如Asset，在Runtime 时，只有用户代码 Load 的时候才会进内存。而 Editor模式下，为了编辑的便利性，只要打开 Unity就会进内存（所以打开很慢）。后续有推出 Asset Pipeline2.0，一开始导入一些基本的 Asset，剩下的 Asset只有使用的时候才会导入，这样即使是很大的工程，也可以尽量减少使用者对不关心的Asset 付出导入时间的代价。</p><h2 id="按照内存管理方式划分">2. 按照内存管理方式划分</h2><p>按照管理方式分为：引擎管理内存和用户管理内存。引擎管理内存即引擎运行的时候分配的一些内存，例如很多的Manager和Singleton，这些内存开发者一般是碰触不到的。用户管理内存也就是开发者开发时使用到的内存，是我们平时接触最多的部分。</p><h2 id="unity-监测不到的内存">3. Unity 监测不到的内存</h2><ul><li>用户分配的Native内存。比如自己写的Native插件（C++插件）导入Unity，这部分Unity是检测不到的，因为Unity没法分析已编译的C++是如何分配和使用内存的</li><li>Lua，它完全自己管理的，Unity也没法统计到它内部的情况</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概览&quot;&gt;概览&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Unity 是一个 C++ 引擎
&lt;ul&gt;
&lt;li&gt;底层代码完全由 C++ 实现&lt;/li&gt;
&lt;li&gt;通过 Wrapper 提供给用户 API&lt;/li&gt;
&lt;li&gt;用户代码会转换为 Cpp 代码（IL2CPP）&lt;/</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"/>
    
    <category term="Unity内存管理" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Unity" scheme="https://peiyuzou.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>01.什么是内存</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/01.%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/01.%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98/</id>
    <published>2025-07-09T14:38:36.000Z</published>
    <updated>2025-07-10T01:40:39.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览">概览</h1><ul><li>物理内存<ul><li>CPU 访问内存是一个慢速过程<ul><li>减少 Cache miss</li><li>ECS 和 DOTS</li></ul></li><li>移动设备与台式设备内存架构差异<ul><li>没有独立显卡</li><li>没有独立显存</li><li>CPU 板载面积更小，缓存级数更少，缓存大小更小</li></ul></li></ul></li><li>虚拟内存<ul><li>内存交换<ul><li>PC 设备支持</li><li>移动设备不支持</li></ul></li><li>内存压缩<ul><li>iOS 支持</li><li>Android 不支持</li></ul></li></ul></li><li>内存寻址范围<ul><li>32 位 CPU 和 64 位 CPU的寻址范围不一定谁更大（但可以普遍认为后者更大）</li></ul></li><li>Android 内存管理<ul><li>内存基本单位：Page</li><li>内存杀手：low memory killer</li><li>内存指标：RSS、PSS、USS</li></ul></li></ul><h1 id="物理内存">物理内存</h1><p>物理内存关注两个点：CPU访问内存是一个慢速过程、理解移动设备的内存架构差异。这里只解释前者，后者比较简单，看大纲即可。</p><p>CPU 在访问内存之前，会先去依次访问 L1、L2、L3Cache，如果没有得到想要的数据（称为一次 CacheMiss），则会访问主内存，然后回到Cache。整个这个过程是比较慢的，如果执行指令或者内存地址不连续，这个过程会导致大量的Cache Miss，造成大量的主内存和 Cache之间的交换，大量的时间会被浪费在内存的读取上。</p><p>所以物理内存的一个核心问题是如何减少 Cache Miss。Unity 推出的 DOTS技术的一个理念就是把不连续的内存尽量变为连续的内存，以此减少 CacheMiss。</p><h1 id="虚拟内存">虚拟内存</h1><p>内存交换是指设备将无用的内存数据写入到硬盘，以腾出内存空间的行为。PC设备支持内存交换，移动设备不支持，不支持的原因有以下两点：</p><ul><li>移动设备的 IO 性能较差，做内存交换会严重影响性能</li><li>移动设备的外置存储可擦写次数较少，频繁的内存交换会减少外置存储的寿命</li></ul><p>为了解决这个问题，iOS支持了内存压缩，大致原理是把无用的内存数据压缩起来放到指定位置，以此节省内存空间。</p><h1 id="android-内存管理">Android 内存管理</h1><p>Android 是基于 Linux 的操作系统，所以 Android 的内存管理与 Linux的内存管理是类似的。</p><h2 id="内存基本单位">内存基本单位</h2><p>它的内存基本单位是一个 Page，大小为 4KB（不代表所有数据是按照 4KB进行内存对齐）。回收和分配以 Page为单位。内存空间分为内核态和用户态，内核态的内存是用户态严格禁止访问的。</p><h2 id="low-memory-killer">low memory killer</h2><blockquote><p>详细介绍参考：https://developer.android.com/games/optimize/vitals/lmk?hl=zh-cn</p></blockquote><p><img src="2025-07-09T232219.png"alt="Android 进程，从上到下，优先级递增" /><br /></p><p>lmk的原理是根据进程的优先级，在内存不足时，优先杀死优先级低的进程。所以一般在前台游戏进程分配过多内存时，优先杀掉了后台进程，如果内存分配还在继续，则肯呢个会影响到声音、桌面，甚至杀掉当前前台进程，如果前台进程被杀掉时，内存分配没有来得及释放，则可能会导致系统崩溃，也就是最高到System 这一级别。Native 内核层不会受影响。</p><p>lmk通常受到忽略，比如后台被杀掉的其他进程，或者音乐停了，但是游戏还在运行。但我们仍然需要关注，这变向地暴露了游戏内存的过多分配。</p><h2 id="内存指标">内存指标</h2><ul><li>RSS：Resident Set Size，常驻内存。</li><li>PSS：Proportional Set Size，比例内存。</li><li>USS：Unique Set Size，唯一内存。</li></ul><p>RSS 是你的应用占用的内存 +由于调用公共库，公共库所分配出来的内存。PSS 和 RSS类似，但是会根据公共库的共享程度进行比例分配，比如公共库被 10个进程使用，它被分配了 10MB 的内存，那么每个进程的 PSS 就是 1MB。USS是你的应用占用的内存，不包括公共库的内存。</p><p>所以一般如果我们 RSS 高但 USS低，说明我们调用了某个复杂度较高的公共库。这些内存指标可以通过 Procrank工具（一款用于 Android 平台的内存分析工具）查看。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概览&quot;&gt;概览&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;物理内存
&lt;ul&gt;
&lt;li&gt;CPU 访问内存是一个慢速过程
&lt;ul&gt;
&lt;li&gt;减少 Cache miss&lt;/li&gt;
&lt;li&gt;ECS 和 DOTS&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;移动设备与台式设备</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"/>
    
    <category term="Unity内存管理" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Unity" scheme="https://peiyuzou.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>03.协议族和套接字类型</title>
    <link href="https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/03.%E5%8D%8F%E8%AE%AE%E6%97%8F%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B/"/>
    <id>https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/03.%E5%8D%8F%E8%AE%AE%E6%97%8F%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-07-04T03:38:58.000Z</published>
    <updated>2025-07-08T12:03:55.536Z</updated>
    
    <content type="html"><![CDATA[<p>在创建套接字的时候，我们调用了 <code>socket</code>函数，函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">SOCKET <span class="title function_">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><ul><li>af: 套接字使用的地址族（Address Family）或者协议族（ProtocolFamily）</li><li>type: 套接字传输类型</li><li>protocol：最终使用的协议</li></ul><h1 id="协议族protocol-family">协议族（Protocol Family）</h1><p>以下是协议族的部分分类：</p><table><thead><tr><th>名称</th><th>协议族</th></tr></thead><tbody><tr><td>PF_INET</td><td>IPv4互联网协议族</td></tr><tr><td>PF_INET6</td><td>IPv6互联网协议族</td></tr><tr><td>PF_LOCAL</td><td>本地通信的UNIX协议族</td></tr><tr><td>PF_PACKET</td><td>底层套接字的协议族</td></tr><tr><td>PF_IPX</td><td>IPX Novell协议族</td></tr></tbody></table><p>只需关心 PF_INET 即可，例子中会用到它</p><h1 id="套接字类型">套接字类型</h1><p>这个参数指定了数据传输方式，这里介绍两种最具代表性的：SOCK_STREAM 和SOCK_DGRAM</p><h2 id="sock_stream">1.SOCK_STREAM</h2><p>SOCK_STREAM 又称为面向连接的套接字。它有以下特性：</p><ul><li>基于连接：传输端和接收端必须一一对应（端对端传输），且需要先建立连接</li><li>数据可靠：保证数据不丢失且按序到达</li><li>数据边界：无消息边界，数据以字节流的形式传输</li><li>对应协议：TCP</li></ul><h2 id="sock_dgram">2.SOCK_DGRAM</h2><p>SOCK_DGRAM 又称为面向消息的套接字。它有以下特性：</p><ul><li>基于消息：不需要建立连接，直接发送</li><li>数据不可靠：可能丢包、重复、乱序</li><li>数据边界：有消息边界，一次发送的数据是一整个报文</li><li>对应协议：UDP</li></ul><h1 id="最终协议的选择">最终协议的选择</h1><p>其实通过接口签名的前两个参数进行组合，大多数情况下程序就已经可以得到最终的协议了，比如，PF_INET+ SOCK_STREAM 可以确定用户要使用 TCP 协议，所以这种情况下第三个参数传 0也可以。</p><p>但是存在前两个参数组合也无法确认最终协议的情况：在同一个协议族中，存在多个使用相同传输方式的协议。</p><p>所以这里设计了第三个参数，用来指定这个最终的协议，所以使用 TCP 的Socket 也可以这么写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hSocket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br></pre></td></tr></table></figure><h1 id="af-和-pf">AF 和 PF ?</h1><p>在上述的 socket 函数签名中，第一个参数是 af，但是我们实际调用的时候，传入的是 PF_INET：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数签名</span></span><br><span class="line">SOCKET <span class="title function_">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际调用</span></span><br><span class="line">hSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>要解释这个传参的问题，要先从 AF 和 PF 本身讲起。</p><ul><li>AF (Address Family) 指地址族，强调地址类型，比如 IPv4 在 AF中指的是地址类型为 IPv4</li><li>PF (Protocol Family) 指协议族，IPv4 在 PF 中强调的是协议类型为IPv4</li></ul><p>从语义来说，这个函数的签名要求传入的是地址类型，但是我们之所以可以传入PF_INET 的原因是：在 Winsock 和大多数系统中，AF_XXX 和 PF_XXX是同一个值！如下图的定义：</p><p><img src="AF_PF_Define.png" alt="AF 和 PF 的相关定义" /><br /></p><p>这本质上是历史语义的问题，在实际的使用中，无论是 AF 还是 PF都不会出现问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在创建套接字的时候，我们调用了 &lt;code&gt;socket&lt;/code&gt;
函数，函数签名如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;</summary>
      
    
    
    
    <category term="08-网络编程" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Socket" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/"/>
    
    
  </entry>
  
  <entry>
    <title>02.使用C语言实现一个WinSock简易例子</title>
    <link href="https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/02.%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWinSock%E7%AE%80%E6%98%93%E4%BE%8B%E5%AD%90/"/>
    <id>https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/02.%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWinSock%E7%AE%80%E6%98%93%E4%BE%8B%E5%AD%90/</id>
    <published>2025-07-02T05:56:32.000Z</published>
    <updated>2025-07-04T03:26:40.928Z</updated>
    
    <content type="html"><![CDATA[<p>WinSock 是指 Windows Socket，是 Windows 平台的套接字。</p><h1 id="服务端代码">服务端代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello_server.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接ws2_32.lib库，提供Windows Socket API</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    WSADATA wsaData;                <span class="comment">// Windows Socket库信息结构体</span></span><br><span class="line">    SOCKET hServSock, hClntSock;    <span class="comment">// 服务器socket句柄和客户端socket句柄</span></span><br><span class="line">    SOCKADDR_IN servAddr, clntAddr; <span class="comment">// 服务器和客户端地址信息结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> szClntAddt;                 <span class="comment">// 客户端地址结构体大小</span></span><br><span class="line">    <span class="type">char</span> message[] = <span class="string">&quot;nice day&quot;</span>;    <span class="comment">// 要发送给客户端的消息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查命令行参数数量，需要端口号</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Windows Socket库，请求版本2.2</span></span><br><span class="line">    <span class="keyword">if</span>(WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;WSAStartup() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP socket (PF_INET: IPv4, SOCK_STREAM: TCP, 0: 默认协议)</span></span><br><span class="line">    hServSock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(hServSock == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;socket() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置服务器地址信息</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servAddr));          <span class="comment">// 清零结构体</span></span><br><span class="line">    servAddr.sin_family = AF_INET;                   <span class="comment">// 设置地址族为IPv4</span></span><br><span class="line">    servAddr.sin_addr.s_addr = htonl(INADDR_ANY);    <span class="comment">// 绑定到所有可用网络接口</span></span><br><span class="line">    servAddr.sin_port = htons(atoi(argv[<span class="number">1</span>]));        <span class="comment">// 设置端口号并转换为网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将socket绑定到指定地址和端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(hServSock, (SOCKADDR*)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr)) == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;bind() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听连接请求，最大等待队列长度为5</span></span><br><span class="line">    <span class="keyword">if</span>(listen(hServSock, <span class="number">5</span>) == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;listen() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受客户端连接请求</span></span><br><span class="line">    szClntAddt = <span class="keyword">sizeof</span>(clntAddr);</span><br><span class="line">    hClntSock = accept(hServSock, (SOCKADDR*)&amp;clntAddr, &amp;szClntAddt);</span><br><span class="line">    <span class="keyword">if</span>(hClntSock == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;accept() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向客户端发送消息</span></span><br><span class="line">    send(hClntSock, message, <span class="keyword">sizeof</span>(message), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端和服务器socket，清理Windows Socket库</span></span><br><span class="line">    closesocket(hClntSock);</span><br><span class="line">    closesocket(hServSock);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理函数：打印错误信息并退出程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);  <span class="comment">// 输出错误信息到标准错误流</span></span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);     <span class="comment">// 换行</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);                 <span class="comment">// 退出程序，返回错误码1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="客户端代码">客户端代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello_client.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接ws2_32.lib库，提供Windows Socket API</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    WSADATA wsaData;        <span class="comment">// Windows Socket库信息结构体</span></span><br><span class="line">    SOCKET hSocket;         <span class="comment">// 客户端socket句柄</span></span><br><span class="line">    SOCKADDR_IN servAddr;   <span class="comment">// 服务器地址信息结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> message[<span class="number">30</span>];       <span class="comment">// 存储从服务器接收的消息</span></span><br><span class="line">    <span class="type">int</span> strLen = <span class="number">0</span>;         <span class="comment">// 累计接收的字节数</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, readLen = <span class="number">0</span>;  <span class="comment">// idx: 消息缓冲区索引, readLen: 单次接收的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查命令行参数数量，需要IP地址和端口号</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Windows Socket库，请求版本2.2</span></span><br><span class="line">    <span class="keyword">if</span>(WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;WSAStartup() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP socket (PF_INET: IPv4, SOCK_STREAM: TCP, 0: 默认协议)</span></span><br><span class="line">    hSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSocket == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;socket() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置服务器地址信息</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servAddr));              <span class="comment">// 清零结构体</span></span><br><span class="line">    servAddr.sin_family = AF_INET;                       <span class="comment">// 设置地址族为IPv4</span></span><br><span class="line">    servAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);       <span class="comment">// 设置服务器IP地址</span></span><br><span class="line">    servAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));            <span class="comment">// 设置端口号并转换为网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span>(connect(hSocket, (SOCKADDR*)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr)) == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐字节接收服务器发送的数据，直到连接关闭</span></span><br><span class="line">    <span class="keyword">while</span>(readLen = recv(hSocket, &amp;message[idx++], <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(readLen == <span class="number">-1</span>)  <span class="comment">// 接收出错</span></span><br><span class="line">        &#123;</span><br><span class="line">            ErrorHandling(<span class="string">&quot;recv() error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        strLen += readLen;  <span class="comment">// 累计接收的总字节数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印接收到的消息和总接收次数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from server : %s \n&quot;</span>, message);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function read call count : %d \n&quot;</span>, strLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭socket并清理Windows Socket库</span></span><br><span class="line">    closesocket(hSocket);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理函数：打印错误信息并退出程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);  <span class="comment">// 输出错误信息到标准错误流</span></span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);     <span class="comment">// 换行</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);                 <span class="comment">// 退出程序，返回错误码1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编译运行">编译运行</h1><p>注意需要链接 ws2_32.lib 库，有两种方法：</p><ul><li>通过 Visual Studio 等集成开发环境，设置附加依赖项，把 ws2_32.lib链接进来</li><li>在编译运行时，通过命令行链接</li></ul><p>编译链接的命令行如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello_client.c -o hClientWin -lws2_32</span><br></pre></td></tr></table></figure><p>意味编译 hello_client.c 并与 ws2_32.lib 链接，最终输出 hClientWin.exe文件。</p><p>运行服务端程序，指定一个端口号，会发现程序进入了等待状态，因为调用的<code>accept</code> 函数还未返回。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:<span class="title">NetCoding</span>\<span class="title">Socket</span>&gt;<span class="title">hServerWin</span> 9190</span></span><br><span class="line"><span class="function">(空白)</span></span><br></pre></td></tr></table></figure><p>接着运行客户端程序，指定对应的 ip 和port，命令行得到打印结果，同时服务端程序也运行完毕。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:<span class="title">NetCoding</span>\<span class="title">Socket</span>&gt;<span class="title">hClientWin</span> 127.0.0.1 9190</span></span><br><span class="line"><span class="function"><span class="title">Message</span> <span class="title">from</span> <span class="title">server</span> : <span class="title">nice</span> <span class="title">day</span></span></span><br><span class="line"><span class="function"><span class="title">Function</span> <span class="title">read</span> <span class="title">call</span> <span class="title">count</span> : 9</span></span><br></pre></td></tr></table></figure><h1 id="需要注意的点">需要注意的点</h1><p>在客户端代码中，是逐字节接收服务器发送的数据。其实这里可以根据实际需求调整，不一定是一个字节一个字节地接收。这里这样写是因为想要展示非对称的传输：我们使用了IPv4 + 流失传输的组合（下节介绍），符合这一组合的协议只有 TCP 协议，而TCP协议的传输是非对称的，即服务端的发送次数和客户端的接收次数不一定相等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;WinSock 是指 Windows Socket，是 Windows 平台的套接字。&lt;/p&gt;
&lt;h1 id=&quot;服务端代码&quot;&gt;服务端代码&lt;/h1&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</summary>
      
    
    
    
    <category term="08-网络编程" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Socket" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/"/>
    
    
  </entry>
  
</feed>
