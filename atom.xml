<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Per-Fragment</title>
  
  
  <link href="https://peiyuzou.github.io/atom.xml" rel="self"/>
  
  <link href="https://peiyuzou.github.io/"/>
  <updated>2025-07-11T01:43:50.040Z</updated>
  <id>https://peiyuzou.github.io/</id>
  
  <author>
    <name>Z.P.Y</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>01.Lz4压缩</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/01.Lz4/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/01.Lz4/</id>
    <published>2025-07-10T11:06:13.000Z</published>
    <updated>2025-07-11T01:43:50.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>LZ4 是一种无损压缩算法，提供每核 &gt; 500 MB/s的压缩速度，并可通过多核 CPU进行扩展。它具有极快的解码器，每核速度可达数 GB/s，通常会达到多核系统的RAM 速度极限。</p><p>作为 Unity AssetBundle 主推的压缩算法，它相比 Lzma拥有更快的速度（大约是 Lzma 的十倍以上）。并且是基于块压缩的（ChunkBased），可以按需选择加载部分块，而不用将整个文件全部加载，这对于内存来说是更友好的。唯一相较于Lzma 的劣势是压缩率，大约比 Lzma 高出 30%</p><h1 id="lz4-的原理">Lz4 的原理</h1><p>Lz4压缩后的文件由块组成，每一个压缩块则由若干序列组成，它的核心原理简单概括就是找出重复的字节序列，按照固定规则以更省空间的形式存储。先来看它的序列示意图：</p><p><img src="Lz4_Sequence.png" alt="Lz4的序列" /><br /></p><p>首先，开头的一个字节称为一个标记（Token），这个标记由两个 4位组成（因此值的范围从 0 到 15）</p><p>高 4位用于存储字面量（Literal）的长度，字面量是指压缩过程中无法被压缩的原始字节。由于4 位能表示的值范围有限，因此图中 Literal length+（图中黄色区域）用于支持更大的长度值的存储，这是一个可选的区域。如果 4位之内足够存储字面量的长度，这个区域就不存在，Token 之后会紧跟Literals（字面量）。如果该 4 位存储的值为 0，则代表没有字面量。如果为15（4 位全 1），则增加一个 Literal length+ 区域，其代表的值为 0 -255（一个字节的大小），此时字面量的长度 = 15 +这个字节的值。如果这个字节的值仍然满了（255），则继续增加一个新的字节，直到可以表示字面量的长度为止。（因此图中写的是0-n bytes）</p><p>这两个区域之后，则是字面量的存储区域，字面量是未压缩的字节，按原样复制。</p><p>紧接着是偏移量（Offset），这是一个两个字节的值（0-65535），它表示要从中复制匹配的位置。请注意，0是无效值，不会被使用。1 表示“当前位置 - 1字节”，另外需要注意，这个值使用小端格式存储（低位在前，高位在后）。通过偏移量，我们可以得到重复字节的起始位置</p><p>我们使用重复字节的起始位置加上匹配长度的值，就可以得到重复位置从哪个位置开始到哪个位置结束。匹配长度是指从在Token 的低 4位值存储，如果不够，再启用后面的可选区域，可选区域的规则和字面量长度的规则一致，但这里有一点细小的差异，匹配长度要求最小值为4，也就是说至少要 4个重复的字节才可以压缩，这应该是为了压缩率至少不能超过 1而设计的，毕竟压缩后变大了是不行的。这里存储的值如果为 0，代表匹配长度为4 个字节，如果值为 15，代表匹配长度为 19+个字节（可能启用了可选区域）</p><h1 id="进行一次计算">进行一次计算</h1><p><img src="Lz4_Exp.drawio.png" alt="原始字节序列" /><br /></p><p>假设我们有上面这个字节序列，其中每个字节编号一个索引，最大值是F（11111111），现在开始对它进行模拟压缩，步骤如下：</p><p><img src="Lz4.drawio.png" alt="模拟压缩步骤" /><br /></p><h2 id="压缩计算">压缩计算</h2><p>现在我们得到：</p><ul><li>字面量为[C, C, C, A, B, C, D, E, F, B, B, B]，长度为12。</li><li>偏移量为9</li><li>匹配长度为6</li></ul><p>首先第一个序列用来存储字面量：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Token：</span><br><span class="line">- 高 4 位：12（字面量长度，小于 15 无需额外字节）</span><br><span class="line">- 低 4 位：0（不存储匹配）</span><br><span class="line">Literals：[C, C, C, A, B, C, D, E, F, B, B, B]</span><br><span class="line">Offset：由于该序列仅表示字面量，因此不存储Offset</span><br></pre></td></tr></table></figure><p>第二个序列用来存储匹配数据：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">匹配信息:</span><br><span class="line">- 偏移量: 9</span><br><span class="line">- 匹配长度: 6</span><br><span class="line">Token:</span><br><span class="line">- 高4位: 0 (没有字面量)</span><br><span class="line">- 低4位: 2 (匹配长度 = 6-4 = 2)</span><br><span class="line">Token = 0x02</span><br><span class="line">偏移量编码: 0x0009 → 小端序 [0x09][0x00]</span><br></pre></td></tr></table></figure><p>得到最终压缩结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0xC0][C][C][C][A][B][C][D][E][F][B][B][B][0x02][0x09][0x00]</span><br><span class="line"></span><br><span class="line">原始数据: 18字节</span><br><span class="line">压缩数据: 16字节</span><br><span class="line">压缩率: 16/18 ≈ 88.9%</span><br><span class="line">节省: 2字节 (11.1%)</span><br></pre></td></tr></table></figure><h2 id="解压计算">解压计算</h2><p>解压Token1 (0xC0)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">字面量长度: 12</span><br><span class="line">匹配长度: 0</span><br><span class="line">操作: 复制12个字面量</span><br><span class="line">输出: C C C A B C D E F B B B</span><br></pre></td></tr></table></figure><p>解压Token2 (0x02)：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">字面量长度: 0</span><br><span class="line">匹配长度: 2+4 = 6</span><br><span class="line">偏移量: 9</span><br><span class="line">操作: 从位置3开始复制6个字节</span><br><span class="line">输出: A B C D E F (复制位置3-8)</span><br></pre></td></tr></table></figure><p>最终结果与原数据一致：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C C C A B C D E F B B B A B C D E F</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;概述&lt;/h1&gt;
&lt;p&gt;LZ4 是一种无损压缩算法，提供每核 &amp;gt; 500 MB/s
的压缩速度，并可通过多核 CPU
进行扩展。它具有极快的解码器，每核速度可达数 GB/s，通常会达到多核系统的
RAM 速度极限。&lt;/p&gt;
&lt;p&gt;作为 Uni</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="压缩算法" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Compression" scheme="https://peiyuzou.github.io/tags/Compression/"/>
    
  </entry>
  
  <entry>
    <title>05.Unity内存优化最佳实践</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/05.Unity%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/05.Unity%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2025-07-10T08:30:30.000Z</published>
    <updated>2025-07-10T08:30:39.063Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"/>
    
    <category term="Unity内存管理" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Unity" scheme="https://peiyuzou.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>04.Unity Managed Memory</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/04.Unity%20Managed%20Memory/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/04.Unity%20Managed%20Memory/</id>
    <published>2025-07-10T05:43:59.000Z</published>
    <updated>2025-07-10T08:18:00.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览">概览</h1><ul><li>VM 内存池<ul><li>VM 返回内存给操作系统的条件</li></ul></li><li>GC 机制<ul><li>GC 机制考量<ul><li>Throughput（回收能力）</li><li>Pause Times（暂停时长）</li><li>Fragmentation（碎片化）</li><li>Mutator overhead（额外消耗）</li><li>Scalability（可扩展性）</li><li>Portability（可移植性）</li></ul></li><li>使用的 GC<ul><li>Boehm<ul><li>Non-generaional</li><li>Non-compacting</li></ul></li><li>Incremental GC（渐进式GC）</li></ul></li><li>Memory fragmentation（内存碎片化）</li><li>Zombie Memory（僵尸内存）<ul><li>无用内存</li><li>没有释放</li><li>通过代码管理和性能工具分析</li></ul></li></ul></li></ul><h2 id="vm-内存池">VM 内存池</h2><p>Unity 编辑器进程自身使用 MonoVM，打包后的实际游戏进程根据脚本后端选择不同，使用 IL2Cpp Runtime 或者Mono VM。注意这里说的 VM 是指实际游戏进程使用的 VM。</p><p>Mono VM 的内存池，内存以 Block 的形式管理，当一个 Block 连续 6 次 GC没有被访问到，这块内存会被返回给系统，条件苛刻，比较难触发。</p><p>IL2CPP 更容易触发，因为它的内存管理更像一个传统 C++程序的内存管理模式。</p><blockquote><p>注意，GC 本身是不会把内存返还给操作系统的，它是回收给虚拟机。</p></blockquote><h2 id="unity-的-gc">Unity 的 GC</h2><h3 id="gc-机制的考量">1. GC 机制的考量</h3><ul><li>Throughput（回收能力）：一次GC能收回多少内存</li><li>Pause times（暂停时长）：GC时对主线程的影响会多大（卡顿）</li><li>Fragmentation（碎片化）：对整体内存池的碎片化影响多少</li><li>Mutatoroverhead（额外消耗）：GC时的消耗，GC时需要做很多的统计会产生消耗</li><li>Scalability（可拓展性）：拓展到多核多线程会不会有什么bug</li><li>Portability（可移植性）：在不同的平台上是否可以使用</li></ul><h3 id="boehm-gc-和-incremental-gc">2. Boehm GC 和 Incremental GC</h3><p>Unity 用的 Boehm GC，简单粗暴，不分代。它有以下特点：</p><ul><li>Non-generational（非分代式），即全都堆在一起，因为这样会很快。分代的话就是例如大内存，小内存，超小内存分在不同的内存区域来进行管理（SGenGC的设计思想）。</li><li>Non-Compacting（非压缩式），即当有内存被释放的时候，这块区域就空着。而压缩式的会重新排布，填充空白区域，使内存紧密排布。</li></ul><p>但目前 Unity 在 Mono 上已经使用 SGen GC （Scalable GenerationalGC，分代垃圾回收器）了，而 IL2CPP 则是嵌入了一个定制化后的 Boehm</p><p>结论如下表：</p><table><thead><tr><th>Unity后端</th><th>使用的GC</th><th>是否 Boehm</th><th>是否支持分代</th></tr></thead><tbody><tr><td>Mono（编辑器）</td><td>Mono SGen GC</td><td>非 Boehm</td><td>是</td></tr><tr><td>IL2CPP</td><td>Boehm GC（定制版）</td><td>是</td><td>否</td></tr><tr><td>DOTS/Burst</td><td>无托管堆</td><td>无GC</td><td>N/A</td></tr></tbody></table><p>Unity 另外实装了 IncrementalGC，主要解决主线程卡顿的问题，现在进行一次GC主线程被迫要停下来，遍历所有的Memory Island，决定哪些要被 GC掉，会造成一定时间的主线程卡顿。Incremental GC把前面暂停主线程的事分帧做了，这样主线程不会出现峰值。</p><h3 id="内存碎片化">3. 内存碎片化</h3><p>非压缩式的内存虽然快（避免了内存重新排布的时间消耗），但是容易造成内存碎片化。内存的碎片化容易间接内存异常上涨，比如内存总用量下降了，但是还在继续分配新的空间。例如，内存中有一些空白的内存区域时，分配了一块较大内存时，却没有任何的一个空间放得下（即使整体的空间足够），导致内存扩充很多。</p><p>因此建议在需要连续分配内存的情况下，先操作大内存，然后操作小内存，可以一定程度上减轻碎片化。</p><h3 id="僵尸内存">4. 僵尸内存</h3><p>这个和内存泄漏常被人搞混在一起。僵尸内存是指碎片化内存之间空出的内存，这部分内存可能成为僵尸内存。这种情况实际上并不是内存泄露，因为这些内存并没有被泄露，泄露指这块内存没有任何人可以访问和管理，但实际上这块内存一直在内存池里。</p><h1 id="managed-memory-最佳实践">Managed Memory 最佳实践</h1><h2 id="dont-null-it-destroy-it">1. Don’t Null it, Destroy it</h2><p>用 Destroy，别用 null，显示的调用 Destroy 才能真正的销毁掉。</p><h2 id="class-和-struct-不要混用">2. Class 和 Struct 不要混用</h2><p>这个不赘述</p><h2 id="pool-in-pool">3. Pool In Pool</h2><p>高频使用的部分自己建一个内存池去重用</p><h2 id="closures-and-anonymous-methods闭包和匿名函数">4. Closures andanonymous methods（闭包和匿名函数）</h2><p>所有的匿名函数和闭包在 C# 编 IL 代码时都会被 new 成一个Class（匿名class），所以在里面所有变量以及new的东西，都是要占内存的。</p><h2 id="coroutines协程">5. Coroutines（协程）</h2><p>协程属于闭包和匿名函数的特例，游戏开始启动一个协程直到游戏结束才释放，是错误的做法。因为协程只要没被释放，里面的所有变量，即使是局部变量（包括值类型），也都会在内存里。建议用的时候才生产一个协程，不用的时候就丢掉。</p><h2 id="configurations配置表">6. Configurations（配置表）</h2><p>全部配置表一下全部进内存也是不明智的，可以考虑分关加载等策略。</p><h2 id="singleton单例">7. Singleton（单例）</h2><p>慎用单例，不要什么都往里放，因为里面的变量会一直占用内存。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概览&quot;&gt;概览&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;VM 内存池
&lt;ul&gt;
&lt;li&gt;VM 返回内存给操作系统的条件&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;GC 机制
&lt;ul&gt;
&lt;li&gt;GC 机制考量
&lt;ul&gt;
&lt;li&gt;Throughput（回收能力）&lt;</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"/>
    
    <category term="Unity内存管理" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Unity" scheme="https://peiyuzou.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>03.Unity Native Memory</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/03.Unity%20Native%20Memory/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/03.Unity%20Native%20Memory/</id>
    <published>2025-07-10T02:19:51.000Z</published>
    <updated>2025-07-10T05:43:16.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览">概览</h1><ul><li>Native Memory 介绍<ul><li>Allocator与Memory Label</li><li>GetRuntimeMemory</li><li>NewAsRoot</li><li>会即时返还给操作系统</li></ul></li><li>Native Memory 最佳实践<ul><li>Scene</li><li>Audio<ul><li>DSP buffer</li><li>Force to mono</li><li>Format</li><li>Compression Format</li></ul></li><li>Code Size</li><li>AssetBundle<ul><li>TypeTree</li><li>Lz4 &amp; Lzma</li><li>Size &amp; Count</li></ul></li><li>Resources<ul><li>R-B Tree</li></ul></li><li>Texture<ul><li>upload buffer</li><li>r/w</li><li>Mip Maps</li></ul></li><li>Mesh<ul><li>r/w</li><li>Compression</li></ul></li><li>Assets</li></ul></li></ul><h1 id="native-memory-介绍">Native Memory 介绍</h1><h2 id="allocator与memory-label">1. Allocator与Memory Label</h2><p>Unity 在里面重载了 C++ 的所有分配内存的操作符，例如 alloc，new等。每个操作符在被使用的时候要求有一个额外的参数就是 Memory Label，在Memory Profiler （Windows/Analysis/Memory Profiler）中查看 MemoryDetails 里的 Name 很多就是 MemoryLabel。它指的就是当前的这一块内存内存要分配到哪个类型池里。</p><h2 id="getruntimememory">2. GetRuntimeMemory</h2><p>Unity 在底层会用 Allocator，使用重载过的分配符分配内存的时候，会根据Memory Label 分配到不同的 Allocator池 里面。每个 Allocator池，单独做自己的跟踪。当要在 Runtime 去 Get 一个 Memory Label下面池的时候，可以从对应的 Allocator中取，可以从中知道有什么东西，有多少兆。</p><h2 id="newasroot">3. NewAsRoot</h2><p>前面提到的 Allocator 的生成是使用 NewAsRoot，生成一个所谓的 MemoryIsland，它下面会有很多的子内存。例如一个 Shader，当加载一个 shader进内存的时候，首先会生成一个 shader 的 Root，也就是 Memory Island。然后Shader 底下的数据，例如 Subshader，Pass，Parameters 等，会作为该 Root底下的成员，依次的分配。所以最后统计 Runtime 的内存时，统计这些 Root即可。</p><h2 id="返还操作系统">4. 返还操作系统</h2><p>因为是 C++ 的，所以当 delete 或 free一个内存的时候，会立刻返回给系统。这和托管内存不一样，托管内存需要 GC后才返回。</p><h1 id="native-memory-最佳实践">Native Memory 最佳实践</h1><p>在使用Unity的时候，如果某些方面使用不当，会造成 Native Memory的增长，所以这部分也是可以优化调整的。</p><h2 id="scene">1. Scene</h2><p>首当其冲，最常见的导致 Native Memory 增长的原因，就是Scene。因为Unity 是 C++ 引擎，所有的实体最终都会反映在 C++上，而不会反映在托管堆上。所以当 Scene 构建一个 GameObject的时候，实际上在 Unity 的底层会构建一个或多个 Object 来存储这一个GameObject 的信息（Component信息等）。所以当一个 Scene 里面有过多的GameObject 存在的时候，Native Memory就会显著的上升，甚至可能导致内存溢出。</p><blockquote><p>所以这里有一个经验之谈：当发现 Native Memory大量上升时，首先去着重检查你的 Scene</p></blockquote><h2 id="audio">2. Audio</h2><h3 id="dsp-buffer">2.1 DSP buffer</h3><p>指一个声音的缓冲，当一个声音要播放的时候，需要向 CPU去发送指令。如果声音的数据量非常的小，会造成频繁的向 CPU 发指令，造成 IO压力。在 Unity 的 FMOD 声音引擎里面，一般会有一个 Buffer，当 Buffer填充满了才会去向 CPU 发送一次播放声音的指令。所以 DSPBuffer大小的设置非常考究，一般会导致两种问题：</p><ul><li>设置的值过大，会导致声音的延迟，因为填充满需要很多的声音数据，当我们声音数据不大的时候，就会产生延时。</li><li>设置的值过小，会导致 CPU 负担上升，因为会频繁的发送。</li></ul><h3 id="audio-import-settings">2.2 Audio Import Settings</h3><p><strong>Force ToMono</strong>：​这个选项作用是强制单声道，很多声音为了追求质量会设置成双声道，导致声音在包体和内存中，占用的空间加倍，但是95%以上的声音，两个声道是完全一样的数据。因此对声音不是很敏感的项目建议勾选此项，来降低内存的占用。<strong>CompressionFormat</strong>：不同的平台有不同的声音格式的支持，iOS 对 MP3有硬件支持，Android 暂时没有硬件支持。建议 iOS 使用 ADPCM 和 MP3格式，Android 使用 Vorbis 格式。 <strong>LoadType</strong>：决定声音在内存中的存在形态： - Decompress OnLoad：当audio clip被加载时，解压声音数据，适用于小型音频文件（&lt;200kb） - Compressed InMemory：声音数据将以压缩的形式保存在内存当中，适用于中型音频文件（&gt;=200kb） -Streaming：从磁盘读取声音数据，适用于大型音频文件，例如背景音</p><blockquote><p>注：<br> - Decompress On Load，要求文件必须小于200kb，因为内部内存管理的问题，如果是大于 200kb的文件，那么也还是只会被分配到不足 200kb 的内存。<br> -Bitrate：可以对音频文件本身进行压缩，降低文件的比特率（bitrate），前提音频品质不会被破坏太严重。</p></blockquote><h2 id="code-size">3. Code Size</h2><p>代码文件也是占内存的，需要加载进内存执行。一个典型的例子是模板泛型的滥用，例如一个模板函数有四五个不同的泛型参数，类型也不尽相同（float，int，double等），最后展开得到的一个cpp 文件可能会很大。因为实际上 C++ 编译的时候用的所有的 Class，所有的Template最终都会被展开成静态类型。因此当模板函数有很多排列组合时，最后编译会得到所有的排列组合代码，导致文件很大。</p><p>这不光会影响到最终代码文件的大小，导致 Native Memory间接增长，同时也会影响IL2CPP编译速度，接触过 C++ 编译应该知道，单一一个cpp文件编译的话是没办法并行的，只能单核处理，所以也间接地导致打包慢。</p><h2 id="assetbundle">4. AssetBundle</h2><h3 id="typetree">4.1 TypeTree</h3><p>这个东西存在是为了做这件事：Unity前后有很多的版本，不同的版本中很多的类型可能会有数据结构的改变，为了做数据结构的兼容，会在生成数据类型序列化的时候，顺便生成一个叫TypeTree的东西。就是当前这个版本用到了哪些变量，它们对应的数据类型是什么，当进行反序列化的时候，根据TypeTree 去做反序列化。如果上一个版本的类型在这个版本没有，那 TypeTree里就没有它，所以不会去碰到它。如果有新的TypeTree，但是在当前版本不存在的话，那要用它的默认值来序列化。从而保证了在不同版本之间不会序列化出错。</p><p>在构建 AssetBundle 的时候，可以通过以下代码关掉 TypeTree 的生成：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BuildAssetBundleOptions.DisableWriteTypeTree</span><br></pre></td></tr></table></figure><p>什么时候可以关呢？当你可以保证构建 AssetBundle 的 Unity版本和使用它的Unity的版本是一模一样的时候（对兼容性不会有影响），就可以关闭。这样有三个好处：一、可以减少内存；二、AssetBundle包大小会减少；三、build 和 Runtime 会变快，因为不会去序列化和反序列化TypeTree（如果开了 TypeTree，序列化会做两步，首先去序列化TypeTree，然后再去序列化实际的东西，反序列化也一样）</p><h3 id="压缩方式lz4-和-lzma">4.2 压缩方式（Lz4 和 Lzma）</h3><p>Unity 目前主推Lz4（也就是ChunkBased，BuildAssetBundleOptions.ChunkBasedCompression），Lz4非常快，大概是 Lzma 的十倍以上的速度，但平均压缩比例比 Lzma 差 30%左右，即包体更大。但 Lzma 基本可以不用了，因为 Lzma解压和读取速度都非常慢，并且内存占比高，因为它的读取不是基于ChunkBased，而是 Stream，也就是一次全解压出来。ChunkBased可以逐块解压，每次解压可以重用之前的内存，减少内存的峰值。</p><blockquote><p>Lz4目前是开源的，可以了解下它的原理：https://github.com/lz4/lz4</p></blockquote><h3 id="大小和数量">4.3 大小和数量</h3><p>AssetBundle分两部分，一部分是头（用于索引），一部分是实际的打包的数据部分。如果每个Asset 都单独打成一个AssetBundle，那么可能所有问题加起来头的部分比数据还大。所以这个大小不适合太大也不能太小，官方建议一个AssetBundle在1-2M，但是现在进入 5g 时代的话，可以适当加大，因为网络带宽更大了。</p><h2 id="resources">5. Resources</h2><p>如果使用 Resources 模式打包，Resources文件夹里的内容被打进包的时候会做一个红黑树（R-BTree）用做索引，即检索资源到底在什么位置。所以Resource越大，红黑树越大，它不可卸载，并在刚刚加载游戏的时候就会被一直加在内存里，极大的拖慢游戏的启动时间，因为红黑树没有分析和加载完，游戏是不会启动的，并造成持续的内存压力。所以建议不要使用Resource，使用AssetBundle。</p><h2 id="texture">6. Texture</h2><ul><li>Upload Buffer：和声音的Buffer类似，填满后向 GPU push 一次</li><li>Read/Write：没必要的话就关闭，正常情况，Texture 读进内存解析完了搁到Upload Buffer 里之后，内存里那部分就会 delete掉。除非开了Read/Write，那就不会 delete了，会在显存和内存里各一份。前面说过手机内存显存通用的，所以内存里会有两份。</li><li>​Mip Maps：例如 UI元素这类相对于相机Z轴的值不会有任何变化的纹理，关闭该选项。</li><li>Alpha Source：对于不透明纹理，关闭其alpha通道。 ​​- MaxSize：根据平台不同，纹理的Max Size设成该平台最小值。</li><li>POT：纹理的大小尽量为2的幂次方（POT），因为有些压缩格式可能不支持非2的幂次方的。</li><li>压缩格式：<ul><li>Android<ul><li>支持 OpenGL ES 3.0 的使用 ETC2，RGB 压缩为 RGB Compressed ETC24bits，RGBA 压缩为 RGBA Compressed ETC2 8bits</li><li>需要兼容 OpenGL ES 2.0 的使用 ETC，RGB 压缩为 RGB Compressed ETC4bits，RGBA 压缩为 RGBA 16bits。（压缩大小不能接受的情况下，压缩为 2 张RGB Compressed ETC 4bits）</li><li>目前主流正在从 ETC2 向 ASTC转变，后者的压缩质量和大小上都有优势。它支持 OpenGL ES 3.1 和部分 OpenGLES 3.0 的设备。目前市面上绝大多数安卓设备都支持，已经可以普及使用</li></ul></li><li>iOS<ul><li>支持 OpenGL ES 3.0 的使用ASTC，RGB 压缩为RGB CompressedASTC 6x6block，RGBA 压缩为 RGBA Compressed ASTC 4x4 block。</li><li>对于法线贴图的压缩精度较高可以选择 RGB CompressedASTC 5x5block。</li><li>需要兼容OpenGLES 2.0 的使用 PVRTC，RGB 压缩为PVRTC 4bits，RGBA压缩为RGBA 16bits。（压缩大小不能接受的情况下，压缩为 2 张 RGB CompressedPVRTC 4bits）</li><li>截止目前 ASTC 合并了 RGB 和 RGBA格式，压缩格式的选择上面更加方便了</li></ul></li></ul></li></ul><h2 id="mesh">7. Mesh</h2><ul><li>Read/Write：同Texture，若开启，Unity会存储两份Mesh，导致运行时的内存用量变成两倍。</li><li>Compression：Mesh Compression是使用压缩算法将Mesh数据进行压缩，结果是会减少占用硬盘的空间，但是在Runtime的时候会被解压为原始精度的数据，因此内存占用并不会减少。需要注意的是有些版本开了，实际解压之后内存占用大小会更严重。</li><li>Rig：如果没有使用动画，请关闭Rig，例如房子，石头这些。</li><li>​​Blendshapes：如果没有用到Blendshapes，也关闭。</li><li>Material设置：如果Material没有用到法向量和切线信息，关闭可以减少额外信息。</li></ul><h2 id="assets">8. Assets</h2><p>和整个的 Asset 管理有关系，Unity官网上有关于资源管理的文章，找到再补充。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概览&quot;&gt;概览&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Native Memory 介绍
&lt;ul&gt;
&lt;li&gt;Allocator与Memory Label&lt;/li&gt;
&lt;li&gt;GetRuntimeMemory&lt;/li&gt;
&lt;li&gt;NewAsRoot&lt;/li&gt;
&lt;li&gt;会</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"/>
    
    <category term="Unity内存管理" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Unity" scheme="https://peiyuzou.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>02.Unity内存管理</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/02.Unity%E5%86%85%E5%AD%98%E7%AE%80%E4%BB%8B/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/02.Unity%E5%86%85%E5%AD%98%E7%AE%80%E4%BB%8B/</id>
    <published>2025-07-09T15:39:20.000Z</published>
    <updated>2025-07-10T02:03:41.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览">概览</h1><ul><li>Unity 是一个 C++ 引擎<ul><li>底层代码完全由 C++ 实现</li><li>通过 Wrapper 提供给用户 API</li><li>用户代码会转换为 Cpp 代码（IL2CPP）</li><li>VM 仍然存在（解决跨平台问题）</li></ul></li><li>Unity 的内存<ul><li>按照分配方式分为：<ul><li>Native Memory</li><li>Managed Memory</li><li>Editor &amp; Runtime 是不同的</li></ul></li><li>按照管理方式分为：<ul><li>引擎管理的内存</li><li>用户管理的内存</li></ul></li><li>Unity 监测不到的内存<ul><li>用户的 Native 代码</li><li>Lua</li></ul></li></ul></li></ul><h1 id="unity-引擎概述">Unity 引擎概述</h1><p>Unity 是一个 C++ 引擎，并不是 C# 引擎，底层代码全部是由 C++写的，除了一些 Editor 里面的 Services 可能会用到 NodeJS这些网络的语言，Runtime 里面用到的每行 Unity 底层代码都是 C++ 的。</p><p>Unity 实际上分为三层：</p><ul><li>最底层是 Runtime，全是 Native C++ 代码。</li><li>最上层是 C#，Unity 本身也有一些 C#，例如 Unity 的 Editor 是用 C#写的，还有些 Package 也是 C# 写的。</li><li>中间还有一层叫 Binding，可以看见很多的 .bindings.cs 文件（基于 C# 的binding 语言，一开始是 Unity 自定义的一种语言），这些文件的作用就是把C++ 和 C# 联系在一起，为 C# 层提供所有的 API。因此使用 Unity 时看见的 C#API，都是在 Binding 层中自定义的。这些文件底层运行的时候还是 C++，只是个Wrapper（封装）。</li></ul><p>最早用户代码是运行在 C# 上，是 MonoRuntime。现在可以通过 IL2CPP将其转成 C++ 代码，所以现在几乎没有纯正的 C# 在运行了。</p><p>Unity 的 VM（虚拟机：VirtualMachine）依旧还是存在，主要用于跨平台，有了一层 VM抽象后，跨平台的工作会容易很多，IL2CPP 本质也是 VM。</p><h1 id="unity-的内存">Unity 的内存</h1><p>Unity的内存，可以从以下几个层面去理解</p><h2 id="按照分配方式划分">1. 按照分配方式划分</h2><p>按照分配方式分为：Native Memory（原生内存）和ManagedMemory（托管内存）。Native Memory并不会被系统自动管理，需要手动去释放。而 Managed Memory的内存管理是自动的，会通过 GC 来释放。</p><p>此外 Unity 在 Editor 和 Runtime下，内存的管理方式是不同的，除了内存大小不同，内存的分配时机以及分配方式也不同。例如Asset，在Runtime 时，只有用户代码 Load 的时候才会进内存。而 Editor模式下，为了编辑的便利性，只要打开 Unity就会进内存（所以打开很慢）。后续有推出 Asset Pipeline2.0，一开始导入一些基本的 Asset，剩下的 Asset只有使用的时候才会导入，这样即使是很大的工程，也可以尽量减少使用者对不关心的Asset 付出导入时间的代价。</p><h2 id="按照内存管理方式划分">2. 按照内存管理方式划分</h2><p>按照管理方式分为：引擎管理内存和用户管理内存。引擎管理内存即引擎运行的时候分配的一些内存，例如很多的Manager和Singleton，这些内存开发者一般是碰触不到的。用户管理内存也就是开发者开发时使用到的内存，是我们平时接触最多的部分。</p><h2 id="unity-监测不到的内存">3. Unity 监测不到的内存</h2><ul><li>用户分配的Native内存。比如自己写的Native插件（C++插件）导入Unity，这部分Unity是检测不到的，因为Unity没法分析已编译的C++是如何分配和使用内存的</li><li>Lua，它完全自己管理的，Unity也没法统计到它内部的情况</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概览&quot;&gt;概览&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Unity 是一个 C++ 引擎
&lt;ul&gt;
&lt;li&gt;底层代码完全由 C++ 实现&lt;/li&gt;
&lt;li&gt;通过 Wrapper 提供给用户 API&lt;/li&gt;
&lt;li&gt;用户代码会转换为 Cpp 代码（IL2CPP）&lt;/</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"/>
    
    <category term="Unity内存管理" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Unity" scheme="https://peiyuzou.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>01.什么是内存</title>
    <link href="https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/01.%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98/"/>
    <id>https://peiyuzou.github.io/wiki/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/01.%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98/</id>
    <published>2025-07-09T14:38:36.000Z</published>
    <updated>2025-07-10T01:40:39.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概览">概览</h1><ul><li>物理内存<ul><li>CPU 访问内存是一个慢速过程<ul><li>减少 Cache miss</li><li>ECS 和 DOTS</li></ul></li><li>移动设备与台式设备内存架构差异<ul><li>没有独立显卡</li><li>没有独立显存</li><li>CPU 板载面积更小，缓存级数更少，缓存大小更小</li></ul></li></ul></li><li>虚拟内存<ul><li>内存交换<ul><li>PC 设备支持</li><li>移动设备不支持</li></ul></li><li>内存压缩<ul><li>iOS 支持</li><li>Android 不支持</li></ul></li></ul></li><li>内存寻址范围<ul><li>32 位 CPU 和 64 位 CPU的寻址范围不一定谁更大（但可以普遍认为后者更大）</li></ul></li><li>Android 内存管理<ul><li>内存基本单位：Page</li><li>内存杀手：low memory killer</li><li>内存指标：RSS、PSS、USS</li></ul></li></ul><h1 id="物理内存">物理内存</h1><p>物理内存关注两个点：CPU访问内存是一个慢速过程、理解移动设备的内存架构差异。这里只解释前者，后者比较简单，看大纲即可。</p><p>CPU 在访问内存之前，会先去依次访问 L1、L2、L3Cache，如果没有得到想要的数据（称为一次 CacheMiss），则会访问主内存，然后回到Cache。整个这个过程是比较慢的，如果执行指令或者内存地址不连续，这个过程会导致大量的Cache Miss，造成大量的主内存和 Cache之间的交换，大量的时间会被浪费在内存的读取上。</p><p>所以物理内存的一个核心问题是如何减少 Cache Miss。Unity 推出的 DOTS技术的一个理念就是把不连续的内存尽量变为连续的内存，以此减少 CacheMiss。</p><h1 id="虚拟内存">虚拟内存</h1><p>内存交换是指设备将无用的内存数据写入到硬盘，以腾出内存空间的行为。PC设备支持内存交换，移动设备不支持，不支持的原因有以下两点：</p><ul><li>移动设备的 IO 性能较差，做内存交换会严重影响性能</li><li>移动设备的外置存储可擦写次数较少，频繁的内存交换会减少外置存储的寿命</li></ul><p>为了解决这个问题，iOS支持了内存压缩，大致原理是把无用的内存数据压缩起来放到指定位置，以此节省内存空间。</p><h1 id="android-内存管理">Android 内存管理</h1><p>Android 是基于 Linux 的操作系统，所以 Android 的内存管理与 Linux的内存管理是类似的。</p><h2 id="内存基本单位">内存基本单位</h2><p>它的内存基本单位是一个 Page，大小为 4KB（不代表所有数据是按照 4KB进行内存对齐）。回收和分配以 Page为单位。内存空间分为内核态和用户态，内核态的内存是用户态严格禁止访问的。</p><h2 id="low-memory-killer">low memory killer</h2><blockquote><p>详细介绍参考：https://developer.android.com/games/optimize/vitals/lmk?hl=zh-cn</p></blockquote><p><img src="2025-07-09T232219.png"alt="Android 进程，从上到下，优先级递增" /><br /></p><p>lmk的原理是根据进程的优先级，在内存不足时，优先杀死优先级低的进程。所以一般在前台游戏进程分配过多内存时，优先杀掉了后台进程，如果内存分配还在继续，则肯呢个会影响到声音、桌面，甚至杀掉当前前台进程，如果前台进程被杀掉时，内存分配没有来得及释放，则可能会导致系统崩溃，也就是最高到System 这一级别。Native 内核层不会受影响。</p><p>lmk通常受到忽略，比如后台被杀掉的其他进程，或者音乐停了，但是游戏还在运行。但我们仍然需要关注，这变向地暴露了游戏内存的过多分配。</p><h2 id="内存指标">内存指标</h2><ul><li>RSS：Resident Set Size，常驻内存。</li><li>PSS：Proportional Set Size，比例内存。</li><li>USS：Unique Set Size，唯一内存。</li></ul><p>RSS 是你的应用占用的内存 +由于调用公共库，公共库所分配出来的内存。PSS 和 RSS类似，但是会根据公共库的共享程度进行比例分配，比如公共库被 10个进程使用，它被分配了 10MB 的内存，那么每个进程的 PSS 就是 1MB。USS是你的应用占用的内存，不包括公共库的内存。</p><p>所以一般如果我们 RSS 高但 USS低，说明我们调用了某个复杂度较高的公共库。这些内存指标可以通过 Procrank工具（一款用于 Android 平台的内存分析工具）查看。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概览&quot;&gt;概览&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;物理内存
&lt;ul&gt;
&lt;li&gt;CPU 访问内存是一个慢速过程
&lt;ul&gt;
&lt;li&gt;减少 Cache miss&lt;/li&gt;
&lt;li&gt;ECS 和 DOTS&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;移动设备与台式设备</summary>
      
    
    
    
    <category term="05-游戏编程" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Unity" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/"/>
    
    <category term="Unity内存管理" scheme="https://peiyuzou.github.io/categories/05-%E6%B8%B8%E6%88%8F%E7%BC%96%E7%A8%8B/Unity/Unity%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Unity" scheme="https://peiyuzou.github.io/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>03.协议族和套接字类型</title>
    <link href="https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/03.%E5%8D%8F%E8%AE%AE%E6%97%8F%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B/"/>
    <id>https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/03.%E5%8D%8F%E8%AE%AE%E6%97%8F%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B/</id>
    <published>2025-07-04T03:38:58.000Z</published>
    <updated>2025-07-08T12:03:55.536Z</updated>
    
    <content type="html"><![CDATA[<p>在创建套接字的时候，我们调用了 <code>socket</code>函数，函数签名如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">SOCKET <span class="title function_">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br></pre></td></tr></table></figure><ul><li>af: 套接字使用的地址族（Address Family）或者协议族（ProtocolFamily）</li><li>type: 套接字传输类型</li><li>protocol：最终使用的协议</li></ul><h1 id="协议族protocol-family">协议族（Protocol Family）</h1><p>以下是协议族的部分分类：</p><table><thead><tr><th>名称</th><th>协议族</th></tr></thead><tbody><tr><td>PF_INET</td><td>IPv4互联网协议族</td></tr><tr><td>PF_INET6</td><td>IPv6互联网协议族</td></tr><tr><td>PF_LOCAL</td><td>本地通信的UNIX协议族</td></tr><tr><td>PF_PACKET</td><td>底层套接字的协议族</td></tr><tr><td>PF_IPX</td><td>IPX Novell协议族</td></tr></tbody></table><p>只需关心 PF_INET 即可，例子中会用到它</p><h1 id="套接字类型">套接字类型</h1><p>这个参数指定了数据传输方式，这里介绍两种最具代表性的：SOCK_STREAM 和SOCK_DGRAM</p><h2 id="sock_stream">1.SOCK_STREAM</h2><p>SOCK_STREAM 又称为面向连接的套接字。它有以下特性：</p><ul><li>基于连接：传输端和接收端必须一一对应（端对端传输），且需要先建立连接</li><li>数据可靠：保证数据不丢失且按序到达</li><li>数据边界：无消息边界，数据以字节流的形式传输</li><li>对应协议：TCP</li></ul><h2 id="sock_dgram">2.SOCK_DGRAM</h2><p>SOCK_DGRAM 又称为面向消息的套接字。它有以下特性：</p><ul><li>基于消息：不需要建立连接，直接发送</li><li>数据不可靠：可能丢包、重复、乱序</li><li>数据边界：有消息边界，一次发送的数据是一整个报文</li><li>对应协议：UDP</li></ul><h1 id="最终协议的选择">最终协议的选择</h1><p>其实通过接口签名的前两个参数进行组合，大多数情况下程序就已经可以得到最终的协议了，比如，PF_INET+ SOCK_STREAM 可以确定用户要使用 TCP 协议，所以这种情况下第三个参数传 0也可以。</p><p>但是存在前两个参数组合也无法确认最终协议的情况：在同一个协议族中，存在多个使用相同传输方式的协议。</p><p>所以这里设计了第三个参数，用来指定这个最终的协议，所以使用 TCP 的Socket 也可以这么写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hSocket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br></pre></td></tr></table></figure><h1 id="af-和-pf">AF 和 PF ?</h1><p>在上述的 socket 函数签名中，第一个参数是 af，但是我们实际调用的时候，传入的是 PF_INET：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数签名</span></span><br><span class="line">SOCKET <span class="title function_">socket</span><span class="params">(<span class="type">int</span> af, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际调用</span></span><br><span class="line">hSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>要解释这个传参的问题，要先从 AF 和 PF 本身讲起。</p><ul><li>AF (Address Family) 指地址族，强调地址类型，比如 IPv4 在 AF中指的是地址类型为 IPv4</li><li>PF (Protocol Family) 指协议族，IPv4 在 PF 中强调的是协议类型为IPv4</li></ul><p>从语义来说，这个函数的签名要求传入的是地址类型，但是我们之所以可以传入PF_INET 的原因是：在 Winsock 和大多数系统中，AF_XXX 和 PF_XXX是同一个值！如下图的定义：</p><p><img src="AF_PF_Define.png" alt="AF 和 PF 的相关定义" /><br /></p><p>这本质上是历史语义的问题，在实际的使用中，无论是 AF 还是 PF都不会出现问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在创建套接字的时候，我们调用了 &lt;code&gt;socket&lt;/code&gt;
函数，函数签名如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;</summary>
      
    
    
    
    <category term="08-网络编程" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Socket" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/"/>
    
    
  </entry>
  
  <entry>
    <title>02.使用C语言实现一个WinSock简易例子</title>
    <link href="https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/02.%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWinSock%E7%AE%80%E6%98%93%E4%BE%8B%E5%AD%90/"/>
    <id>https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/02.%E4%BD%BF%E7%94%A8C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAWinSock%E7%AE%80%E6%98%93%E4%BE%8B%E5%AD%90/</id>
    <published>2025-07-02T05:56:32.000Z</published>
    <updated>2025-07-04T03:26:40.928Z</updated>
    
    <content type="html"><![CDATA[<p>WinSock 是指 Windows Socket，是 Windows 平台的套接字。</p><h1 id="服务端代码">服务端代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello_server.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接ws2_32.lib库，提供Windows Socket API</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    WSADATA wsaData;                <span class="comment">// Windows Socket库信息结构体</span></span><br><span class="line">    SOCKET hServSock, hClntSock;    <span class="comment">// 服务器socket句柄和客户端socket句柄</span></span><br><span class="line">    SOCKADDR_IN servAddr, clntAddr; <span class="comment">// 服务器和客户端地址信息结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> szClntAddt;                 <span class="comment">// 客户端地址结构体大小</span></span><br><span class="line">    <span class="type">char</span> message[] = <span class="string">&quot;nice day&quot;</span>;    <span class="comment">// 要发送给客户端的消息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查命令行参数数量，需要端口号</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: %s &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Windows Socket库，请求版本2.2</span></span><br><span class="line">    <span class="keyword">if</span>(WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;WSAStartup() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP socket (PF_INET: IPv4, SOCK_STREAM: TCP, 0: 默认协议)</span></span><br><span class="line">    hServSock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(hServSock == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;socket() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置服务器地址信息</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servAddr));          <span class="comment">// 清零结构体</span></span><br><span class="line">    servAddr.sin_family = AF_INET;                   <span class="comment">// 设置地址族为IPv4</span></span><br><span class="line">    servAddr.sin_addr.s_addr = htonl(INADDR_ANY);    <span class="comment">// 绑定到所有可用网络接口</span></span><br><span class="line">    servAddr.sin_port = htons(atoi(argv[<span class="number">1</span>]));        <span class="comment">// 设置端口号并转换为网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将socket绑定到指定地址和端口</span></span><br><span class="line">    <span class="keyword">if</span>(bind(hServSock, (SOCKADDR*)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr)) == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;bind() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始监听连接请求，最大等待队列长度为5</span></span><br><span class="line">    <span class="keyword">if</span>(listen(hServSock, <span class="number">5</span>) == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;listen() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受客户端连接请求</span></span><br><span class="line">    szClntAddt = <span class="keyword">sizeof</span>(clntAddr);</span><br><span class="line">    hClntSock = accept(hServSock, (SOCKADDR*)&amp;clntAddr, &amp;szClntAddt);</span><br><span class="line">    <span class="keyword">if</span>(hClntSock == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;accept() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向客户端发送消息</span></span><br><span class="line">    send(hClntSock, message, <span class="keyword">sizeof</span>(message), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭客户端和服务器socket，清理Windows Socket库</span></span><br><span class="line">    closesocket(hClntSock);</span><br><span class="line">    closesocket(hServSock);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理函数：打印错误信息并退出程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);  <span class="comment">// 输出错误信息到标准错误流</span></span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);     <span class="comment">// 换行</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);                 <span class="comment">// 退出程序，返回错误码1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="客户端代码">客户端代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hello_client.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链接ws2_32.lib库，提供Windows Socket API</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    WSADATA wsaData;        <span class="comment">// Windows Socket库信息结构体</span></span><br><span class="line">    SOCKET hSocket;         <span class="comment">// 客户端socket句柄</span></span><br><span class="line">    SOCKADDR_IN servAddr;   <span class="comment">// 服务器地址信息结构体</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> message[<span class="number">30</span>];       <span class="comment">// 存储从服务器接收的消息</span></span><br><span class="line">    <span class="type">int</span> strLen = <span class="number">0</span>;         <span class="comment">// 累计接收的字节数</span></span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>, readLen = <span class="number">0</span>;  <span class="comment">// idx: 消息缓冲区索引, readLen: 单次接收的字节数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查命令行参数数量，需要IP地址和端口号</span></span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage : %s &lt;IP&gt; &lt;port&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Windows Socket库，请求版本2.2</span></span><br><span class="line">    <span class="keyword">if</span>(WSAStartup(MAKEWORD(<span class="number">2</span>,<span class="number">2</span>), &amp;wsaData) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;WSAStartup() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP socket (PF_INET: IPv4, SOCK_STREAM: TCP, 0: 默认协议)</span></span><br><span class="line">    hSocket = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSocket == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;socket() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置服务器地址信息</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servAddr, <span class="number">0</span>, <span class="keyword">sizeof</span>(servAddr));              <span class="comment">// 清零结构体</span></span><br><span class="line">    servAddr.sin_family = AF_INET;                       <span class="comment">// 设置地址族为IPv4</span></span><br><span class="line">    servAddr.sin_addr.s_addr = inet_addr(argv[<span class="number">1</span>]);       <span class="comment">// 设置服务器IP地址</span></span><br><span class="line">    servAddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));            <span class="comment">// 设置端口号并转换为网络字节序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="keyword">if</span>(connect(hSocket, (SOCKADDR*)&amp;servAddr, <span class="keyword">sizeof</span>(servAddr)) == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrorHandling(<span class="string">&quot;connect() error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐字节接收服务器发送的数据，直到连接关闭</span></span><br><span class="line">    <span class="keyword">while</span>(readLen = recv(hSocket, &amp;message[idx++], <span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(readLen == <span class="number">-1</span>)  <span class="comment">// 接收出错</span></span><br><span class="line">        &#123;</span><br><span class="line">            ErrorHandling(<span class="string">&quot;recv() error!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        strLen += readLen;  <span class="comment">// 累计接收的总字节数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印接收到的消息和总接收次数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message from server : %s \n&quot;</span>, message);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function read call count : %d \n&quot;</span>, strLen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭socket并清理Windows Socket库</span></span><br><span class="line">    closesocket(hSocket);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理函数：打印错误信息并退出程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrorHandling</span><span class="params">(<span class="type">char</span> *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(message, <span class="built_in">stderr</span>);  <span class="comment">// 输出错误信息到标准错误流</span></span><br><span class="line">    fputc(<span class="string">&#x27;\n&#x27;</span>, <span class="built_in">stderr</span>);     <span class="comment">// 换行</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);                 <span class="comment">// 退出程序，返回错误码1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编译运行">编译运行</h1><p>注意需要链接 ws2_32.lib 库，有两种方法：</p><ul><li>通过 Visual Studio 等集成开发环境，设置附加依赖项，把 ws2_32.lib链接进来</li><li>在编译运行时，通过命令行链接</li></ul><p>编译链接的命令行如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello_client.c -o hClientWin -lws2_32</span><br></pre></td></tr></table></figure><p>意味编译 hello_client.c 并与 ws2_32.lib 链接，最终输出 hClientWin.exe文件。</p><p>运行服务端程序，指定一个端口号，会发现程序进入了等待状态，因为调用的<code>accept</code> 函数还未返回。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:<span class="title">NetCoding</span>\<span class="title">Socket</span>&gt;<span class="title">hServerWin</span> 9190</span></span><br><span class="line"><span class="function">(空白)</span></span><br></pre></td></tr></table></figure><p>接着运行客户端程序，指定对应的 ip 和port，命令行得到打印结果，同时服务端程序也运行完毕。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">C:<span class="title">NetCoding</span>\<span class="title">Socket</span>&gt;<span class="title">hClientWin</span> 127.0.0.1 9190</span></span><br><span class="line"><span class="function"><span class="title">Message</span> <span class="title">from</span> <span class="title">server</span> : <span class="title">nice</span> <span class="title">day</span></span></span><br><span class="line"><span class="function"><span class="title">Function</span> <span class="title">read</span> <span class="title">call</span> <span class="title">count</span> : 9</span></span><br></pre></td></tr></table></figure><h1 id="需要注意的点">需要注意的点</h1><p>在客户端代码中，是逐字节接收服务器发送的数据。其实这里可以根据实际需求调整，不一定是一个字节一个字节地接收。这里这样写是因为想要展示非对称的传输：我们使用了IPv4 + 流失传输的组合（下节介绍），符合这一组合的协议只有 TCP 协议，而TCP协议的传输是非对称的，即服务端的发送次数和客户端的接收次数不一定相等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;WinSock 是指 Windows Socket，是 Windows 平台的套接字。&lt;/p&gt;
&lt;h1 id=&quot;服务端代码&quot;&gt;服务端代码&lt;/h1&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</summary>
      
    
    
    
    <category term="08-网络编程" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Socket" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/"/>
    
    
  </entry>
  
  <entry>
    <title>01.Socket概览</title>
    <link href="https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/01.Socket%E6%A6%82%E8%A7%88/"/>
    <id>https://peiyuzou.github.io/wiki/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/01.Socket%E6%A6%82%E8%A7%88/</id>
    <published>2025-07-02T05:55:31.000Z</published>
    <updated>2025-07-02T06:02:47.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="先入为主">先入为主</h1><p>网络编程的实际意义就是在两台连网的计算机之间交换数据。除开所需的物理连接外，只需要编写数据传输软件就可以做到了，然而我们通常不需要担心这点，因为操作系统已经为我们提供了名为Socket 的部件来完成这个事。</p><p>由此可以得出定义：Socket（又名套接字）是操作系统层面提供的用于网络传输的软件部件。</p><h1 id="套接字使用过程">套接字使用过程</h1><ul><li>创建套接字</li><li>分配IP地址和端口号</li><li>进入接收请求状态</li><li>受理连接请求</li></ul><p>这是整个套接字编程的“轮廓”</p><h1 id="文件描述符">文件描述符</h1><p>在windows平台又称“文件句柄”。文件描述符是系统分配给文件或者套接字的一个整数值。它类似于一个图书馆中某本书的编号，在程序员和操作系统两者之间，对文件或者套接字操作提供的一个便利性的指代。如果通过某个函数创建了一个套接字，一般会返回一整数，这个整数就是文件描述符，在下文的代码中，则可以使用这个句柄对套接字做一些操作，有点类似指针。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;先入为主&quot;&gt;先入为主&lt;/h1&gt;
&lt;p&gt;网络编程的实际意义就是在两台连网的计算机之间交换数据。除开所需的物理连接外，只需要编写数据传输软件就可以做到了，然而我们通常不需要担心这点，因为操作系统已经为我们提供了名为
Socket 的部件来完成这个事。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="08-网络编程" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Socket" scheme="https://peiyuzou.github.io/categories/08-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Socket/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://peiyuzou.github.io/wiki/index/"/>
    <id>https://peiyuzou.github.io/wiki/index/</id>
    <published>2025-07-01T12:26:56.425Z</published>
    <updated>2024-11-22T03:25:05.428Z</updated>
    
    <content type="html"><![CDATA[<!-- <div><image src="images/pixel03.gif"></div> --><p>一些有关游戏开发和数学的话题、教程、记录</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- &lt;div&gt;
&lt;image src=&quot;images/pixel03.gif&quot;&gt;
&lt;/div&gt; --&gt;
&lt;p&gt;一些有关游戏开发和数学的话题、教程、记录&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://peiyuzou.github.io/wiki/06-%E5%BC%95%E6%93%8E%E5%BC%80%E5%8F%91/Blank/"/>
    <id>https://peiyuzou.github.io/wiki/06-%E5%BC%95%E6%93%8E%E5%BC%80%E5%8F%91/Blank/</id>
    <published>2025-07-01T12:26:56.404Z</published>
    <updated>2024-12-09T03:20:48.261Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="06-引擎开发" scheme="https://peiyuzou.github.io/categories/06-%E5%BC%95%E6%93%8E%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://peiyuzou.github.io/wiki/07-%E5%9B%BE%E5%BD%A2%E5%AD%A6/Blank/"/>
    <id>https://peiyuzou.github.io/wiki/07-%E5%9B%BE%E5%BD%A2%E5%AD%A6/Blank/</id>
    <published>2025-07-01T12:26:56.404Z</published>
    <updated>2024-12-09T03:20:48.262Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="07-图形学" scheme="https://peiyuzou.github.io/categories/07-%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://peiyuzou.github.io/wiki/04-%E7%A8%8B%E5%BA%8F%E6%95%B0%E5%AD%A6/Blank/"/>
    <id>https://peiyuzou.github.io/wiki/04-%E7%A8%8B%E5%BA%8F%E6%95%B0%E5%AD%A6/Blank/</id>
    <published>2025-07-01T12:26:56.366Z</published>
    <updated>2024-12-09T03:20:45.361Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="04-程序数学" scheme="https://peiyuzou.github.io/categories/04-%E7%A8%8B%E5%BA%8F%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Blank/"/>
    <id>https://peiyuzou.github.io/wiki/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/Blank/</id>
    <published>2025-07-01T12:26:56.304Z</published>
    <updated>2024-12-09T03:20:45.072Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    <category term="01-计算机科学" scheme="https://peiyuzou.github.io/categories/01-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
    
  </entry>
  
  <entry>
    <title>5.x 虚拟机相关函数解读</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/5.x-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E8%A7%A3%E8%AF%BB/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/5.x-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E8%A7%A3%E8%AF%BB/</id>
    <published>2025-01-16T02:12:00.000Z</published>
    <updated>2025-01-16T04:19:42.308Z</updated>
    
    <content type="html"><![CDATA[<h1 id="lual_loadfilex">luaL_loadfilex</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** 用于加载 Lua 脚本文件或从标准输入读取脚本内容，并将其编译为 Lua 的字节码</span></span><br><span class="line"><span class="comment">** 输入：</span></span><br><span class="line"><span class="comment">**     L - 当前状态机</span></span><br><span class="line"><span class="comment">**     filename - 脚本文件名称</span></span><br><span class="line"><span class="comment">**     mode - 指定加载模式（t - 文本，b - 二进制，bt or NULL - 根据首字符自动检查）</span></span><br><span class="line"><span class="comment">** 输出：</span></span><br><span class="line"><span class="comment">**     编译结果的状态（LUA_OK等）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LUALIB_API <span class="type">int</span> <span class="title function_">luaL_loadfilex</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *filename,</span></span><br><span class="line"><span class="params">                                             <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">  LoadF lf;</span><br><span class="line">  <span class="type">int</span> status, readstatus;</span><br><span class="line">  <span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到文件名在栈上的位置</span></span><br><span class="line">  <span class="type">int</span> fnameindex = lua_gettop(L) + <span class="number">1</span>;  <span class="comment">/* index of filename on the stack */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理filename参数</span></span><br><span class="line">  <span class="comment">// - 如果 filename 为 NULL，则从标准输入加载脚本并在栈顶压入 =stdin（标识输入来源）</span></span><br><span class="line">  <span class="comment">// - 如果提供了 filename，尝试以只读模式打开文件。如果失败，则调用 errfile 报错</span></span><br><span class="line">  <span class="keyword">if</span> (filename == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    lua_pushliteral(L, <span class="string">&quot;=stdin&quot;</span>);</span><br><span class="line">    lf.f = <span class="built_in">stdin</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    lua_pushfstring(L, <span class="string">&quot;@%s&quot;</span>, filename);</span><br><span class="line">    lf.f = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (lf.f == <span class="literal">NULL</span>) <span class="keyword">return</span> errfile(L, <span class="string">&quot;open&quot;</span>, fnameindex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 跳过文件中的注释</span></span><br><span class="line">  <span class="comment">// - 调用 skipcomment 跳过文件中的注释部分。c 保存第一个非注释字符</span></span><br><span class="line">  <span class="comment">// - 如果跳过注释后需要调整行号（如文件首行为注释），将换行符 \n 添加到缓冲区</span></span><br><span class="line">  <span class="keyword">if</span> (skipcomment(&amp;lf, &amp;c))  <span class="comment">/* read initial portion */</span></span><br><span class="line">    lf.buff[lf.n++] = <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">/* add line to correct line numbers */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是二进制文件，重新以二进制模式打开</span></span><br><span class="line">  <span class="comment">// 如果文件的第一个字符与 LUA_SIGNATURE 匹配，表明可能是 Lua 的预编译二进制文件</span></span><br><span class="line">  <span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>] &amp;&amp; filename) &#123;  <span class="comment">/* binary file? */</span></span><br><span class="line">    lf.f = freopen(filename, <span class="string">&quot;rb&quot;</span>, lf.f);  <span class="comment">/* reopen in binary mode */</span></span><br><span class="line">    <span class="keyword">if</span> (lf.f == <span class="literal">NULL</span>) <span class="keyword">return</span> errfile(L, <span class="string">&quot;reopen&quot;</span>, fnameindex);</span><br><span class="line">    skipcomment(&amp;lf, &amp;c);  <span class="comment">/* re-read initial portion */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果第一个字符是非空字符，将其存入缓冲区，作为流的第一个有效字符</span></span><br><span class="line">  <span class="keyword">if</span> (c != EOF)</span><br><span class="line">    lf.buff[lf.n++] = c;  <span class="comment">/* &#x27;c&#x27; is the first character of the stream */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 lua_load 编译文件内容为 Lua 字节码</span></span><br><span class="line">  <span class="comment">// - 参数 getF 是一个回调函数，从 lf 中读取内容并提供给 lua_load</span></span><br><span class="line">  status = lua_load(L, getF, &amp;lf, lua_tostring(L, <span class="number">-1</span>), mode);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 ferror 检查文件是否读取错误</span></span><br><span class="line">  <span class="comment">// - 如果有错误，将 Lua 栈恢复到调用此函数之前的状态，并返回错误码</span></span><br><span class="line">  readstatus = ferror(lf.f);</span><br><span class="line">  <span class="keyword">if</span> (filename) fclose(lf.f);  <span class="comment">/* close file (even in case of errors) */</span></span><br><span class="line">  <span class="keyword">if</span> (readstatus) &#123;</span><br><span class="line">    lua_settop(L, fnameindex);  <span class="comment">/* ignore results from &#x27;lua_load&#x27; */</span></span><br><span class="line">    <span class="keyword">return</span> errfile(L, <span class="string">&quot;read&quot;</span>, fnameindex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理和返回</span></span><br><span class="line">  <span class="comment">// - 在成功加载文件后，移除栈上的文件名信息，保持栈的整洁</span></span><br><span class="line">  lua_remove(L, fnameindex);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lua_load">lua_load</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** 在编译解释阶段，负责两个事：</span></span><br><span class="line"><span class="comment">**     1.在执行编译前加锁确保线程安全，并初始化一个文件读取流</span></span><br><span class="line"><span class="comment">**     2.在编译完成后，给编译结果设置全局表作为第一个上值</span></span><br><span class="line"><span class="comment">** 输入：</span></span><br><span class="line"><span class="comment">**     L - 当前状态机</span></span><br><span class="line"><span class="comment">**     reader - 回调函数，用于逐步读取代码块的内容</span></span><br><span class="line"><span class="comment">**     data - 传递给 reader 的用户数据，通常是文件流或内存中的字符串，在 luaL_loadfilex 传过来的是指定文件的文件流</span></span><br><span class="line"><span class="comment">**     chunkname - 代码块的名字，用于错误提示</span></span><br><span class="line"><span class="comment">**     mode - 编译模式，文本还是二进制</span></span><br><span class="line"><span class="comment">** 输出：</span></span><br><span class="line"><span class="comment">**     成功时返回 LUA_OK，并将编译后的 Lua 函数（LClosure）压入栈顶</span></span><br><span class="line"><span class="comment">**     失败时返回错误代码，并将错误信息压入栈顶</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LUA_API <span class="type">int</span> <span class="title function_">lua_load</span> <span class="params">(lua_State *L, lua_Reader reader, <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">char</span> *chunkname, <span class="type">const</span> <span class="type">char</span> *mode)</span> &#123;</span><br><span class="line">  ZIO z;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加锁，确保线程安全</span></span><br><span class="line">  lua_lock(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 缺省 chunkname</span></span><br><span class="line">  <span class="keyword">if</span> (!chunkname) chunkname = <span class="string">&quot;?&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化 ZIO 流</span></span><br><span class="line">  <span class="comment">// - z 是一个 ZIO 结构，它封装了读取代码块内容的逻辑</span></span><br><span class="line">  <span class="comment">// - 将 reader 和 data 指定给这个 ZIO，确保用 reader 指定的方式读取 data 的文件内容</span></span><br><span class="line">  luaZ_init(L, &amp;z, reader, data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用解析器</span></span><br><span class="line">  <span class="comment">// - 此函数负责对代码块的解析和编译，它运行在一个受保护的环境中，可以捕获并处理运行时错误</span></span><br><span class="line">  <span class="comment">// - 解析完成后，将生成的 Lua 函数（LClosure）压入栈顶</span></span><br><span class="line">  status = luaD_protectedparser(L, &amp;z, chunkname, mode);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置全局环境</span></span><br><span class="line">  <span class="comment">// - L-&gt;top - 1 指向的是上一步生成的放在栈顶的 Lua 函数对象</span></span><br><span class="line">  <span class="comment">// - s2v 理解为 StackValue to TValue，它将一个栈元素转化为通用的 TValue 结构体</span></span><br><span class="line">  <span class="comment">// - clLvalue 进一步将 TValue 转化为 LClosure (Lua闭包)</span></span><br><span class="line">  <span class="comment">// - 如果有上值，获取全局表并将全局表设置为该函数的第一个上值</span></span><br><span class="line">  <span class="comment">// - luaC_barrier 确保垃圾回收的正确性，维护引用关系</span></span><br><span class="line">  <span class="keyword">if</span> (status == LUA_OK) &#123;  <span class="comment">/* no errors? */</span></span><br><span class="line">    LClosure *f = clLvalue(s2v(L-&gt;top - <span class="number">1</span>));  <span class="comment">/* get newly created function */</span></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;nupvalues &gt;= <span class="number">1</span>) &#123;  <span class="comment">/* does it have an upvalue? */</span></span><br><span class="line">      <span class="comment">/* get global table from registry */</span></span><br><span class="line">      <span class="type">const</span> TValue *gt = getGtable(L);</span><br><span class="line">      <span class="comment">/* set global table as 1st upvalue of &#x27;f&#x27; (may be LUA_ENV) */</span></span><br><span class="line">      setobj(L, f-&gt;upvals[<span class="number">0</span>]-&gt;v, gt);</span><br><span class="line">      luaC_barrier(L, f-&gt;upvals[<span class="number">0</span>], gt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 释放锁并返回结果</span></span><br><span class="line">  lua_unlock(L);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="f_parser">f_parser</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** lua_load 函数工作流程的一部分</span></span><br><span class="line"><span class="comment">** 输入：</span></span><br><span class="line"><span class="comment">**     L - 当前状态机</span></span><br><span class="line"><span class="comment">**     ud - 一个通用的用户数据指针，在这里是一个指向 SParser 结构体的指针，包含了解析需要的信息</span></span><br><span class="line"><span class="comment">** 输出：</span></span><br><span class="line"><span class="comment">**     没有返回，自动检查文件流是二进制还是文本，转发调用 luaU_undump 和 luaY_parser</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f_parser</span> <span class="params">(lua_State *L, <span class="type">void</span> *ud)</span> &#123;</span><br><span class="line">  LClosure *cl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 ud 强制转换为 SParser 指针</span></span><br><span class="line">  <span class="comment">// - SParser 包含解析时所需的输入流（z）、缓冲区（buff）、动态数据结构（dyd）以及源文件的名字（name）</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">SParser</span> *<span class="title">p</span> =</span> cast(<span class="keyword">struct</span> SParser *, ud);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查文件流类型，转发调用解析函数</span></span><br><span class="line">  <span class="comment">// - 二进制调用 luaU_undump</span></span><br><span class="line">  <span class="comment">// - 文本源码调用 luaY_parser</span></span><br><span class="line">  <span class="type">int</span> c = zgetc(p-&gt;z);  <span class="comment">/* read first character */</span></span><br><span class="line">  <span class="keyword">if</span> (c == LUA_SIGNATURE[<span class="number">0</span>]) &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">&quot;binary&quot;</span>);</span><br><span class="line">    cl = luaU_undump(L, p-&gt;z, p-&gt;name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    checkmode(L, p-&gt;mode, <span class="string">&quot;text&quot;</span>);</span><br><span class="line">    cl = luaY_parser(L, p-&gt;z, &amp;p-&gt;buff, &amp;p-&gt;dyd, p-&gt;name, c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一致性校验，校验生成的闭包的实际 upvalues 数量是否等于函数原型中定义的数量</span></span><br><span class="line">  <span class="comment">// - nupvalues: 闭包中实际的 upvalues 数量</span></span><br><span class="line">  <span class="comment">// - sizeupvalues: 函数原型中声明的 upvalues 数量</span></span><br><span class="line">  lua_assert(cl-&gt;nupvalues == cl-&gt;p-&gt;sizeupvalues);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化闭包的 Upvalues（外部变量的引用）</span></span><br><span class="line">  <span class="comment">// - Upvalues 是闭包执行环境的重要组成部分，确保函数可以正确访问外部变量</span></span><br><span class="line">  luaF_initupvals(L, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="luay_parser">luaY_parser</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** lua_load 函数工作流程的核心部分，将文本流源码解析生成可执行的函数闭包</span></span><br><span class="line"><span class="comment">** 输入：</span></span><br><span class="line"><span class="comment">**     L - 当前状态机</span></span><br><span class="line"><span class="comment">**     z - 输入流对象，封装了输入数据（源码的文本流）</span></span><br><span class="line"><span class="comment">**     buff - 动态缓冲区，用于存储解析过程中的临时数据</span></span><br><span class="line"><span class="comment">**     dyd - 动态数据结构，包含作用域变量、标签、跳转等动态信息</span></span><br><span class="line"><span class="comment">**     name - 源文件的名称，用于生成调试信息</span></span><br><span class="line"><span class="comment">**     firstchar - 输入流的第一个字符，通常在调用时已经读取</span></span><br><span class="line"><span class="comment">** 输出：</span></span><br><span class="line"><span class="comment">**     返回生成的函数闭包（注意词法分析器的表出栈了，函数闭包仍然在栈上）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LClosure *<span class="title function_">luaY_parser</span> <span class="params">(lua_State *L, ZIO *z, Mbuffer *buff,</span></span><br><span class="line"><span class="params">                       Dyndata *dyd, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> firstchar)</span> &#123;</span><br><span class="line">  LexState lexstate;</span><br><span class="line">  FuncState funcstate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建主函数闭包</span></span><br><span class="line">  <span class="comment">// - 使用 luaF_newLclosure 创建一个 LClosure 对象。主闭包对应整个 Lua 源码文件的顶层函数</span></span><br><span class="line">  <span class="comment">// - 使用 setclLvalue2s 将闭包对象放置在 Lua 堆栈顶端，确保不会被垃圾回收器错误清理</span></span><br><span class="line">  <span class="comment">// - 增加堆栈顶指针，以存放闭包</span></span><br><span class="line">  LClosure *cl = luaF_newLclosure(L, <span class="number">1</span>);  <span class="comment">/* create main closure */</span></span><br><span class="line">  setclLvalue2s(L, L-&gt;top, cl);  <span class="comment">/* anchor it (to avoid being collected) */</span></span><br><span class="line">  luaD_inctop(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建词法分析器的哈希表</span></span><br><span class="line">  <span class="comment">// - 为词法分析器创建一张哈希表，存储标识符等信息</span></span><br><span class="line">  <span class="comment">// - 将该表放置在 Lua 堆栈顶端，防止其被垃圾回收器清理</span></span><br><span class="line">  lexstate.h = luaH_new(L);  <span class="comment">/* create table for scanner */</span></span><br><span class="line">  sethvalue2s(L, L-&gt;top, lexstate.h);  <span class="comment">/* anchor it */</span></span><br><span class="line">  luaD_inctop(L);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化函数原型</span></span><br><span class="line">  <span class="comment">// - 创建函数原型: 调用 luaF_newproto 创建函数原型对象（Proto），并将其关联到闭包的 p 字段</span></span><br><span class="line">  <span class="comment">// - 对象屏障: 使用 luaC_objbarrier 确保垃圾回收器正确处理新创建对象之间的引用</span></span><br><span class="line">  <span class="comment">// - 设置调试信息: 将 source 字段设置为源码的名称</span></span><br><span class="line">  funcstate.f = cl-&gt;p = luaF_newproto(L);</span><br><span class="line">  luaC_objbarrier(L, cl, cl-&gt;p);</span><br><span class="line">  funcstate.f-&gt;source = luaS_new(L, name);  <span class="comment">/* create and anchor TString */</span></span><br><span class="line">  luaC_objbarrier(L, funcstate.f, funcstate.f-&gt;source);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化词法和语法分析器</span></span><br><span class="line">  <span class="comment">// - 关联动态数据: 将动态缓冲区和动态数据与词法分析器状态关联</span></span><br><span class="line">  <span class="comment">// - 清空动态数据: 重置动态作用域变量、跳转目标和标签的计数</span></span><br><span class="line">  <span class="comment">// - 设置输入流: 调用 luaX_setinput 初始化词法分析器，设置输入流 z、调试信息 source 和首字符 firstchar</span></span><br><span class="line">  lexstate.buff = buff;</span><br><span class="line">  lexstate.dyd = dyd;</span><br><span class="line">  dyd-&gt;actvar.n = dyd-&gt;gt.n = dyd-&gt;label.n = <span class="number">0</span>;</span><br><span class="line">  luaX_setinput(L, &amp;lexstate, z, funcstate.f-&gt;source, firstchar);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析主函数</span></span><br><span class="line">  <span class="comment">// - 调用核心函数 mainfunc，解析整个 Lua 源码文件，构建语法树和函数原型</span></span><br><span class="line">  mainfunc(&amp;lexstate, &amp;funcstate);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查解析一致性</span></span><br><span class="line">  <span class="comment">// - 检查语法解析是否正确结束：</span></span><br><span class="line">  <span class="comment">//     - 没有多余的嵌套函数</span></span><br><span class="line">  <span class="comment">//     - FuncState 中的 nups（upvalue 数量）为 1</span></span><br><span class="line">  <span class="comment">//     - LexState 中 fs（当前的函数状态）为 NULL</span></span><br><span class="line">  <span class="comment">// - 检查动态数据是否清空</span></span><br><span class="line">  lua_assert(!funcstate.prev &amp;&amp; funcstate.nups == <span class="number">1</span> &amp;&amp; !lexstate.fs);</span><br><span class="line">  <span class="comment">/* all scopes should be correctly finished */</span></span><br><span class="line">  lua_assert(dyd-&gt;actvar.n == <span class="number">0</span> &amp;&amp; dyd-&gt;gt.n == <span class="number">0</span> &amp;&amp; dyd-&gt;label.n == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理堆栈并返回</span></span><br><span class="line">  L-&gt;top--;  <span class="comment">/* remove scanner&#x27;s table */</span></span><br><span class="line">  <span class="keyword">return</span> cl;  <span class="comment">/* closure is on the stack, too */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;lual_loadfilex&quot;&gt;luaL_loadfilex&lt;/h1&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    <category term="源码阅读" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="05-虚拟机" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>5.1 Lua执行的大致过程</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/5.1-Lua%E6%89%A7%E8%A1%8C%E7%9A%84%E5%A4%A7%E8%87%B4%E8%BF%87%E7%A8%8B/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/5.1-Lua%E6%89%A7%E8%A1%8C%E7%9A%84%E5%A4%A7%E8%87%B4%E8%BF%87%E7%A8%8B/</id>
    <published>2025-01-15T02:06:22.000Z</published>
    <updated>2025-07-01T11:47:43.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="和其他语言的执行差异">和其他语言的执行差异</h1><p>一般语言分为编译型语言（Compiled Language）和解释型语言（InterpretedLanguage）。前者会先将代码编译为目标机器可运行的机器码，而后由目标机器直接运行，编译型语言的特点是在编译阶段实现跨平台，不同平台的编译结果不一样，由于它能由机器直接执行，速度会很快。解释型语言则是将代码交给解释器翻译执行，它的特点是由解释器来实现跨平台，平台的差异由语言自身的解释器来解决，由于它需要由解释器来执行，相比前者会慢不少。</p><p><img src="LuaVm01.drawio.png" alt="语言间的执行差异" /><br /></p><p>Lua作为一门解释型语言，它实现了自己的虚拟机充当解释器的角色，来解释执行 Lua代码。这里有一点需要注意，Lua会先将代码进行语法词法分析，生成虚拟机能看懂的字节码（后称OpCode），再由虚拟机执行。现在不少解释型语言和Lua采用了一样的思路，虽然最终是在解释器中执行，但是仍然预先制定了一套语言定制化的编译规则，将代码编译为对应的字节码后再交给解释器执行，这样做会加快代码的执行速度但是仍然有部分语言是采用直接解释执行。比如Bash、AWK、早期的 PHP、Basic 等</p><h2 id="lua-的即时编译和jit的区别">Lua 的即时编译和JIT的区别</h2><p>Lua虽然是先编译为字节码，再交由虚拟机执行，但编译也是发生在运行阶段的，也就是说Lua是即时编译的。即时编译并不会妨碍它作为解释型语言在运行时可修改的特性，但Lua 的即时编译和传统的 JIT 有所不同。</p><p>Lua 的编译执行过程分为两个阶段：</p><ul><li>即时编译阶段（源代码 –&gt; 字节码）<ul><li>当 Lua 脚本被加载时，Lua 虚拟机会将源代码即时编译为字节码</li><li>这一步发生在运行时，即每次加载脚本时都会进行，这个编译过程由<code>lua_load</code> 函数完成</li></ul></li><li>解释运行阶段（字节码 –&gt; 执行）<ul><li>编译后的字节码并不会被进一步编译为机器码，而是由 Lua虚拟机逐条解释执行</li></ul></li></ul><p>Lua 的即时编译与真正的 JIT 编译的区别在于：Lua即时编译的结果并非目标机器码，而是一种中间表示，只有它的虚拟机能够解释执行。</p><h2 id="lua-为何不采用-jit-编译">Lua 为何不采用 JIT 编译？</h2><p>它的官方解释器（PUC-Rio Lua）并没有集成 JIT 编译器，原因如下：</p><ul><li>跨平台性：<ul><li>Lua以简单和轻量为核心设计目标，官方解释器支持多种平台，而字节码和虚拟机的实现更容易移植</li><li>JIT 编译器需要针对特定的 CPU 架构生成机器码，移植性较差</li></ul></li><li>嵌入式使用：<ul><li>Lua主要被设计为嵌入式脚本语言，典型场景包括嵌入游戏引擎、应用程序等</li><li>字节码解释足以满足大部分需求，同时减少了 JIT编译的复杂性和内存开销</li></ul></li><li>性能需求：<ul><li>Lua 的性能在许多嵌入式场景下已经足够</li><li>对于更高性能需求的场景，可以使用 LuaJIT（Lua 的一个 JIT编译器版本，将字节码直接编译为机器码，极大提升了性能）</li></ul></li></ul><h1 id="虚拟机概览">虚拟机概览</h1><p>除了 Lua，还有一些其他语言也实现了自己的虚拟机比如 Java 和Python。一般一个语言的虚拟机的职责如下：</p><ul><li>将源代码编译成虚拟机可识别执行的字节码</li><li>为函数调用准备调用栈</li><li>内部维持一个指令指针（IP，InstructionPointer）来保存下一个将执行的指令地址。在 Lua 中，该 IP 对应的是 PC指针，后续会讲</li><li>模拟一个 CPU 的运行：循环拿出由 IP指向的字节码，根据字节码格式进行解码，然后执行</li></ul><p>这样一来，一台抽象的计算机就出现了，这也是它们被称为虚拟机的原因。</p><p>虚拟机有两种实现方式：基于栈（stack-based）和基于寄存器（register-based），市面上常见的都是前者，而Lua 属于后者。</p><h2 id="基于栈的虚拟机">基于栈的虚拟机</h2><p>对于这种虚拟机，字节码的操作数从栈顶弹出，执行完操作后再压入栈顶，下图是一个加法操作后栈结构的变化：</p><p><img src="LuaVm02.drawio.png" alt="基于栈的虚拟机" /><br /></p><p>这个操作对应的伪代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POP 2</span><br><span class="line">POP 1</span><br><span class="line">ADD 2,1,result</span><br><span class="line">PUSH result</span><br></pre></td></tr></table></figure><p>完成一个加法操作需要 4条字节码，需要用额外的指令准备数据是这种设计的缺点。但是优点是指令不需要关心操作数的地址，在执行操作前已经将操作数准备在栈顶了</p><h2 id="基于寄存器的虚拟机">基于寄存器的虚拟机</h2><p>和基于栈的虚拟机不同，这种虚拟机将操作数存放在 “CPU的寄存器”中，这个寄存器不是物理意义上的寄存器，而是虚拟机的一种抽象实现。它实现前面的加法操作的示意图如下：</p><p><img src="LuaVm03.drawio.png" alt="基于寄存器的虚拟机" /><br /></p><p>它对应的伪代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD R1,R2,R3 <span class="comment">#寄存器R1与R2相加结果保存在寄存器R3中</span></span><br></pre></td></tr></table></figure><p>这种虚拟机的优点是，指令简短，但缺点是程序需要关注操作数的位置。Lua选择这种寄存器的主要目的是尽可能高效。</p><h1 id="执行源码概览">执行源码概览</h1><p>这里以一个宏观的角度浏览整个编译解释和执行的流程，具体函数的分析参考<ahref="https://peiyuzou.github.io/wiki/02-编程语言/Lua/源码阅读/05-虚拟机/5.x-虚拟机相关函数解读/">函数解读</a></p><h2 id="lual_dofile">luaL_dofile</h2><p>这是 Lua 执行文件的调用函数，本身是个宏，等效于先调用<code>luaL_loadfile</code>，再调用 <code>lua_ocall</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> luaL_dofile(L, fn) \</span></span><br><span class="line"><span class="meta">(luaL_loadfile(L, fn) || lua_pcall(L, 0, LUA_MULTRET, 0))</span></span><br></pre></td></tr></table></figure><p>luaL_loadfile 负责进行词法语法分析，lua_pcall则将分析结果放到虚拟机中执行</p><h2 id="编译解释流程">编译解释流程</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;和其他语言的执行差异&quot;&gt;和其他语言的执行差异&lt;/h1&gt;
&lt;p&gt;一般语言分为编译型语言（Compiled Language）和解释型语言（Interpreted
Language）。前者会先将代码编译为目标机器可运行的机器码，而后由目标机器直接运行，编译型语言的</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    <category term="源码阅读" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="05-虚拟机" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/05-%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
    <category term="Lua" scheme="https://peiyuzou.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>4.2 表相关的算法</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/4.2-%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/4.2-%E8%A1%A8%E7%9B%B8%E5%85%B3%E7%9A%84%E7%AE%97%E6%B3%95/</id>
    <published>2025-01-14T03:05:06.000Z</published>
    <updated>2025-01-14T10:01:19.410Z</updated>
    
    <content type="html"><![CDATA[<p>在上一节中，我们简要提到了表的数组部分和哈希部分会进行自适应调整；以正整数为键的数据可能会存储在数组部分，也可能存储在哈希部分；存储在数组部分时，它的键就是数组的索引；而存储在哈希部分时，就是单纯的键值对。Lua有一个标准去做这个调整，保证数组和哈希部分有最优的边界。</p><p>我们在来看这个例子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">t[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">t[<span class="number">100</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>插入的这两个元素对外部使用者来说，并不能准确地知道它们究竟写入了数组还是哈希表。我们先跳过它的写入逻辑，来看看table 是怎么处理查找的。</p><h1 id="查找">查找</h1><p>table 处理查找的伪代码如下：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> key &gt; <span class="number">0</span> <span class="keyword">and</span> key &lt;= 数组大小 <span class="keyword">then</span> <span class="comment">--在数组索引范围内</span></span><br><span class="line">    尝试在数组部分查找</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    尝试在哈希部分查找</span><br><span class="line">    <span class="comment">--[[</span></span><br><span class="line"><span class="comment">        1.计算出key的哈希值，根据哈希值访问Node数组得到哈希桶位置</span></span><br><span class="line"><span class="comment">        2.遍历哈希桶链表，直到找到对应key</span></span><br><span class="line"><span class="comment">    ]]</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>可以看出来，一个正整数，只有在数组索引范围内时，其存储才会落在数组部分。否则也会存储在哈希部分。</p><h1 id="新增">新增</h1><p>上面关于查找的算法可以看出来，table 的哈希部分采用链地址法。Lua将哈希桶所在的位置称为<code>mainposition</code>。哈希部分的链表结构和普通链地址法的哈希表一致：</p><p><img src="LuaTableHash.drawio.png" alt="table的哈希表结构" /><br /></p><p>那么 Lua 在往 table新增数据的时候，是如何处理的？让我们关注两个入口函数<code>luaH_set</code> 和 <code>luaH_setint</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">luaH_set</span> <span class="params">(lua_State *L, Table *t, <span class="type">const</span> TValue *key, TValue *value)</span> &#123;</span><br><span class="line">  <span class="type">const</span> TValue *slot = luaH_get(t, key);</span><br><span class="line">  luaH_finishset(L, t, key, slot, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">luaH_setint</span> <span class="params">(lua_State *L, Table *t, lua_Integer key, TValue *value)</span> &#123;</span><br><span class="line">  <span class="type">const</span> TValue *p = luaH_getint(t, key);</span><br><span class="line">  <span class="keyword">if</span> (isabstkey(p)) &#123;</span><br><span class="line">    TValue k;</span><br><span class="line">    setivalue(&amp;k, key);</span><br><span class="line">    luaH_newkey(L, t, &amp;k, value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    setobj2t(L, cast(TValue *, p), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和以前的版本不同，Lua 5.4.4 中并没有<code>luaH_setstr</code>、<code>luaH_setnum</code>等API，它使用了一个公共的 <code>luaH_set</code>来满足全部类型数据的新增，这本身是得益于 TValue 结构的优化。</p><h2 id="luah_setint">luaH_setint ?</h2><p>而 <code>luaH_setint</code>则是基于整数键做出的优化函数，它会判断整数键是否属于表的数组部分，从而绕过了非整数键的检查逻辑。这样具有更高的访问效率，减少了很多不必要的逻辑计算。</p><p>举个例子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">t[<span class="number">1</span>] = <span class="string">&quot;a&quot;</span>    <span class="comment">-- 整数键</span></span><br><span class="line">t[<span class="string">&quot;key&quot;</span>] = <span class="string">&quot;b&quot;</span> <span class="comment">-- 字符串键</span></span><br></pre></td></tr></table></figure><p><code>t[1] = "a"</code></p><ul><li>Lua会调用 <code>luaH_setint</code></li><li>如果键 <code>1</code> 落在数组部分，直接将 <code>"a"</code>存入数组部分</li><li>如果键超出数组范围或数组未分配足够大小，调整 alimit或将键值存入哈希部分</li></ul><p><code>t["key"] = "b"</code></p><ul><li>Lua 会调用 <code>luaH_set</code></li><li>根据键的类型（字符串），计算其哈希值，找到对应的哈希桶并插入</li></ul><h2 id="luah_newkey">luaH_newkey</h2><p>不管是调用 <code>luaH_setint</code> 还是<code>luaH_set</code>，如果新增的键不存在，都牵涉到一个函数<code>luaH_newkey</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** inserts a new key into a hash table; first, check whether key&#x27;s main</span></span><br><span class="line"><span class="comment">** position is free. If not, check whether colliding node is in its main</span></span><br><span class="line"><span class="comment">** position or not: if it is not, move colliding node to an empty place and</span></span><br><span class="line"><span class="comment">** put new key in its main position; otherwise (colliding node is in its main</span></span><br><span class="line"><span class="comment">** position), new key goes to an empty position.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">luaH_newkey</span> <span class="params">(lua_State *L, Table *t, <span class="type">const</span> TValue *key, TValue *value)</span> &#123;</span><br><span class="line">  Node *mp;</span><br><span class="line">  TValue aux;</span><br><span class="line">  <span class="keyword">if</span> (l_unlikely(ttisnil(key)))</span><br><span class="line">    luaG_runerror(L, <span class="string">&quot;table index is nil&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ttisfloat(key)) &#123;</span><br><span class="line">    lua_Number f = fltvalue(key);</span><br><span class="line">    lua_Integer k;</span><br><span class="line">    <span class="keyword">if</span> (luaV_flttointeger(f, &amp;k, F2Ieq)) &#123;  <span class="comment">/* does key fit in an integer? */</span></span><br><span class="line">      setivalue(&amp;aux, k);</span><br><span class="line">      key = &amp;aux;  <span class="comment">/* insert it as an integer */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l_unlikely(luai_numisnan(f)))</span><br><span class="line">      luaG_runerror(L, <span class="string">&quot;table index is NaN&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ttisnil(value))</span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">/* do not insert nil values */</span></span><br><span class="line">  mp = mainpositionTV(t, key);</span><br><span class="line">  <span class="keyword">if</span> (!isempty(gval(mp)) || isdummy(t)) &#123;  <span class="comment">/* main position is taken? */</span></span><br><span class="line">    Node *othern;</span><br><span class="line">    Node *f = getfreepos(t);  <span class="comment">/* get a free place */</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;  <span class="comment">/* cannot find a free place? */</span></span><br><span class="line">      rehash(L, t, key);  <span class="comment">/* grow table */</span></span><br><span class="line">      <span class="comment">/* whatever called &#x27;newkey&#x27; takes care of TM cache */</span></span><br><span class="line">      luaH_set(L, t, key, value);  <span class="comment">/* insert key into grown table */</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lua_assert(!isdummy(t));</span><br><span class="line">    othern = mainpositionfromnode(t, mp);</span><br><span class="line">    <span class="keyword">if</span> (othern != mp) &#123;  <span class="comment">/* is colliding node out of its main position? */</span></span><br><span class="line">      <span class="comment">/* yes; move colliding node into free position */</span></span><br><span class="line">      <span class="keyword">while</span> (othern + gnext(othern) != mp)  <span class="comment">/* find previous */</span></span><br><span class="line">        othern += gnext(othern);</span><br><span class="line">      gnext(othern) = cast_int(f - othern);  <span class="comment">/* rechain to point to &#x27;f&#x27; */</span></span><br><span class="line">      *f = *mp;  <span class="comment">/* copy colliding node into free pos. (mp-&gt;next also goes) */</span></span><br><span class="line">      <span class="keyword">if</span> (gnext(mp) != <span class="number">0</span>) &#123;</span><br><span class="line">        gnext(f) += cast_int(mp - f);  <span class="comment">/* correct &#x27;next&#x27; */</span></span><br><span class="line">        gnext(mp) = <span class="number">0</span>;  <span class="comment">/* now &#x27;mp&#x27; is free */</span></span><br><span class="line">      &#125;</span><br><span class="line">      setempty(gval(mp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">/* colliding node is in its own main position */</span></span><br><span class="line">      <span class="comment">/* new node will go into free position */</span></span><br><span class="line">      <span class="keyword">if</span> (gnext(mp) != <span class="number">0</span>)</span><br><span class="line">        gnext(f) = cast_int((mp + gnext(mp)) - f);  <span class="comment">/* chain new position */</span></span><br><span class="line">      <span class="keyword">else</span> lua_assert(gnext(f) == <span class="number">0</span>);</span><br><span class="line">      gnext(mp) = cast_int(f - mp);</span><br><span class="line">      mp = f;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setnodekey(L, mp, key);</span><br><span class="line">  luaC_barrierback(L, obj2gco(t), key);</span><br><span class="line">  lua_assert(isempty(gval(mp)));</span><br><span class="line">  setobj2t(L, gval(mp), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们逐段分析，看看这个函数做了什么。</p><ul><li>首先是第 11 ~ 24 行，这一段针对 key做了一些错误处理，中间的分支对于浮点数键做了处理：如果 key是一个浮点数，但是它的值是一个整数，那么把 key 作为一个整型值插入。</li><li>第 25 行，计算得到 key 的哈希值mainposition，也就是它在哈希数组中的哈希桶的地址</li><li>先看 58 ~ 61 行，该 mainposition 位置空闲，这里直接将 key 和 value设置给该位置的 Node</li><li>再看 26 ~ 57 行，该 mainposition位置冲突（我们暂且称这里存放的节点为冲突节点）<ul><li>28 ~ 34 行，尝试找一个空闲位置，如果没有，执行一次 rehash 扩张一次table，然后插入 key 和 value</li><li>36 行，有现成的空闲位置，那么计算这个冲突节点的 mainposition<ul><li>37 ~ 48 行，冲突节点的 mainposition在其它位置，那么把冲突节点移动到一个空闲位置</li><li>50 ~ 57 行，冲突节点的 mainposition 就在它当前位置，那么把当前 key和 value 插入空闲位置</li></ul></li></ul></li></ul><p>总结就是：首先，检查 key的主位置是否空闲。如果不是，则检查冲突节点是否在其主位置：如果不是，则将冲突节点移至空位置并将key 放入其主位置；否则（冲突节点在其主位置），key 将移至空位置</p><blockquote><p>这里要重点注意，整个操作都是基于哈希表进行的，而没有关于数组的逻辑。因为在执行<code>luaH_newkey</code> 之前，一定是通过 <code>luaH_get</code> 或者<code>luaH_getint</code>在数组部分检查过了，数组部分不存在的情况下，才会走进<code>luaH_newkey</code> 的逻辑。</p></blockquote><h2 id="rehash">rehash</h2><p>从前面的代码可见，在空闲空间不足的情况下，table 会自动执行一次rehash，这个函数就是我们在前一节提到的自适应调整数组部分和哈希部分空间的算法，让我们来看看：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** nums[i] = number of keys &#x27;k&#x27; where 2^(i - 1) &lt; k &lt;= 2^i</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">rehash</span> <span class="params">(lua_State *L, Table *t, <span class="type">const</span> TValue *ek)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> asize;  <span class="comment">/* optimal size for array part */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> na;  <span class="comment">/* number of keys in the array part */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nums[MAXABITS + <span class="number">1</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> totaluse;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= MAXABITS; i++) nums[i] = <span class="number">0</span>;  <span class="comment">/* reset counts */</span></span><br><span class="line">  setlimittosize(t);</span><br><span class="line">  na = numusearray(t, nums);  <span class="comment">/* count keys in array part */</span></span><br><span class="line">  totaluse = na;  <span class="comment">/* all those keys are integer keys */</span></span><br><span class="line">  totaluse += numusehash(t, nums, &amp;na);  <span class="comment">/* count keys in hash part */</span></span><br><span class="line">  <span class="comment">/* count extra key */</span></span><br><span class="line">  <span class="keyword">if</span> (ttisinteger(ek))</span><br><span class="line">    na += countint(ivalue(ek), nums);</span><br><span class="line">  totaluse++;</span><br><span class="line">  <span class="comment">/* compute new size for array part */</span></span><br><span class="line">  asize = computesizes(nums, &amp;na);</span><br><span class="line">  <span class="comment">/* resize the table to new computed sizes */</span></span><br><span class="line">  luaH_resize(L, t, asize, totaluse - na);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的大致算法思路如下：</p><ul><li>分配一个数组 <code>nums</code>，初始它的每个元素都是0，假设它的下标用变量 i 表示，它的每个元素的含义是 key 的值在 <spanclass="math inline">\({2^{(i-1)}}\)</span> ~ <spanclass="math inline">\({2^i}\)</span> 之间的元素数量（左开右闭）</li><li>遍历数组部分，统计元素数量更新到 nums</li><li>遍历哈希部分，只统计正整数键，更新到 nums</li><li>此时，整个 table 的正整数 key 的分配已经统计在了 nums 中。接着遍历nums数组，找到范围区间内包含的整数数量大于50%，满足这个条件的索引可能有很多个，只要索引最大的那个</li><li>这个索引作为重新散列后的数组大小，也就是之前提到的<code>alimit</code>，凡是超过这个值的 key，就分配到了哈希部分</li></ul><p>从这个函数可以看出 Lua的设计思想：简单高效、且尽量节省内存。在重新散列的过程中，除了要增大table的大小来容纳新的数据外，还借此机会调整了数组和哈希两个部分，让两部分都尽可能发挥其容纳效率。</p><p>下面的图是调整后的数组部分的示意图，每个 2的幂之间的空间的存储率都大于 50%，这也是 Lua认为数组达到最大容纳效率的标准：</p><p><img src="LuaTableRehash.drawio.png"alt="rehash调整后的数组" /><br /></p><h2 id="代价">代价？</h2><p>从上面的分析可以看出， Lua解释器会自动进行重新散列，并且对使用者来说是透明的。从算法和以往对哈希表扩容的经验来看，这个操作的开销不会很小，然而我们在知晓其原理后，可以手动减少它的发生，来看一个例子：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>, <span class="number">3</span> <span class="keyword">do</span></span><br><span class="line">    t[i] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个代码执行会触发 3 次 rehash：</p><ul><li>第一次，为了装下 t[1] , Lua 触发了一次 rehash，数组部分长度设置为1</li><li>第二次，数组长度设置为 2</li><li>第三次，数组长度设置为 4</li></ul><p>也就是说，如果数组部分要装下一个数，需要执行 n 次 rehash，保证 <spanclass="math inline">\({2^n}\)</span> 大于key。对于超多元素的表，比如100万个元素，其实也不过触发了 20 次rehash。但是在一个需要创建大量小长度的表的情况下，这个问题会很严重。但是我们可以尽可能地减少它，来看对比：</p><p><img src="202401141725.png" alt="创建大量小长度的表" /><br /></p><p>我们使用预填充的方法，减少触发重新散列，这里的优化提高了一倍多的速度！</p><h1 id="迭代">迭代</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">luaH_next</span> <span class="params">(lua_State *L, Table *t, StkId key)</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> asize = luaH_realasize(t);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = findindex(L, t, s2v(key), asize);  <span class="comment">/* find original key */</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; asize; i++) &#123;  <span class="comment">/* try first array part */</span></span><br><span class="line">    <span class="keyword">if</span> (!isempty(&amp;t-&gt;<span class="built_in">array</span>[i])) &#123;  <span class="comment">/* a non-empty entry? */</span></span><br><span class="line">      setivalue(s2v(key), i + <span class="number">1</span>);</span><br><span class="line">      setobj2s(L, key + <span class="number">1</span>, &amp;t-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (i -= asize; cast_int(i) &lt; sizenode(t); i++) &#123;  <span class="comment">/* hash part */</span></span><br><span class="line">    <span class="keyword">if</span> (!isempty(gval(gnode(t, i)))) &#123;  <span class="comment">/* a non-empty entry? */</span></span><br><span class="line">      Node *n = gnode(t, i);</span><br><span class="line">      getnodekey(L, s2v(key), n);</span><br><span class="line">      setobj2s(L, key + <span class="number">1</span>, gval(n));</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">/* no more elements */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lua中表的迭代并没有设计迭代器，很大原因是为了兼容数组部分和哈希部分的访问。</p><p>luaH_next 大致的逻辑是在当前 key 的基础上找下一个有效键值对</p><ul><li>如果 key 是 nil，表示从头开始遍历，否则找到该 key的位置，然后从下一个位置继续</li><li>优先遍历数组部分，因为顺序表遍历更快，找到下一个非空值。</li><li>如果数组部分没有找到，再遍历哈希部分，这部分就需要遍历每个桶，找到下一个有效键值对</li><li>不管在是数组部分还是哈希部分找到，都将键和值压入 Lua栈，并返回成功或失败（1或0）</li></ul><h1 id="取长度">取长度</h1><p>在 Lua 中，我们可以提供元方法 <code>__len</code>来自定义表的取长度方法，Lua 本身默认提供了 <code>#</code>作为取长度符号。</p><p>它的取长度的结果不是 table 的全部元素的数量，而是 table的序列部分的长度，这个序列部分指表的第一个键的值连续的数据子集，比如：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(#&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">nil</span>,<span class="number">10</span>&#125;) <span class="comment">-- 输出 5</span></span><br></pre></td></tr></table></figure><p>这和数组部分无关，尽管它看起来像是数组，这个所谓的序列对哈希部分也是一样的规则：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t1 = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(#t1) <span class="comment">-- 输出 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t2 = &#123;</span><br><span class="line">    [<span class="number">1</span>] = <span class="number">1</span>,</span><br><span class="line">    [<span class="number">2</span>] = <span class="number">2</span>,</span><br><span class="line">    [<span class="number">5</span>] = <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(#t2) <span class="comment">-- 输出 2</span></span><br></pre></td></tr></table></figure><p>如果一个表混合了这两种风格，那么优先取数组部分的长度：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(#&#123;[<span class="number">1</span>] = <span class="number">1</span>, [<span class="number">2</span>] = <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;) <span class="comment">-- 输出 3</span></span><br></pre></td></tr></table></figure><p>取长度对应的源码函数是<code>luaH_getn</code>，这里不赘述了，它的算法思路大致就是先在数组部分取长度，没有取成功就在哈希部分取</p><h1 id="总结">总结</h1><p>Lua的表内部分为数组部分和哈希部分，虽然对使用者是透明的，但是理解其存储原理会帮助我们更正确地使用它：</p><ul><li>尽量避免混用数组和哈希，提升效率</li><li>可以通过预先分配的方式，减少 rehash</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在上一节中，我们简要提到了表的数组部分和哈希部分会进行自适应调整；以正整数为键的数据可能会存储在数组部分，也可能存储在哈希部分；存储在数组部分时，它的键就是数组的索引；而存储在哈希部分时，就是单纯的键值对。Lua有一个标准去做这个调整，保证数组和哈希部分有最优的边界。&lt;/p</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    <category term="源码阅读" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="04-表" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/"/>
    
    
    <category term="Lua" scheme="https://peiyuzou.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>2.1 Lua中的数据类型</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.1-Lua%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/2.1-Lua%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2024-12-10T09:27:20.000Z</published>
    <updated>2025-01-14T02:18:56.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础类型">基础类型</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (lua.h)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** basic types</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNONE(-1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNIL0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TBOOLEAN1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TLIGHTUSERDATA2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TNUMBER3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TSTRING4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTABLE5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TFUNCTION6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TUSERDATA7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_TTHREAD8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_NUMTYPES9</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>宏</th><th>类型描述</th><th>对应数据结构</th></tr></thead><tbody><tr><td>LUA_TNONE</td><td>无效类型</td><td>无</td></tr><tr><td>LUA_TNIL</td><td>空</td><td>无</td></tr><tr><td>LUA_TBOOLEAN</td><td>布尔</td><td>无</td></tr><tr><td>LUA_TLIGHTUSERDATA</td><td>指针</td><td>void *</td></tr><tr><td>LUA_TNUMBER</td><td>数值</td><td>lua_Number</td></tr><tr><td>LUA_TSTRING</td><td>字符串</td><td>TString</td></tr><tr><td>LUA_TTABLE</td><td>表</td><td>Table</td></tr><tr><td>LUA_TFUNCTION</td><td>函数</td><td>CClosure、LClosure</td></tr><tr><td>LUA_TUSERDATA</td><td>指针</td><td>Udata</td></tr><tr><td>LUA_TTHREAD</td><td>Lua虚拟机、协程</td><td>lua_State</td></tr></tbody></table><p>宏 <code>LUA_NUMTYPES</code> 指有效数据类型的数量，即0~8共9个</p><p>其中 <code>LUA_TLIGHTUSERDATA</code> 和 <code>LUA_TUSERDATA</code>均是指针，userdata 指一些外部的用户知晓的内存块，它们的类型不被 Lua定义，用指针来访问它们以在 Lua中实现对外部数据的操作。两者的区别在于，LUA_TLIGHTUSERDATA的分配释放由外部自己管理，所以 Lua将它视为值类型，因为不需要分配任何额外空间来存储数据，仅仅只是一个指针而已。LUA_TUSERDATA则由内部管理，Lua 为它定义了 <code>Udata</code>结构，存储它的数据，并且加入GC的管理。</p><blockquote><p>需要注意的是，这些宏并不是真正的类型，只是用某个数字代指这个类型，真正的类型是表格中的最后一列：对应数据结构</p></blockquote><h1 id="动态类型是如何实现的">动态类型是如何实现的？</h1><p>Lua是动态类型的语言，动态类型指一个变量在不同时刻可以是不同类型的</p><p>它通过一个通用结构体 <code>TValue</code>来定义任意的类型，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Tagged Values. This is the basic representation of values in Lua:</span></span><br><span class="line"><span class="comment">** an actual value plus a tag with its type.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TValuefieldsValue value_; lu_byte tt_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TValue</span> &#123;</span></span><br><span class="line">  TValuefields;</span><br><span class="line">&#125; TValue;</span><br></pre></td></tr></table></figure><p>简单来说，<code>tt_</code>用于标记这个结构体是什么类型，<code>value_</code>则存储实际的值数据。当一个变量需要变为其他类型时，改变它的 tt_字段的值，同时设置对应的 Value_ 值即可做到。</p><h1 id="类型标记type-tag">类型标记（Type Tag）</h1><p><code>tt_</code> 全称是 Type Tag ，用于标记当前对象的类型，它被声明为<code>lu_byte</code> 类型，lu_byte 宏代指 unsigned char类型（占一个字节，范围0~255），由于基础类型的标记最高值是8，因此低4位被设计用于标记基础类型，其它的位设计如下：</p><table><thead><tr><th>7 bit</th><th>6 bit</th><th>5-4 bit</th><th>3-0 bit</th></tr></thead><tbody><tr><td>reserved</td><td>GC Tag</td><td>variant type tag</td><td>basic type tag</td></tr></tbody></table><p>从表中可以看到，除了低4位被用于标记基础类型，Lua还在 bits(4-5)设计了变种类型，变种类型让 Lua对类型标记进一步划分，用于内部更加多样化的数据支持、更加精确地处理数据、甚至是提升性能。如下是Lua 将数值类型 LUA_TNUMBER 进行变种得到整型数和浮点数的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// (lobject.h)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** tags for Tagged Values have the following use of bits:</span></span><br><span class="line"><span class="comment">** bits 0-3: actual tag (a LUA_T* constant)</span></span><br><span class="line"><span class="comment">** bits 4-5: variant bits</span></span><br><span class="line"><span class="comment">** bit 6: whether value is collectable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* add variant bits to a type */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> makevariant(t,v)((t) | ((v) &lt;&lt; 4))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Variant tags for numbers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_VNUMINTmakevariant(LUA_TNUMBER, 0)  <span class="comment">/* integer numbers */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LUA_VNUMFLTmakevariant(LUA_TNUMBER, 1)  <span class="comment">/* float numbers */</span></span></span><br></pre></td></tr></table></figure><p>除了 variant type tag 和 basic type tag，还有用于标记是否可被回收的GC Tag。而 bit 7 目前保留没有任何作用</p><h1id="tvalue的结构设计valuegcobject和gcunion">TValue的结构设计（Value、GCObject和GCUnion）</h1><p><img src="Lua通用数据结构的设计.drawio.png"alt="Struct of TValue" /><br /></p><h2 id="tvalue">TValue</h2><p><code>TValue</code> 结构如上图所示，包含一个联合体<code>value_</code> 和一个类型标记 <code>tt_</code>，对应源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Tagged Values. This is the basic representation of values in Lua:</span></span><br><span class="line"><span class="comment">** an actual value plus a tag with its type.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TValuefieldsValue value_; lu_byte tt_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TValue</span> &#123;</span></span><br><span class="line">  TValuefields;</span><br><span class="line">&#125; TValue;</span><br></pre></td></tr></table></figure><p><code>tt_</code> 标记了联合体 <code>value_</code>分配的空间中值的具体类型，由此知道该以什么样的结构使用这块内存。另外，前述内容也提到<code>tt_</code>的第7位标记了当前类型是否是可回收类型，以下代码是判断一个对象是否是可回收的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bit mark for collectable types */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIT_ISCOLLECTABLE(1 &lt;&lt; 6)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> iscollectable(o)(rawtt(o) &amp; BIT_ISCOLLECTABLE)</span></span><br></pre></td></tr></table></figure><h2 id="value">Value</h2><p>再看 <code>Value</code> 的设计，这个域负责存储实际的值，我们知道 Lua有自己的垃圾回收机制，因此它的类型设计包含了可回收和不可回收两种。</p><p>在 <code>Value</code> 这一层面，Lua将这两种类型区分开了，可回收的对象表达为一个指针，而没有直接存储它。不可回收的类型则全部声明为联合体的域。整个联合体只是在栈上分配了一个空间，存储这些域的其中之一：</p><ul><li>GCObject *gc：指向一个可回收对象的内存地址</li><li>void *p：本质就是一个指针，Lua中称它为<code>lightuserdata</code>，和 <code>userdata</code> 不同，前者不需要Lua 管理内存，只是作为变量保存一个地址。后者则需要 Lua 负责管理内存</li><li>lua_CFunction f：本质上也是一个指针，指向一个 C 函数</li><li>lua_Integer i：存储整型数值</li><li>lua_Number n：存储浮点数值</li></ul><h2 id="gcunion和gcobject">GCUnion和GCObject</h2><p>为了更好地理解 <code>GCObject</code>，我们要先了解<code>GCUnion</code> 这个联合体</p><p><code>GCUnion</code> 是真正定义GC对象存储位置的结构，Lua中的全部可回收类型都定义为它的域</p><p>其中比较特殊的是 <code>GCObject</code>，它只包含一个<code>CommonHeader</code> 宏，源码定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Common Header for all collectable objects (in macro form, to be</span></span><br><span class="line"><span class="comment">** included in other objects)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CommonHeaderstruct GCObject *next; lu_byte tt; lu_byte marked</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Common type for all collectable objects */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GCObject</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">&#125; GCObject;</span><br></pre></td></tr></table></figure><p><code>CommonHeader</code> 包含三个域：</p><ul><li>GCObject *next：这个指针指向下一个 GC 对象，所有 GC 对象通过各自的next 指针链接起来形成整个 GC 链表</li><li>lu_byte tt：也是类型标记，和 <code>tt_</code> 相同，但由于<code>GCObject</code>在堆内存中单独分配，所以这里为它再存了一份，便于访问</li><li>lu_byte marked：GC 阶段的标记</li></ul><p>Lua 中需要 GC 的类型很多，但在作为可回收对象时，都是统一作为<code>GCObject</code> 类型。这里很多人会产生一个疑问：GCUnion作为一个联合体，同一个内存如何转换 <code>GCObject</code>和其他类型？</p><p>要回答这个问题，需要看其他 GC 类型的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TString</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  ... <span class="comment">/* other fields */</span></span><br><span class="line">&#125; TString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Udata</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  ... <span class="comment">/* other fields */</span></span><br><span class="line">&#125; Udata;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  ... <span class="comment">/* other fields */</span></span><br><span class="line">&#125; Table;</span><br></pre></td></tr></table></figure><p>现在应该明白了，所有类型的内存头部都是相同的结构<code>CommonHeader</code>，相当于需要把一个类型作为<code>GCObject</code> 的时候，只是访问了这个头部结构的内存数据罢了。</p><p>除开 <code>GCObject</code> ，其他的类型我们先简单了解下：</p><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>TString</td><td>字符串</td></tr><tr><td>Udata</td><td>用户数据指针</td></tr><tr><td>Closure</td><td>闭包</td></tr><tr><td>Table</td><td>表</td></tr><tr><td>Proto</td><td>函数原型</td></tr><tr><td>lua_State</td><td>Lua虚拟机</td></tr><tr><td>UpVal</td><td>上值</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础类型&quot;&gt;基础类型&lt;/h1&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    <category term="源码阅读" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="02-数据类型" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/02-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
    
    <category term="Lua" scheme="https://peiyuzou.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>4.1 表的数据结构</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/4.1-%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/4.1-%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2024-12-10T06:59:20.000Z</published>
    <updated>2025-01-14T03:00:34.696Z</updated>
    
    <content type="html"><![CDATA[<p>Lua 用 table 来表示一切数据结构，为了效率，Lua 将 table 的存储分为了<code>数组</code> 和 <code>哈希表</code> 两个部分。</p><ul><li>数组部分提供了紧凑且高效的随机访问。它的索引从1开始，这是 Lua区别于其他语言的一个地方。</li><li>无法存进数组的其他数据则存储在哈希表中，它的键可以是除nil外的任意值。</li></ul><p>这样的分开存储对使用者来说完全透明，但是我们需要掌握它存储的原理和逻辑，否则会造成预想不到的性能开销。它的数据结构定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> &#123;</span></span><br><span class="line">  CommonHeader;</span><br><span class="line">  lu_byte flags;  <span class="comment">/* 1&lt;&lt;p means tagmethod(p) is not present */</span></span><br><span class="line">  lu_byte lsizenode;  <span class="comment">/* log2 of size of &#x27;node&#x27; array */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> alimit;  <span class="comment">/* &quot;limit&quot; of &#x27;array&#x27; array */</span></span><br><span class="line">  TValue *<span class="built_in">array</span>;  <span class="comment">/* array part */</span></span><br><span class="line">  Node *node;</span><br><span class="line">  Node *lastfree;  <span class="comment">/* any free position is before this position */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Table</span> *<span class="title">metatable</span>;</span></span><br><span class="line">  GCObject *gclist;</span><br><span class="line">&#125; Table;</span><br></pre></td></tr></table></figure><p>简单介绍下它的每个域：</p><ul><li>CommonHeader：可回收对象默认在头部分配的内存</li><li>flags：表示这个表提供了哪些元方法，置 1的位代表对应的元方法没有实现，元方法对应的 bit 定义在 ltm.h 文件中</li><li>lsizenode：存储哈希表的大小，它的值是以2为底的对数。比如哈希表的长度是256，那么lsizenode 的值为8，由此我们可以得到两个信息：<ul><li>哈希表扩容是在原基础上加一倍，哈希表的内存大小始终是 2 的幂</li><li>这个域之所以是 byte 类型，是因为足够了</li></ul></li><li>alimit：表示数组部分的逻辑边界，下文详解</li><li>array：指向数组部分的指针</li><li>node：指向哈希部分起始位置的指针</li><li>lastfree：指向哈希部分最后位置的指针</li><li>metatable：指向当前表的元表的指针</li><li>gclist：GC相关的链表，后续讲GC再探讨</li></ul><h1 id="alimit">alimit</h1><p><code>alimit</code> 理解为 array limit，是 Lua 5.4引入的一个字段，用于标记 Table 数组部分的<code>逻辑边界</code>。它的主要作用是动态调整数组部分的有效范围，从而优化表的访问效率。</p><p>怎么理解所谓的逻辑边界？首先，Lua对数组的内存分配并不是最大索引是多少就分配多少，而是一个和哈希表大小挂钩自适应调整大小的分配规则（下文会分析），最后数组的大小会调整为一个2的幂。而alimit 代表当前数组部分实际使用的索引范围。</p><p>先说下这个自适应调整是什么意思，假设我们有以下代码：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line">t[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">t[<span class="number">100</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>我们往一个 table中插入了两个元素，这两个元素一定会分配在数组中吗？这是不一定的。Lua会根据数组部分的有效索引和哈希部分的全部正整数key（数组下标只能是正整数）的分布情况，以一个位图算法计算出一个边界，超过这个边界的部分会存储在哈希表中，这是整个自适应调整的大致逻辑，后面讲table 相关算法时会详细分解。</p><h2 id="那为什么需要-alimit">那为什么需要 alimit ?</h2><ul><li>优化性能：在 Lua中，数组部分的大小会根据表的使用情况动态调整，但实际使用的范围可能小于分配的大小。使用alimit 可以快速判断哪些索引属于数组部分，而无需频繁操作内存。</li><li>支持稀疏数组：Lua 表可以是稀疏的，即索引并非连续的整数。alimit帮助区分哪些索引属于数组部分，哪些应该存储在哈希部分。</li></ul><h2 id="使用-alimit-的场景">使用 alimit 的场景</h2><ul><li>快速访问：通过 alimit，Lua可以快速判断某个索引是否在数组部分的有效范围内，而无需逐一检查。</li><li>表的结构发生变化：如插入或删除元素，Lua会重新评估表的分布（rehash）。在 rehash 过程中，Lua 会调整 alimit以确保数组部分的逻辑边界是最优的。</li></ul><h2id="为什么不再存储数组的实际大小物理大小">为什么不再存储数组的实际大小（物理大小）？</h2><p>首先通过 alimit可以非常迅速地计算出实际大小，两者同时存储有些浪费。alimit对于判断索引范围帮助更大，因此没有存储实际大小。</p><p>通过 alimit 算实际大小，本质上是算一个大于 alimit的最小2的幂。如果一个 table 频繁地rehash，这部分也存在一定的计算开销，Lua 考虑到了这个问题，让我们看看通过alimit 计算实际大小的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** True if value of &#x27;alimit&#x27; is equal to the real size of the array</span></span><br><span class="line"><span class="comment">** part of table &#x27;t&#x27;. (Otherwise, the array part must be larger than</span></span><br><span class="line"><span class="comment">** &#x27;alimit&#x27;.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> limitequalsasize(t)(isrealasize(t) || ispow2((t)-&gt;alimit))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Returns the real size of the &#x27;array&#x27; array</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LUAI_FUNC <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">luaH_realasize</span> <span class="params">(<span class="type">const</span> Table *t)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (limitequalsasize(t))</span><br><span class="line">    <span class="keyword">return</span> t-&gt;alimit;  <span class="comment">/* this is the size */</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size = t-&gt;alimit;</span><br><span class="line">    <span class="comment">/* compute the smallest power of 2 not smaller than &#x27;n&#x27; */</span></span><br><span class="line">    size |= (size &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    size |= (size &gt;&gt; <span class="number">2</span>);</span><br><span class="line">    size |= (size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">    size |= (size &gt;&gt; <span class="number">8</span>);</span><br><span class="line">    size |= (size &gt;&gt; <span class="number">16</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (UINT_MAX &gt;&gt; 30) &gt; 3</span></span><br><span class="line">    size |= (size &gt;&gt; <span class="number">32</span>);  <span class="comment">/* unsigned int has more than 32 bits */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    size++;</span><br><span class="line">    lua_assert(ispow2(size) &amp;&amp; size/<span class="number">2</span> &lt; t-&gt;alimit &amp;&amp; t-&gt;alimit &lt; size);</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lua 对此做出的优化是，先判断当前 table 的 alimit是否和实际大小一致，不一致再计算。它的核心是 isrealasize方法，由此我们引申出下面的源码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** About &#x27;alimit&#x27;: if &#x27;isrealasize(t)&#x27; is true, then &#x27;alimit&#x27; is the</span></span><br><span class="line"><span class="comment">** real size of &#x27;array&#x27;. Otherwise, the real size of &#x27;array&#x27; is the</span></span><br><span class="line"><span class="comment">** smallest power of two not smaller than &#x27;alimit&#x27; (or zero iff &#x27;alimit&#x27;</span></span><br><span class="line"><span class="comment">** is zero); &#x27;alimit&#x27; is then used as a hint for #t.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BITRAS(1 &lt;&lt; 7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> isrealasize(t)(!((t)-&gt;flags &amp; BITRAS))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> setrealasize(t)((t)-&gt;flags &amp;= cast_byte(~BITRAS))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> setnorealasize(t)((t)-&gt;flags |= BITRAS)</span></span><br></pre></td></tr></table></figure><p>结合上面的代码和它们的调用，这里 Lua 实际上是把结果记录在了<code>flags</code> 域中, 在第 8 位（bit 7）如果标记为 1，那么代表该表的alimit 不等于数组的实际大小。这里会产生一个疑问，flags本来是用于标记元方法是否有效，在第 8位存储，不会影响元方法的判断吗？（TM_SUB 是元方法掩码 7）</p><p>这里其实在设计上已经被切开了，当前表如果是元表，那么它的 flags域会被用于元方法标记，而不会有 BITRAS 的判断。如果当前表不是元表，那么flags 会用于标记 BITRAS</p><h1 id="哈希表的结构">哈希表的结构</h1><p><img src="LuaTable.drawio.png" alt="Table的数据结构" /><br /></p><p>上图可以看出，array 域指向一个数组部分的起始位置。node域指向一个哈希表的起始位置， lastfree 则是指向哈希表最后的位置。</p><p>这里我们需要关注下哈希表的节点，它的类型是<code>Node</code>，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Nodes for Hash tables: A pack of two TValue&#x27;s (key-value pairs)</span></span><br><span class="line"><span class="comment">** plus a &#x27;next&#x27; field to link colliding entries. The distribution</span></span><br><span class="line"><span class="comment">** of the key&#x27;s fields (&#x27;key_tt&#x27; and &#x27;key_val&#x27;) not forming a proper</span></span><br><span class="line"><span class="comment">** &#x27;TValue&#x27; allows for a smaller size for &#x27;Node&#x27; both in 4-byte</span></span><br><span class="line"><span class="comment">** and 8-byte alignments.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">NodeKey</span> &#123;</span></span><br><span class="line">    TValuefields;  <span class="comment">/* fields for value */</span></span><br><span class="line">    lu_byte key_tt;  <span class="comment">/* key type */</span></span><br><span class="line">    <span class="type">int</span> next;  <span class="comment">/* for chaining */</span></span><br><span class="line">    Value key_val;  <span class="comment">/* key value */</span></span><br><span class="line">  &#125; u;</span><br><span class="line">  TValue i_val;  <span class="comment">/* direct access to node&#x27;s value as a proper &#x27;TValue&#x27; */</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>Node 作为一个联合体，它头部的内存空间用于存储实际的值，这样可以通过i_val 域直接访问。当需要访问键和链表的内容时，结合后续的内存作为<code>NodeKey</code> 结构体访问。next 指向链表中的下一个节点，而 key_tt和 key_val 存储了键的类型和实际值</p><h1 id="表的创建和释放">表的创建和释放</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Table *<span class="title function_">luaH_new</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">  GCObject *o = luaC_newobj(L, LUA_VTABLE, <span class="keyword">sizeof</span>(Table));</span><br><span class="line">  Table *t = gco2t(o);</span><br><span class="line">  t-&gt;metatable = <span class="literal">NULL</span>;</span><br><span class="line">  t-&gt;flags = cast_byte(maskflags);  <span class="comment">/* table has no metamethod fields */</span></span><br><span class="line">  t-&gt;<span class="built_in">array</span> = <span class="literal">NULL</span>;</span><br><span class="line">  t-&gt;alimit = <span class="number">0</span>;</span><br><span class="line">  setnodevector(L, t, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">luaH_free</span> <span class="params">(lua_State *L, Table *t)</span> &#123;</span><br><span class="line">  freehash(L, t);</span><br><span class="line">  luaM_freearray(L, t-&gt;<span class="built_in">array</span>, luaH_realasize(t));</span><br><span class="line">  luaM_free(L, t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建和释放的逻辑很简单，创建时分配好内存空间，然后给初始化数组部分和哈希部分的指针。释放则是先释放掉哈希部分，然后是数组部分，最后释放掉整个表。</p><p>有一个点需要注意，设置哈希部分的逻辑是调用<code>setnodevector(L, t, 0)</code>，它的逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Creates an array for the hash part of a table with the given</span></span><br><span class="line"><span class="comment">** size, or reuses the dummy node if size is zero.</span></span><br><span class="line"><span class="comment">** The computation for size overflow is in two steps: the first</span></span><br><span class="line"><span class="comment">** comparison ensures that the shift in the second one does not</span></span><br><span class="line"><span class="comment">** overflow.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">setnodevector</span> <span class="params">(lua_State *L, Table *t, <span class="type">unsigned</span> <span class="type">int</span> size)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;  <span class="comment">/* no elements to hash part? */</span></span><br><span class="line">    t-&gt;node = cast(Node *, dummynode);  <span class="comment">/* use common &#x27;dummynode&#x27; */</span></span><br><span class="line">    t-&gt;lsizenode = <span class="number">0</span>;</span><br><span class="line">    t-&gt;lastfree = <span class="literal">NULL</span>;  <span class="comment">/* signal that it is using dummy node */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> lsize = luaO_ceillog2(size);</span><br><span class="line">    <span class="keyword">if</span> (lsize &gt; MAXHBITS || (<span class="number">1u</span> &lt;&lt; lsize) &gt; MAXHSIZE)</span><br><span class="line">      luaG_runerror(L, <span class="string">&quot;table overflow&quot;</span>);</span><br><span class="line">    size = twoto(lsize);</span><br><span class="line">    t-&gt;node = luaM_newvector(L, size, Node);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)size; i++) &#123;</span><br><span class="line">      Node *n = gnode(t, i);</span><br><span class="line">      gnext(n) = <span class="number">0</span>;</span><br><span class="line">      setnilkey(n);</span><br><span class="line">      setempty(gval(n));</span><br><span class="line">    &#125;</span><br><span class="line">    t-&gt;lsizenode = cast_byte(lsize);</span><br><span class="line">    t-&gt;lastfree = gnode(t, size);  <span class="comment">/* all positions are free */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 Lua为了减少空表的维护，定义了一个不可改写的空哈希表：dummynode。空表被初始化时，node域直接指向这个全局节点。由于它是只读的，所以不会引起线程安全问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Lua 用 table 来表示一切数据结构，为了效率，Lua 将 table 的存储分为了
&lt;code&gt;数组&lt;/code&gt; 和 &lt;code&gt;哈希表&lt;/code&gt; 两个部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组部分提供了紧凑且高效的随机访问。它的索引从1开始，这是 Lua</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    <category term="源码阅读" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="04-表" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/04-%E8%A1%A8/"/>
    
    
    <category term="Lua" scheme="https://peiyuzou.github.io/tags/Lua/"/>
    
  </entry>
  
  <entry>
    <title>3.2 字符串的相关实现</title>
    <link href="https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/03-%E5%AD%97%E7%AC%A6%E4%B8%B2/3.2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0/"/>
    <id>https://peiyuzou.github.io/wiki/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/03-%E5%AD%97%E7%AC%A6%E4%B8%B2/3.2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E7%9B%B8%E5%85%B3%E5%AE%9E%E7%8E%B0/</id>
    <published>2024-12-09T09:08:44.000Z</published>
    <updated>2024-12-09T09:35:20.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符串比较">字符串比较</h1><p>短字符串的比较很简单，由于被内部化，只需要比较内存地址即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lstring.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** equality for short strings, which are always internalized</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> eqshrstr(a,b)check_exp((a)-&gt;tt == LUA_VSHRSTR, (a) == (b))</span></span><br></pre></td></tr></table></figure><p>对于长字符串，首先比较长度，长度相同的情况下需要逐字节比较：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** equality for long strings</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">luaS_eqlngstr</span> <span class="params">(TString *a, TString *b)</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> len = a-&gt;u.lnglen;</span><br><span class="line">  lua_assert(a-&gt;tt == LUA_VLNGSTR &amp;&amp; b-&gt;tt == LUA_VLNGSTR);</span><br><span class="line">  <span class="keyword">return</span> (a == b) ||  <span class="comment">/* same instance or... */</span></span><br><span class="line">    ((len == b-&gt;u.lnglen) &amp;&amp;  <span class="comment">/* equal length and ... */</span></span><br><span class="line">     (<span class="built_in">memcmp</span>(getstr(a), getstr(b), len) == <span class="number">0</span>));  <span class="comment">/* equal contents */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="短字符串的内部化">短字符串的内部化</h1><p>直接上内部化的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lstring.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Checks whether short string exists and reuses it or creates a new one.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> TString *<span class="title function_">internshrstr</span> <span class="params">(lua_State *L, <span class="type">const</span> <span class="type">char</span> *str, <span class="type">size_t</span> l)</span> &#123;</span><br><span class="line">  TString *ts;</span><br><span class="line">  global_State *g = G(L);</span><br><span class="line">  stringtable *tb = &amp;g-&gt;strt;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> h = luaS_hash(str, l, g-&gt;seed);</span><br><span class="line">  TString **<span class="built_in">list</span> = &amp;tb-&gt;hash[lmod(h, tb-&gt;size)];</span><br><span class="line">  lua_assert(str != <span class="literal">NULL</span>);  <span class="comment">/* otherwise &#x27;memcmp&#x27;/&#x27;memcpy&#x27; are undefined */</span></span><br><span class="line">  <span class="keyword">for</span> (ts = *<span class="built_in">list</span>; ts != <span class="literal">NULL</span>; ts = ts-&gt;u.hnext) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == ts-&gt;shrlen &amp;&amp; (<span class="built_in">memcmp</span>(str, getstr(ts), l * <span class="keyword">sizeof</span>(<span class="type">char</span>)) == <span class="number">0</span>)) &#123;</span><br><span class="line">      <span class="comment">/* found! */</span></span><br><span class="line">      <span class="keyword">if</span> (isdead(g, ts))  <span class="comment">/* dead (but not collected yet)? */</span></span><br><span class="line">        changewhite(ts);  <span class="comment">/* resurrect it */</span></span><br><span class="line">      <span class="keyword">return</span> ts;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* else must create a new string */</span></span><br><span class="line">  <span class="keyword">if</span> (tb-&gt;nuse &gt;= tb-&gt;size) &#123;  <span class="comment">/* need to grow string table? */</span></span><br><span class="line">    growstrtab(L, tb);</span><br><span class="line">    <span class="built_in">list</span> = &amp;tb-&gt;hash[lmod(h, tb-&gt;size)];  <span class="comment">/* rehash with new size */</span></span><br><span class="line">  &#125;</span><br><span class="line">  ts = createstrobj(L, l, LUA_VSHRSTR, h);</span><br><span class="line">  <span class="built_in">memcpy</span>(getstr(ts), str, l * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">  ts-&gt;shrlen = cast_byte(l);</span><br><span class="line">  ts-&gt;u.hnext = *<span class="built_in">list</span>;</span><br><span class="line">  *<span class="built_in">list</span> = ts;</span><br><span class="line">  tb-&gt;nuse++;</span><br><span class="line">  <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们详细分析下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">global_State *g = G(L);</span><br><span class="line">stringtable *tb = &amp;g-&gt;strt;</span><br></pre></td></tr></table></figure><p>这里认证了短字符串存放在全局字符串表这个说法，<code>strt</code> 就是<code>string table</code> 的简写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> h = luaS_hash(str, l, g-&gt;seed);</span><br><span class="line">TString **<span class="built_in">list</span> = &amp;tb-&gt;hash[lmod(h, tb-&gt;size)];</span><br></pre></td></tr></table></figure><p><code>luaS_hash</code>在上节的Lua为应对DoS攻击做出的修改中有提到，这个函数用于计算字符串的哈希值。然后和经典的链式寻址哈希表的实现一致，lua也用形如<code>index = hash(key) % capacity</code>的逻辑计算得到哈希桶的下标。所以这里得到的 <code>list</code>就是当前字符串存储的桶（链表）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ts = *<span class="built_in">list</span>; ts != <span class="literal">NULL</span>; ts = ts-&gt;u.hnext) &#123;</span><br><span class="line">  <span class="keyword">if</span> (l == ts-&gt;shrlen &amp;&amp; (<span class="built_in">memcmp</span>(str, getstr(ts), l * <span class="keyword">sizeof</span>(<span class="type">char</span>)) == <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">/* found! */</span></span><br><span class="line">    <span class="keyword">if</span> (isdead(g, ts))  <span class="comment">/* dead (but not collected yet)? */</span></span><br><span class="line">      changewhite(ts);  <span class="comment">/* resurrect it */</span></span><br><span class="line">    <span class="keyword">return</span> ts;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这部分就是在桶中查是否有已经存过的相同字符串，（这也是内部化的核心，合并相同内容的字符串）如果有，那么就直接返回它，不用再创建。值得注意的是这里的<code>isdead</code> 和 <code>changewhite</code>的处理，原文对这里有清楚地解释：</p><blockquote><p>这里需要检查表中的字符串是否是死掉的字符串。这是因为Lua的垃圾收集过程是分步完成的。而向字符串池添加新字符串在任何步骤之间都可能发生。有可能在标记完字符串后发现有些字符串没有任何引用，但在下个步骤中又产生了相同的字符串导致这个字符串复活</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tb-&gt;nuse &gt;= tb-&gt;size) &#123;  <span class="comment">/* need to grow string table? */</span></span><br><span class="line">  growstrtab(L, tb);</span><br><span class="line">  <span class="built_in">list</span> = &amp;tb-&gt;hash[lmod(h, tb-&gt;size)];  <span class="comment">/* rehash with new size */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lstring.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">growstrtab</span> <span class="params">(lua_State *L, stringtable *tb)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (l_unlikely(tb-&gt;nuse == MAX_INT)) &#123;  <span class="comment">/* too many strings? */</span></span><br><span class="line">    luaC_fullgc(L, <span class="number">1</span>);  <span class="comment">/* try to free some... */</span></span><br><span class="line">    <span class="keyword">if</span> (tb-&gt;nuse == MAX_INT)  <span class="comment">/* still too many? */</span></span><br><span class="line">      luaM_error(L);  <span class="comment">/* cannot even create a message... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (tb-&gt;size &lt;= MAXSTRTB / <span class="number">2</span>)  <span class="comment">/* can grow string table? */</span></span><br><span class="line">    luaS_resize(L, tb-&gt;size * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** Resize the string table. If allocation fails, keep the current size.</span></span><br><span class="line"><span class="comment">** (This can degrade performance, but any non-zero size should work</span></span><br><span class="line"><span class="comment">** correctly.)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">luaS_resize</span> <span class="params">(lua_State *L, <span class="type">int</span> nsize)</span> &#123;</span><br><span class="line">  stringtable *tb = &amp;G(L)-&gt;strt;</span><br><span class="line">  <span class="type">int</span> osize = tb-&gt;size;</span><br><span class="line">  TString **newvect;</span><br><span class="line">  <span class="keyword">if</span> (nsize &lt; osize)  <span class="comment">/* shrinking table? */</span></span><br><span class="line">    tablerehash(tb-&gt;hash, osize, nsize);  <span class="comment">/* depopulate shrinking part */</span></span><br><span class="line">  newvect = luaM_reallocvector(L, tb-&gt;hash, osize, nsize, TString*);</span><br><span class="line">  <span class="keyword">if</span> (l_unlikely(newvect == <span class="literal">NULL</span>)) &#123;  <span class="comment">/* reallocation failed? */</span></span><br><span class="line">    <span class="keyword">if</span> (nsize &lt; osize)  <span class="comment">/* was it shrinking table? */</span></span><br><span class="line">      tablerehash(tb-&gt;hash, nsize, osize);  <span class="comment">/* restore to original size */</span></span><br><span class="line">    <span class="comment">/* leave table as it was */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;  <span class="comment">/* allocation succeeded */</span></span><br><span class="line">    tb-&gt;hash = newvect;</span><br><span class="line">    tb-&gt;size = nsize;</span><br><span class="line">    <span class="keyword">if</span> (nsize &gt; osize)</span><br><span class="line">      tablerehash(newvect, osize, nsize);  <span class="comment">/* rehash for new size */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是哈希表，自然离不开负载因子过大（哈希冲突严重）导致扩容这个话题，上面的代码也给出了Lua的方案，可以看出Lua的负载因子默认是1，即<code>size / capacity = 1</code> 时会触发扩容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ts = createstrobj(L, l, LUA_VSHRSTR, h);</span><br><span class="line"><span class="built_in">memcpy</span>(getstr(ts), str, l * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">ts-&gt;shrlen = cast_byte(l);</span><br><span class="line">ts-&gt;u.hnext = *<span class="built_in">list</span>;</span><br><span class="line">*<span class="built_in">list</span> = ts;</span><br><span class="line">tb-&gt;nuse++;</span><br><span class="line"><span class="keyword">return</span> ts;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** creates a new string object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> TString *<span class="title function_">createstrobj</span> <span class="params">(lua_State *L, <span class="type">size_t</span> l, <span class="type">int</span> tag, <span class="type">unsigned</span> <span class="type">int</span> h)</span> &#123;</span><br><span class="line">  TString *ts;</span><br><span class="line">  GCObject *o;</span><br><span class="line">  <span class="type">size_t</span> totalsize;  <span class="comment">/* total size of TString object */</span></span><br><span class="line">  totalsize = sizelstring(l);</span><br><span class="line">  o = luaC_newobj(L, tag, totalsize);</span><br><span class="line">  ts = gco2ts(o);</span><br><span class="line">  ts-&gt;hash = h;</span><br><span class="line">  ts-&gt;extra = <span class="number">0</span>;</span><br><span class="line">  getstr(ts)[l] = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">/* ending 0 */</span></span><br><span class="line">  <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的这部分则是创建一个新的短字符串的逻辑，其核心是<code>createstrobj</code>函数，需要注意的是，为了兼容C接口，Lua会在字符串末尾加上一个<code>\0</code>，但这个结尾符并不计算在字符串长度内</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;字符串比较&quot;&gt;字符串比较&lt;/h1&gt;
&lt;p&gt;短字符串的比较很简单，由于被内部化，只需要比较内存地址即可：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="02-编程语言" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Lua" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/"/>
    
    <category term="源码阅读" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="03-字符串" scheme="https://peiyuzou.github.io/categories/02-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Lua/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/03-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="Lua" scheme="https://peiyuzou.github.io/tags/Lua/"/>
    
  </entry>
  
</feed>
